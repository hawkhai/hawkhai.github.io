---
layout: post
title: "图像处理 -- OpenCV 4.1.2 文档整理"
author:
location: "珠海"
categories: ["图像处理"]
tags: ["OpenCV", "图像处理"]
toc: true
toclistyle:
comments:
visibility:
mathjax: true
mermaid:
glslcanvas:
codeprint:
---

OpenCV 4.1.2 文档整理，把整个文档都阅读整理了一遍。

[wechatdl](http://localhost:4000/blog/source/wechatdl/wechatdl)
[OpenCV-Python Tutorials 官方文档](https://docs.opencv.org/4.1.2/d6/d00/tutorial_py_root.html)

* OpenCV 中的 GUI 特性 Gui Features in OpenCV
    * 在这里，如何显示和保存图像和视频，控制鼠标事件以及创建轨迹栏（trackbar）。
* 核心操作 Core Operations
    * 图像的基本操作、例如像素编辑、几何变换，代码优化、一些数学工具等。
* OpenCV 中的图像处理 Image Processing in OpenCV
    * OpenCV 内部的不同图像处理函数。
* 特征检测与描述 Feature Detection and Description
    * 有关特征检测和描述符的信息
* 视频分析 Video analysis (video module)
    * 在本部分中，与对象跟踪等视频配合使用的不同技术。
* 相机校准和 3D 重建 Camera Calibration and 3D Reconstruction
    * 有关相机校准，立体成像（stereo imaging）等的信息。
* 机器学习 Machine Learning
    * OpenCV 内部的不同图像处理函数。
* 计算摄影学 Computational Photography
    * 不同的计算摄影技术如图像去噪（denoising）等。
* 目标检测（objdetect 模块） Object Detection (objdetect module)
    * 目标检测技术，例如人脸检测等。
* OpenCV-Python Binding OpenCV-Python Bindings
    * 我们将了解如何生成 OpenCV-Python Binding

启用 TBB 和 Eigen 支持：
```
cmake -D WITH_TBB=ON -D WITH_EIGEN=ON ..
```


## 图像的基本操作

Numpy 是用于快速数组计算的优化库。因此，简单地访问每个像素值并对其进行修改将非常缓慢，因此不建议使用。

对于单个像素访问，Numpy 数组方法 array.item() 和 array.itemset()) 被认为更好，但是它们始终返回标量。如果要访问所有 B、G、R 值，则需要分别调用所有的 array.item()。

更好的像素访问和编辑方法：
```python
# 访问 RED 值
>>> img.item(10,10,2)
59
# 修改 RED 值
>>> img.itemset((10,10,2), 100)
>>> img.item(10,10,2)
100
```


## 图像上的算术运算

OpenCV 加法和 Numpy 加法之间有区别。OpenCV 加法是饱和运算，而 Numpy 加法是模运算。

```python
>>> x = np.uint8([250])
>>> y = np.uint8([10])
>>> print( cv.add(x,y) ) # 250+10 = 260 => 255
[[255]]
>>> print( x+y )         # 250+10 = 260 % 256 = 4
[4]
```


## 性能优化技术

有几种技术和编码方法可以充分利用 Python 和 Numpy 的最大性能。
这里只注明相关信息，并提供重要信息来源的链接。这里要注意的主要事情是，首先尝试以一种简单的方式实现算法。
一旦它运行起来，分析它，找到瓶颈并优化它们。
1. 尽量避免在 Python 中使用循环，尤其是双 / 三重循环等。它们本来就很慢。
2. 由于 Numpy 和 OpenCV 已针对向量运算进行了优化，因此将算法 / 代码向量化到最大程度。
3. 利用缓存一致性。
4. 除非需要，否则切勿创建数组的副本。尝试改用视图。数组复制是一项昂贵的操作。

即使执行了所有这些操作后，如果你的代码仍然很慢，或者不可避免地需要使用大循环，请使用 Cython 等其他库来使其更快。


## 颜色空间

HSV 的色相范围为 [0,179]，饱和度范围为 [0,255]，值范围为 [0,255]。

对象追踪：
```python
import cv2 as cv
import numpy as np
cap = cv.VideoCapture(0)
while (1):
    # 读取帧
    _, frame = cap.read()
    # 转换颜色空间 BGR 到 HSV
    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)
    # 定义 HSV 中蓝色的范围
    lower_blue = np.array([110,50,50])
    upper_blue = np.array([130,255,255])
    # 设置 HSV 的阈值使得只取蓝色
    mask = cv.inRange(hsv, lower_blue, upper_blue)
    # 将掩膜和图像逐像素相加
    res = cv.bitwise_and(frame,frame, mask= mask)
    cv.imshow('frame',frame)
    cv.imshow('mask',mask)
    cv.imshow('res',res)
    k = cv.waitKey(5) & 0xFF
    if k == 27:
        break
cv.destroyAllWindows()
```


## 形态学转换

* 开运算（MORPH_OPEN）：先腐蚀再膨胀
* 闭运算（MORPH_CLOSE）：先膨胀再腐蚀
* 形态梯度（MORPH_GRADIENT）：膨胀图与腐蚀图之差（保留物体边缘轮廓）
* 顶帽（MORPH_TOPHAT）：原图像与开运算之差
* 黑帽（MORPH_BLACKHAT）：闭图像与原图像之差


### 开运算

开放只是侵蚀然后扩张的另一个名称。如上文所述，它对于消除噪音很有用。
opening = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)

{% include image.html url="/assets/images/211106-opencv/640z1.webp" %}


### 闭运算

闭运算与开运算相反，先扩张然后再侵蚀。在关闭前景对象内部的小孔或对象上的小黑点时很有用。
closing = cv.morphologyEx(img, cv.MORPH_CLOSE, kernel)

{% include image.html url="/assets/images/211106-opencv/640z2.webp" %}


### 顶帽

`顶帽运算（image）= 原图（image）- 开运算（image）`
所以礼帽运算得到的实际上是噪声图像。
{% include image.html url="/assets/images/211106-opencv/20200219150629131.png" %}


### 黑帽

`黑帽运算（image）= 闭运算（image）-原图（image）`
实际得到的是前景图中的黑点和小洞。
{% include image.html url="/assets/images/211106-opencv/2020021915190313.png" %}


## 图像梯度

查找图像梯度、边缘等。
我们将看到以下函数：cv.Sobel()，cv.Scharr()，cv.Laplacian() 等。
{% include image.html url="/assets/images/211106-opencv/640tidu.webp" %}


## 图像金字塔

我们将使用图像金字塔创建一个新的水果“Orapple”。
我们将看到以下功能：cv.pyrUp()，cv.pyrDown()。

有两种图像金字塔。1）高斯金字塔和 2）拉普拉斯金字塔。
拉普拉斯金字塔的层由高斯金字塔的层与高斯金字塔的高层的扩展版本之间的差形成。
{% include image.html url="/assets/images/211106-opencv/640orapple.webp" %}

1. 加载苹果和橙子的两个图像
2. 查找苹果和橙子的高斯金字塔（在此示例中，级别数为 6）
3. 在高斯金字塔中，找到其拉普拉斯金字塔
4. 然后在每个拉普拉斯金字塔级别中加入苹果的左半部分和橙子的右半部分
5. 最后从此联合图像金字塔中重建原始图像。

[Image Blending](http://pages.cs.wisc.edu/~csverma/CS766_09/ImageMosaic/imagemosaic.html)


## OpenCV 中常用的四种模糊效果

* 平均模糊（Averaging blurring）
* 高斯模糊（Gaussian blurring）
* 中值模糊（median blurring）
* 双边滤波（bilateral filtering）
    * 是高斯模糊的一个高级版本。模糊化不仅可以溶解噪声，而且还会平滑边缘。而双边滤波器能在去除噪声的同时保持边缘锐化。这是由于它不仅使用高斯分布值，还同时考虑了距离和像素值的差异。因此，需要指定 sigmaSpace 和 sigmaColor 这两个参数。
    * `cv.bilateralFilter()` 在保持边缘锐利的同时去除噪音非常有效。但与其他过滤器相比，操作速度较慢。


## 梯度（Gradient）定位边缘

```python
# Apply gradient filtering
sobel_x = cv2.Sobel(img, cv2.CV_64F, dx = 1, dy = 0, ksize = 5)
sobel_y = cv2.Sobel(img, cv2.CV_64F, dx = 0, dy = 1, ksize = 5)
blended = cv2.addWeighted(src1=sobel_x, alpha=0.5, src2=sobel_y,
                          beta=0.5, gamma=0)
laplacian = cv2.Laplacian(img, cv2.CV_64F)
```

拉普拉斯运算使用的是 x 和 y 的二阶导数，数学表达式如下。

$$
L(x, y)=\frac{\partial^{2} I}{\partial x^{2}}+\frac{\partial^{2} I}{\partial y^{2}}
$$


### 边缘检测 Canny

输入图像为原始图像，thereshold-1 即像素值低于 150 被视为非边缘，threshold-2 即像素值高于 175 被视为有效边缘。
如果该值在 150 和 175 之间，那么如果边缘像素与有效边缘相连，则仅将其视为有效边缘。

```python
cv.Canny(originalImg, 150, 175)
```


## 旋转或移动图像

```python
def rotate(img, angle, center=None):
    w, h = img.shape[:2]
    if center == None:
        center = (w//2, h//2)
        # center is the center of image from which we have to rotate
        # if it is None then it is cconsider as the center of the original image.
    rotMat = cv.getRotationMatrix2D(center, angle, 1.0)
    dim = (w, h)
    return cv.warpAffine(img, rotMat, dim)
```


## 轮廓特征


## 直方图

OpenCV 函数比 np.histogram() 快大约 40 倍。因此，尽可能使用 OpenCV 函数。

OpenCV 中的直方图均衡
```python
img = cv.imread('wiki.jpg', 0)
equ = cv.equalizeHist(img)
res = np.hstack((img, equ)) # stacking images side-by-side
cv.imwrite('res.png', res)
```

自适应直方图均衡，CLAHE（对比度受限的自适应直方图均衡）
```python
import numpy as np
import cv2 as cv
img = cv.imread('tsukuba_l.png', 0)
# create a CLAHE object (Arguments are optional).
clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
cl1 = clahe.apply(img)
cv.imwrite('clahe_2.jpg', cl1)
```


## Refs

深度学习与计算机视觉
微信号 `uncle_pn`



<hr class='reviewline'/>
<p class='reviewtip'><script type='text/javascript' src='{% include relref.html url="/assets/reviewjs/blogs/2021-11-06-opencv.md.js" %}'></script></p>
<font class='ref_snapshot'>参考资料快照</font>

- [https://docs.opencv.org/4.1.2/d6/d00/tutorial_py_root.html]({% include relrefx.html url="/backup/2021-11-06-opencv.md/docs.opencv.org/45dd6044.html" %})
- [http://pages.cs.wisc.edu/~csverma/CS766_09/ImageMosaic/imagemosaic.html]({% include relrefx.html url="/backup/2021-11-06-opencv.md/pages.cs.wisc.edu/61b3b8fc.html" %})

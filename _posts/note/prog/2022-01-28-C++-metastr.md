---
layout: post
title: "编程与调试 C++ -- C++11 模板元编程 实现编译期字符串加密"
author: 杨全海
location: "珠海"
categories: ["编程与调试"]
tags: ["编程", "C/C++"]
toc: true
toclistyle:
comments:
visibility:
mathjax:
mermaid:
glslcanvas:
codeprint:
---

反编译一个程序，我们往往通过 IDA 或者 windbg 从字符串入手。
如果我们能针对每个字符串加密，运行时解密，就能更好的把字符串信息进行隐藏。
而 C++11/C++14 的新特性 模板元编程 能实现编译期字符串加密。
并且还很好的保证了代码的可读性。

目标实现宏 `OBFUSCATED`，编译出来的二进制文件，IDA 逆向分析不包含字符串 `Baby Hai's Secret`。

```cpp
std::string stdstr = OBFUSCATED("Baby Hai's Secret");
```


## 模板元编程

这玩意号称图灵完备的，很厉害，能实现编译期间运算，主要用到 模板偏特化 & 编译优化。

* 第一个版本，实现长度为 6 的字符串的编译时加密。
* 第二个版本，实现任意长度的字符串 编译时加密。
* 第三个版本，实现任意长度的字符串 随机 key 的编译时加密。
* 第四个版本，三个算法，随机选择加密。


### 算阶乘

阶乘定义：
```
N! = 1 * 2 * 3 * 4 * ... * N
N! = N * (N - 1)!
```

```cpp
#include <iostream>
#include <type_traits>

template<int N>
struct Factorial
{
    static const int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0>
{
    static const int value = 1;
};

int main() {
    // 编译期间 Factorial<5>::value 就算出来了。
    std::cout << "Factorial(5) = " << Factorial<5>::value << std::endl;
    return 0;
}
```

生成的汇编代码：

{% include image.html url="/assets/images/220128-c++-metastr/20220128112513.png" %}

答案编译期就计算出来了，`5!` = `0x78` = `120`。


## enable_if

C++14 `enable_if`。
编译器在类型推导的过程中，会尝试推导所有的重载函数，在此过程在过程中，如果 `enable_if` 条件不满足，则会在候选函数集合中剔除此函数。

```cpp
#include <iostream>
#include <type_traits>

// 1. 只有当 T 是整数的时候，函数才存在。
template <class T>
typename std::enable_if<std::is_integral<T>::value, bool>::type
is_odd(T i) { return bool(i % 2); }

// 2. 只有当 T 是整数的时候，函数才存在。
template < class T,
    class = typename std::enable_if<std::is_integral<T>::value>::type>
    bool is_even(T i) { return !bool(i % 2); }

int main() {
    short int i = 1;  // 如果不是整数类型，编译不过。
    //float i = 1; // 模板推导失败
    std::cout << "i is odd: " << is_odd(i) << std::endl;
    std::cout << "i is even: " << is_even(i) << std::endl;
    return 0;
}
```


## 第一个版本

```cpp
#include <iostream>
#include <type_traits>

template<int... I> // 字符串的数组下标。
struct MetaString1
{
    // 编译期运算
    constexpr __forceinline MetaString1(const char* str)
        : m_buffer{ encrypt(str[I])... } { }

    // 运行时解密
    inline const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i) {
            m_buffer[i] = decrypt(m_buffer[i]);
        }
        m_buffer[sizeof...(I)] = 0;
        return m_buffer;
    }

private:
    // 加密一个字符
    constexpr char encrypt(char c) const { return c ^ 0x55; }
    // 解密一个字符
    constexpr char decrypt(char c) const { return encrypt(c); }

private:
    char m_buffer[sizeof...(I) + 1];
};

#define OBFUSCATED1(str) (MetaString1<0, 1, 2, 3, 4, 5>(str).decrypt())

int main() {
    std::cout << OBFUSCATED1("123456789") << std::endl;
    std::cout << OBFUSCATED1("123456") << std::endl;
    std::cout << OBFUSCATED1("12345") << std::endl;
    return 0;
}
```

输出：
```cpp
123456
123456
12345
```

很明显，只能处理 6 个字符串的情况。

简化一下代码，编译 Release 看看汇编代码。
```cpp
#include <iostream>
#include <type_traits>

template<int... I> // 字符串的数组下标。
struct MetaString1
{
    // 编译期运算
    constexpr __forceinline MetaString1(const char* str)
        : m_buffer{ encrypt(str[I])... } {
    }

    // 运行时解密
    const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i) {
            m_buffer[i] = decrypt(m_buffer[i]);
        }
        m_buffer[sizeof...(I)] = 0;
        return m_buffer;
    }

private:
    // 加密一个字符
    constexpr char encrypt(char c) const { return c ^ 0x55; }
    constexpr char decrypt(char c) const { return encrypt(c); }

private:
    char m_buffer[sizeof...(I) + 1];
};

int main() {
    auto str = MetaString1<0, 1, 2, 3, 4, 5, 6, 7, 8, 9>("0123456789");
    std::cout << "test";
    std::cout << str.decrypt() << std::endl;
    return 0;
}
```

编译器设置：
{% include image.html url="/assets/images/220128-c++-metastr/20220128160613.png" %}

编译后的汇编代码（都优化成了一堆 mov 指令）：
{% include image.html url="/assets/images/220128-c++-metastr/20220128160452.png" %}

Windows 是小端存储（低位在低地址）：
```
>>> "%c" % chr(0x66 ^ 0x55) '3'
>>> "%c" % chr(0x67 ^ 0x55) '2'
>>> "%c" % chr(0x64 ^ 0x55) '1'
>>> "%c" % chr(0x65 ^ 0x55) '0'
```


## 第二个版本

自动识别字符串长度。
使用偏特化为每个长度的字符串自动生成一个模板。
```cpp
// C++14 (C++1y) 新增 std::index_sequence
// MakeIndex<N>::type 生成 Indexes<0, 1, 2, 3, ..., N>
template<int... I>
struct Indexes { using type = Indexes<I..., sizeof...(I)>; };

template<int N>
struct Make_Indexes { using type = typename Make_Indexes<N - 1>::type::type; };

template<>
struct Make_Indexes<0> { using type = Indexes<>; };
```

完整版本：
```cpp
#include <iostream>
#include <type_traits>

// C++14 (C++1y) 新增 std::index_sequence
// MakeIndex<N>::type 生成 Indexes<0, 1, 2, 3, ..., N>
template<int... I>
struct Indexes { using type = Indexes<I..., sizeof...(I)>; };

template<int N>
struct Make_Indexes { using type = typename Make_Indexes<N - 1>::type::type; };

template<>
struct Make_Indexes<0> { using type = Indexes<>; };

template<typename Indexes>
struct MetaString2;

template<int... I>
struct MetaString2<Indexes<I...>>
{
    constexpr __forceinline MetaString2(const char* str)
        : m_buffer{ encrypt(str[I])... } { }

    inline const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i)
            m_buffer[i] = decrypt(m_buffer[i]);
        m_buffer[sizeof...(I)] = 0;
        return m_buffer;
    }

private:
    constexpr char encrypt(char c) const { return c ^ 0x55; }
    constexpr char decrypt(char c) const { return encrypt(c); }

private:
    char m_buffer[sizeof...(I) + 1];
};

int main() {
#define cstr "123"
    auto str = MetaString2<Make_Indexes<sizeof(cstr) - 1>::type>(cstr);
    return 0;
}
```

{% include image.html url="/assets/images/220128-c++-metastr/02.png" %}


## 第三个版本

上面的每次都是同一个密钥 `0x55`，能不能每次都采用不同的密钥呢。

用编译时 时间 `__TIME__` 作为种子，生成编译期随机数。
宏 `__COUNTER__` 是一个计数器，会从 0 开始计数，然后每次调用加 1。
`__COUNTER__` 保证每个字符串 key 都不一样，`__TIME__` 保证每次构建都不一样。

完整的编译期随机数生成算法：
```cpp
#include <iostream>
#include <type_traits>
#include <random>

namespace
{
    constexpr char time[] = __TIME__; // 24 小时格式: hh:mm:ss

    constexpr int DigitToInt(char c) { return c - '0'; }
    const int seed = DigitToInt(time[7]) + DigitToInt(time[6]) * 10 + //
        DigitToInt(time[4]) * 60 + DigitToInt(time[3]) * 600 + //
        DigitToInt(time[1]) * 3600 + DigitToInt(time[0]) * 36000;
}

// 根据 N，生成随机数 value
template<int N>
struct MetaRandomGenerator
{
private:
    static constexpr unsigned a = 16807;        // 7^5
    static constexpr unsigned m = 2147483647;   // 2^31 - 1

    static constexpr unsigned s = MetaRandomGenerator<N - 1>::value;
    static constexpr unsigned lo = a * (s & 0xFFFF); // 低 16 位乘以 16807
    static constexpr unsigned hi = a * (s >> 16);    // 高 16 位乘以 16807
    static constexpr unsigned result = lo + hi + ((hi & 0x7FFF) << 16);

public:
    static constexpr unsigned max = m;
    static constexpr unsigned value = result > m ? result - m : result;
};

template<>
struct MetaRandomGenerator<0>
{
    static constexpr unsigned value = seed;
};

template<int N, int M>
struct MetaRandom
{
    static const int value = MetaRandomGenerator<N + 1>::value % M;
};

int main() {
    // 每次构建，会是一个不同的数字。
    int v = MetaRandom<__COUNTER__, 10>::value;
    int x = MetaRandom<__COUNTER__, 10>::value;
    return 0;
}
```

完整代码：
```cpp
template<typename Indexes, int K>
struct MetaString3;

template<int... I, int K>
struct MetaString3<Indexes<I...>, K>
{
    // buffer[0] 存储 key。
    constexpr __forceinline MetaString3(const char* str)
        : m_buffer{ static_cast<char>(K), encrypt(str[I])... } { }

    // 运行时间解密。
    inline const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i)
            m_buffer[i + 1] = decrypt(m_buffer[i + 1]);
        m_buffer[sizeof...(I) + 1] = 0;
        return m_buffer + 1;
    }

private:
    constexpr char key() const { return m_buffer[0]; }
    constexpr char encrypt(char c) const { return c ^ key(); }
    constexpr char decrypt(char c) const { return encrypt(c); }

private:
    char m_buffer[sizeof...(I) + 2];
};

template<int N>
struct MetaRandomChar3
{
    // 不能超过 0x7F
    static const char value = static_cast<char>(1 + MetaRandom<N, 0x7F - 1>::value);
};

int main() {
#define cstr "1234"
    auto temp = MetaString3<Make_Indexes<sizeof(cstr) - 1>::type, \
                            MetaRandomChar3<__COUNTER__>::value>(cstr);
    return 0;
}
```


## 第四个版本

能不能实现多个算法，每次随机挑选一个呢。
实现三个算法，每次随机挑选一个。

模板偏特化 Template partial specialization：

```cpp
template<int A, int K, typename Indexes>
struct MetaString4;

template<int K, int... I>
struct MetaString4<0, K, Indexes<I...>>
{ … c ^ K … };

template<int K, int... I>
struct MetaString4<1, K, Indexes<I...>>
{ … c + K … };

#define DEF_OBFUSCATED4(str) MetaString4<MetaRandom<__COUNTER__, 2>::value, …
```

完整实现：
```cpp
// 三个参数：N - 算法，Key，Indexes - 字符串下标数组。
template<int N, char Key, typename Indexes>
struct MetaString;

template<char K, int... I>
struct MetaString<0, K, Indexes<I...>>
{
    constexpr __forceinline MetaString(const char* str)
        : m_key{ K }, m_buffer{ encrypt(str[I], K)... } { }

    inline const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i)
            m_buffer[i] = decrypt(m_buffer[i]);
        m_buffer[sizeof...(I)] = 0;
        return const_cast<const char*>(m_buffer);
    }

private:
    constexpr char key() const { return m_key; }
    constexpr char __forceinline encrypt(char c, int k) const { return c ^ k; }
    constexpr char decrypt(char c) const { return encrypt(c, key()); }

    volatile int m_key; // volatile 避免编译器过度优化。
    volatile char m_buffer[sizeof...(I) + 1];
};

template<char K, int... I>
struct MetaString<1, K, Indexes<I...>>
{
    constexpr __forceinline MetaString(const char* str)
        : m_key(K), m_buffer{ encrypt(str[I], I)... } { }

    inline const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i)
            m_buffer[i] = decrypt(m_buffer[i], i);
        m_buffer[sizeof...(I)] = 0;
        return const_cast<const char*>(m_buffer);
    }

private:
    constexpr char key(size_t position) const { return static_cast<char>(m_key + position); }
    constexpr char __forceinline encrypt(char c, size_t position) const { return c ^ key(position); }
    constexpr char decrypt(char c, size_t position) const { return encrypt(c, position); }

    volatile int m_key;
    volatile char m_buffer[sizeof...(I) + 1];
};

template<char K, int... I>
struct MetaString<2, K, Indexes<I...>>
{
    constexpr __forceinline MetaString(const char* str)
        : m_buffer{ encrypt(str[I])..., 0 } { }

    inline const char* decrypt()
    {
        for (size_t i = 0; i < sizeof...(I); ++i)
            m_buffer[i] = decrypt(m_buffer[i]);
        return const_cast<const char*>(m_buffer);
    }

private:
    // key 绝对不能为 0
    constexpr char key(char key) const { return 1 + (key % 13); }
    constexpr char __forceinline encrypt(char c) const { return c + key(K); }
    constexpr char decrypt(char c) const { return c - key(K); }

    volatile char m_buffer[sizeof...(I) + 1];
};

template<int N>
struct MetaRandomChar
{
    // 最大值 0x7F
    static const char value = static_cast<char>(1 + MetaRandom<N, 0x7F - 1>::value);
};

#define DEF_OBFUSCATED(str) MetaString<MetaRandom<__COUNTER__, 3>::value, \
                                       MetaRandomChar<__COUNTER__>::value, \
                                       Make_Indexes<sizeof(str) - 1>::type>(str)

#define OBFUSCATED(str) (DEF_OBFUSCATED(str).decrypt())

int main() {
    auto temp = DEF_OBFUSCATED("1234");
    auto cstr = temp.decrypt();
    return 0;
}
```


## 尾声

Debug 版本貌似字符串还存在，Release 版本就没有了。
只弄了 char 的情况，wchar 类似，不再累述。

* 字符串直接使用的情况：
    * `const char* str = OBFUSCATED("Baby Hai's Secret");` –- 拿到指针，指针对应的临时变量 `MetaString` 就释放了，非法用法。
    * `const std::string stdstr = OBFUSCATED("Baby Hai's Secret");` –- stdstr 完成构造，对应的临时变量 `MetaString` 才释放，正确。
* 定义和使用分离：
    * `auto metastr = DEF_OBFUSCATED("Baby Hai's Secret");`
    * `const char* str = metastr.decrypt();`

编译出来的二进制就反编译不到对应的字符串了，而且代码的可读性也保证了。



<hr class='reviewline'/>
<p class='reviewtip'><script type='text/javascript' src='{% include relref.html url="/assets/reviewjs/blogs/2022-01-28-C++-metastr.md.js" %}'></script></p>

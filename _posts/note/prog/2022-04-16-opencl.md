---
layout: post
title: "编程与调试 C++ -- OpenCL & CUDA"
author:
location: "珠海"
categories: ["编程与调试"]
tags: ["编程", "C/C++", "OpenCL"]
toc: true
toclistyle:
comments:
visibility:
mathjax:
mermaid:
glslcanvas:
codeprint:
---

并行计算。
1. CPU
    * 首先是指令集优化：SIMD (SSE, AVX, NEON)
    * 然后多线程跑：
        * OpenMP 标准
        * intel 搞的 TBB, oneTBB 等。
2. GPU
    * NVIDIA 搞的 CUDA
    * [OpenCL {% include relref_khronos.html %}](https://www.khronos.org/opencl/) 标准
        * Unlike 'GPU-only' APIs, such as Vulkan, OpenCL enables use of a diverse range of accelerators including multi-core CPUs, GPUs, DSPs, FPGAs and dedicated hardware such as inferencing engines.
    * DirectX 搞的 DirectCompute
    * 微软尝试从 C++ 语言级别搞的 C++ AMP
3. 机器学习多为 CUDA 而 挖矿程序多为 CUDA 和 OpenCL。


## OpenCL vs CUDA

OpenCL 和 nVidia CUDA 很像。

CUDA               | OpenCL
---- | ----
Thread             | Work-item
Thread block       | Work-group
global memory      | global memory
constant memory    | constant memory
shared memory      | local memory
local memory       | private memory
Grid size          | Global range
Block size         | Local range
\_\_global\_\_     | kernel
gridDim.x          | get_num_groups(0)
blockDim.x         | get_local_size(0)
blockIdx.x         | get_group_id(0)
threadIds.x        | get_local_id(0)
\_\_syncthreads    | barrier()
warp               | no equivalent


## OpenCL 基本原理

1. 准备 OpenCL 源码（C99）然后给 OpenCL。
2. OpenCL 针对目标设备，编译源码。
3. 向目标设备传输数据。（内存 到 显存）
4. 在数据上运行 kernel。（GPU 运行）
5. 把数据拖回来。（显存 到 内存）


## OpenCL C++ 伪码

```cpp
#include <cl/cl.hpp>
#include <vector>

using namespace cl;
using namespace std;

int main(int, char**)
{
    Platform platform = Platform::getDefault();

    vector<Device> devices;
    platform.getDevices(CL_DEVICE_TYPE_ALL, &devices);

    Context context(devices[0]);
    CommandQueue queue(context, devices[0]);

    Program program(context, "OpenCL C code goes here...");
    program.build();

    auto kernel = make_kernel<Buffer, Buffer>(program, "example_kernel");

    const static int Size = 1000000;
    vector<int> inputData(Size, 0), outputData(Size, 0);

    Buffer inputBuffer(context, CL_MEM_READ_ONLY, Size * sizeof(int));
    Buffer outputBuffer(context, CL_MEM_WRITE_ONLY, Size * sizeof(int));

    // 发送数据
    queue.enqueueWriteBuffer(inputBuffer, false, 0, Size * sizeof(int), inputData.data());

    // 运行 kernel
    kernel(EnqueueArgs(queue, NDRange(Size)), inputBuffer, outputBuffer);

    // 拖回数据
    queue.enqueueReadBuffer(outputBuffer, false, 0, Size * sizeof(int), outputData.data());

    queue.finish();

    return 0;
}
```


## 内核程序 OpenCL C

```c
kernel void example_kernel(global int * input, global int * output)
{
    int worker_id = get_global_id(0);

    output[worker_id] = input[worker_id] + 10 + worker_id;
}

#define MACRO(a, b) a + b

bool function(int a)
{
    float4 vector_type(0, 1, 2, 3); // 有的支持 SIMD

    vector_type *= 2;

    float v = vector_type.x; // 和 OpenGL 有点类似
    float2 v2; float8 v8; float16 v16;
    uchar uc; uint ui;

    local bool local_buffer[256]; // local 内存不能初始化。
    int lid = get_local_id(0);
    if (lid < 256)
        local_buffer[lid] = (uc8.S1 == uc);

    barrier(CLK_LOCAL_MEM_FENCE);

    if (lid < 256 && lid > 1)
        return local_buffer[lid - 1];

    return false;
}
```


## OpenCL 性能优化

* 提前编译一次，再多次使用。
* 数据传输，只传必要的，只需要的时候才传。
* 运算能力往往高于带宽，kernel 拷贝到 local array 快于读取 global memory。
    * **Global data access** Devices generally have more compute power than they have global memory bandwith
        kernels that read multiple values from global memory can be accelerated by copying the data in a local array
* 简单的多个 kernels 序列，性能不如一个大 kernel 直接一次运算。超大 kernel 可能会超出 硬件能力。
    * A sequence of simple kernels will perform less than one kernel doing all the calculations at once.
        But a very big kernel can suffer from private or local memory exhaustion on some devices and will have less performance
        (this is usually not a problem except for very complex algorithms).


## 性能对比

实现图片模糊，对比性能。

```
---------------------------------------------------------------
|                  LERP                                       |
---------------------------------------------------------------
CPU:    72.6 ms.
CPU MT: 365.9 ms.
OpenCL: 2.8 ms, Process 1.1 ms (39.5%), Copy 1.7 ms (60.5%)
GLSL:   38.8 ms, Process 4.2 ms (10.9%), Copy 34.5 ms (89.1%)
---------------------------------------------------------------
|                  BOX BLUR                                   |
---------------------------------------------------------------
CPU:    5085.4 ms.
CPU MT: 2379.6 ms.
OpenCL: 10.6 ms, Process 9.4 ms (88.7%), Copy 1.2 ms (11.3%)
GLSL:   25.8 ms, Process -1.0 ms (-3.9%), Copy 26.8 ms (103.9%)
---------------------------------------------------------------
|                  GAUSSIAN BLUR                              |
---------------------------------------------------------------
CPU:    5739.2 ms.
CPU MT: 581.8 ms.
OpenCL: 11.8 ms, Process 10.7 ms (90.1%), Copy 1.2 ms (9.9%)
GLSL:   24.6 ms, Process -1.0 ms (-4.1%), Copy 25.6 ms (104.1%)
---------------------------------------------------------------
|                  SEPARABLE GAUSSIAN BLUR                    |
---------------------------------------------------------------
CPU:    1373.6 ms.
CPU MT: 1195.4 ms.
OpenCL: 2.4 ms, Process 1.3 ms (51.6%), Copy 1.2 ms (48.4%)
GLSL:   14.2 ms, Process -1.0 ms (-7.0%), Copy 15.2 ms (107.0%)
```


## Notes

* C++ Wrapper for OpenCL : www.khronos.org/registry/cl/specs/opencl-cplusplus-1.2.pdf
* OpenCL Reference : www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/
* Quick reference card : www.khronos.org/registry/cl/sdk/1.2/docs/OpenCL-1.2-refcard.pdf
* Complete OpenCL tutorial : www.cmsoft.com.br/index.php?option=com_content&view=category&layout=blog&id=41&Itemid=75



<hr class='reviewline'/>
<p class='reviewtip'><script type='text/javascript' src='{% include relref.html url="/assets/reviewjs/blogs/2022-04-16-opencl.md.js" %}'></script></p>
<font class='ref_snapshot'>参考资料快照</font>

- [https://www.khronos.org/opencl/]({% include relrefx.html url="/backup/2022-04-16-opencl.md/www.khronos.org/299e65e9.html" %})

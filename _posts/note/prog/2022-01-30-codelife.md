---
layout: post
title: "编程与调试 C++ -- 代码精进之路：从码农到工匠"
author: 杨全海
location: "珠海"
categories: ["编程与调试"]
tags: ["编程", "C/C++"]
toc: true
toclistyle:
comments:
visibility:
mathjax:
mermaid:
glslcanvas:
codeprint:
---

技艺部分（第 1~7 章）
思想部分（第 8~11 章）
实践部分（第 12、13 章）

> “Talk is cheap, show me the code”


## 第 1 章 命名

代码即文档，可读性好的代码应该有一定的自明性，也就是不借助注释和文档，代码本身就能显性化地表达开发者的意图。


### 方法名约定

| CRUD 操作 | 方法名约定 |
| ---- | ---- |
| 新增 | create |
| 添加 | add |
| 删除 | remove |
| 修改 | update |
| 查询（单个结果） | get |
| 查询（多个结果） | list |
| 分页查询 | page |
| 统计 | count |


### 使用对仗词

* add/remove
* increment/decrement
* open/close
* begin/end
* insert/delete
* show/hide
* create/destroy
* lock/unlock
* source/target
* first/last
* min/max
* start/stop
* get/set
* next/previous
* up/down
* old/new


### 中间变量

我们要通过 Regex 来获得字符串中的值，并放到 map 中。
```java
Matcher matcher = headerPattern.matcher(line);
if (matcher.find()) {
    headers.put(matcher.group(1), matcher.group(2));
}
```

用中间变量，可以写成如下形式：
```java
Matcher matcher = headerPattern.matcher(line);
if (matcher.find()) {
    String key = matcher.group(1);
    String value = matcher.group(2);
    headers.put(key, value);
}
```


## 第 2 章 规范


### 埋点规范

在阿里巴巴有一个超级位置模型（Super Position Model，SPM）的埋点规范，用于统计分析各种场景的用户行为数据。
比如，淘宝社区电商业务（xTao）为外部合作伙伴（外站）提供的一套跟踪引导成交效果数据的解决方案，其中就用到了 SPM。

例如，一个跟踪点击到宝贝详情页的引导成交效果数据的 SPM 示例，其导购链接为
<http://detail.tmall.com/item.htm?id=3716461318&spm=2014.123456789.1.2>。

3456789.1.2 叫作 SPM 编码，是用于跟踪页面模块位置的编码，标准 SPM 编码由 4 段组成，采用 a.b.c.d 的格式。
* a 代表站点类型，对于 xTao 合作伙伴（外站），a 为固定值，a=2014。
* b 代表外站 ID（即外站所使用的 TOP appkey），比如你的站点使用的 TOP appkey=123456789，则 b=123456789。
* c 代表 b 站点上的频道 ID，比如外站某个团购频道、某个逛街频道、某个试用频道等。
* d 代表 c 频道上的页面 ID，比如某个团购详情页、某个宝贝详情页、某个试用详情页等。

通过基于这套规范采集的数据，我们可以利用 SPM 编码的不同层次来做不同维度的导购效果跟踪分析。
* 单独统计 spm 的 a 部分，我们可以知道某一类站点的访问和点击情况，以及后续引导和成交情况。
* 单独统计 spm 的 a.b 部分，我们可以评估某一个站点的访问和点击效果，以及后续引导和成交情况。
* 单独统计 spm 的 a.b.c 部分，我们可以评估某一个站点上某一频道的访问和点击效果，以及后续引导和成交情况。
* 单独统计 spm 的 a.b.c.d 部分，我们可以评估某一个频道上某一具体页面的点击效果，以及后续引导和成交情况。


## 第 3 章 函数


### 优化判空

```java
if (user != null) {
    Address address = user.getAddress();
    if (address != null) {
        Country country = address.getCountry();
        if (country != null) {
            String isocode = country.getIsocode();
            if (isocode != null) {
                isocode = isocode.toUpperCase();
            }
        }
    }
}
```

```java
String isocode = Optional.ofNullable(user)
                         .flatMap(User::getAddress)
                         .flatMap(Address::getCountry)
                         .map(Country::getIsocode)
                         .orElse("default");
```
可以看到，新的写法比旧的判空方式在复杂度和简洁性上都提升了很多，简洁也是一种美。


### SLAP

抽象层次一致性（Single Level of Abstration Principle，SLAP），是和组合函数密切相关的一个原则。
组合函数要求将一个大函数拆成多个子函数的组合，而 SLAP 要求函数体中的内容必须在同一个抽象层次上。
如果高层次抽象和底层细节杂糅在一起，就会显得凌乱，难以理解。

举个例子，假如有一个冲泡咖啡的原始需求，其制作咖啡的过程分为 3 步。

（1）倒入咖啡粉。（2）加入沸水。（3）搅拌。

其伪代码（pseudo code）如下：
```java
public void makeCoffee() {
    pourCoffeePowder();
    pourWater();
    stir();
}
```

如果要加入新的需求，比如需要允许选择不同的咖啡粉，以及选择不同的风味，那么代码就会变成这样：

```java
public void makeCoffee(boolean isMilkCoffee, boolean isSweetTooth, CoffeeType type) {
    // 选择咖啡粉
    if (type == CAPPUCCINO) {
        pourCappuccinoPowder();
    } else if (type == BLACK) {
        pourBlackPowder();
    } else if (type == MOCHA) {
        pourMochaPowder();
    } else if (type == LATTE) {
        pourLattePowder();
    } else if (type == ESPRESSO) {
        pourEspressoPowder();
    }
    // 加入沸水
    pourWater();
    // 选择口味
    if (isMilkCoffee) {
        pourMilk();
    }
    if (isSweetTooth) {
        addSugar();
    }
    // 搅拌
    stir();
}
```

如果继续有更多的需求加入，那么代码会进一步恶化，最后变成一个谁也看不懂且难以维护的逻辑迷宫。

再回看上面的代码，新需求的引入当然是根本原因。但除此之外，另一个原因是新代码已经不再满足 SLAP 了。具体选择用什么样的咖啡粉是倒入咖啡粉这个步骤应该去考虑的实现细节，和主流程步骤不在一个抽象层次上。同理，加奶和加糖也是实现细节。

因此，在引入新需求以后，制作咖啡的主要步骤从原来的 3 步变成了 4 步。

（1）倒入咖啡粉，会有不同的选择。（2）加入沸水。（3）调味，根据需求加糖或加奶。（4）搅拌。

按照组合函数和 SLAP 原则，我们要在入口函数中只显示业务处理的主要步骤。具体的实现细节通过私有方法进行封装，并通过抽象层次一致性来保证，一个函数中的抽象在同一个水平上，而不是高层抽象和实现细节混杂在一起。

根据 SLAP 原则，我们可以将代码重构为：
```java
public void makeCoffee(boolean isMilkCoffee, boolean isSweetTooth, CoffeeType type) {
    // 选择咖啡粉
    pourCoffeePowder(type);
    // 加入沸水
    pourWater();
    // 选择口味
    flavor(isMilkCoffee, isSweetTooth);
    // 搅拌 stir();
}

private void flavor(boolean isMilkCoffee, boolean isSweetTooth) {
    if (isMilkCoffee) {
        pourMilk();
    }
    if (isSweetTooth) {
        addSugar();
    }
}

private void pourCoffeePowder(CoffeeType type) {
    if (type == CAPPUCCINO) {
        pourCappuccinoPowder();
    } else if (type == BLACK) {
        pourBlackPowder();
    } else if (type == MOCHA) {
        pourMochaPowder();
    } else if (type == LATTE) {
        pourLattePowder();
    } else if (type == ESPRESSO) {
        pourEspressoPowder();
    }
}
```

重构后的 makeCoffee() 又重新变得整洁如初了，满足 SLAP 实际上是构筑了代码结构的金字塔。
金字塔结构是一种自上而下的，符合人类思维逻辑的表达方式。关于金字塔原理的更多内容，请参考 8.5.3 节。

在构筑金字塔的过程中，要求金字塔的每一层要属于同一个逻辑范畴、同一个抽象层次。在这一点上，金字塔原理和 SLAP 是相通的，世界就是如此奇妙，很多道理在不同的领域同样适用。

上面列举了 Spring 源码中的一个“坏味道”，接下来我们来看 Spring 的“好味道”。在 Spring 中，做上下文初始化的核心类 AbstractApplicationContext 的 refresh() 函数为我们在遵循 SLAP 方面做了一个很好的示范。

```java
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // Prepare this context for refreshing.
        prepareRefresh();
        // Tell the subclass to refresh the internal bean factory.
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();
        // Prepare the bean factory for use in this context.
        prepareBeanFactory(beanFactory);
        try {
            // Allows post processing of the bean factory in context subclasses.
            postProcessBeanFactory(beanFactory);
            // Invoke factory processors registered as beans in the context.
            invokeBeanFactoryPostProcessors(beanFactory);
            // Register bean processors that intercept bean creation.
            registerBeanPostProcessors(beanFactory);
            // Initialize message source for this context.
            initMessageSource();
            // Initialize event multicaster for this context.
            initApplicationEventMulticaster();
            // Initialize other special beans in specific context subclasses.
            onRefresh();
            // Check for listener beans and register them.
            registerListeners();
            // Instantiate all remaining(non-lazy-init)singletons.
            finishBeanFactoryInitialization(beanFactory);
            // Last step: publish corresponding event.
            finishRefresh();
        } catch (BeansException ex) {
            // Destroy already created singletons to avoid dangling resources.
            destroyBeans();
            // Reset 'active' flag.
            cancelRefresh(ex);
            // Propagate exception to caller.
            throw ex;
        } finally {
            // Reset common introspection caches in Spring's core,
            // since we might not ever need metadata for singleton
            // beans anymore...
            resetCommonCaches();
        }
    }
}
```

试想，如果上面的代码逻辑不是这样写，而是平铺在 refresh() 函数中，结果会是怎样？


## 第 4 章 设计原则


### SOLID 概览

SOLID 是 5 个设计原则开头字母的缩写，其本身就有“稳定的”的意思，寓意是“遵从SOLID原则可以建立稳定、灵活、健壮的系统”。5 个原则分别如下。

* Single Responsibility Principle（SRP）：单一职责原则。
* Open Close Principle（OCP）：开闭原则。
* Liskov Substitution Principle（LSP）：里氏替换原则。
* Interface Segregation Principle（ISP）：接口隔离原则。
* Dependency Inversion Principle（DIP）：依赖倒置原则。

开闭原则和里氏代换原则是设计目标；单一职责原则、接口分隔原则和依赖倒置原则是设计方法。


## 第 5 章 设计模式

{% include image.html url="/assets/images/220130-codelife/img_ae080b16a7d0405d8b9b45e2fc543268.png" %}



<hr class='reviewline'/>
<p class='reviewtip'><script type='text/javascript' src='{% include relref.html url="/assets/reviewjs/blogs/2022-01-30-codelife.md.js" %}'></script></p>
<font class='ref_snapshot'>参考资料快照</font>

- [http://detail.tmall.com/item.htm?id=3716461318&spm=2014.123456789.1.2]({% include relrefx.html url="/backup/2022-01-30-codelife.md/detail.tmall.com/d9890fa2.htm" %})

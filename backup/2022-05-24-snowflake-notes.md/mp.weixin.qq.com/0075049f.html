---
title : 自动快照存档
---

* TIME: 2022-05-24 23:19:50
* URL: <https://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458436558&idx=1&sn=770b20ad3eb60dbb20c83a59f83c8b48&chksm=b18ff34486f87a52514c67a59d4702e7f2ffc59b9a13f8cd4718b7ec28b79c38ae304eb4167c&scene=178&cur_album_id=2293635948628279298>

-----

# 逆向角度看C++部分特性

唱过阡陌  [ 看雪学苑 ](javascript:void\(0\);)

**看雪学苑** ![]()

微信号 ikanxue

功能介绍 致力于移动与安全研究的开发者社区，看雪学院(kanxue.com)官方微信公众帐号。

____

_2022-04-02 17:59_ _发表于_

收录于合集 #“雪花”创作激励计划 68个

![图片](https://mmbiz.qpic.cn/sz_mmbiz_jpg/1UG7KPNHN8Edqm0iaLicibArzJ2Guib4IFQUtZUXCs0NpicCqQmibXIibib7rEWMkqgnm6a1K3OWrMa5fO1aRbO2tQurkg/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)  

本文为看雪论坛优秀‍‍‍文章  
看雪论坛作者ID：唱过阡陌

  

  

####  **单/多继承**

  

 **单继承**

  

测试源码：

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    #define MAIN __attribute__((constructor))#define NOINLINE __attribute__((__noinline__))  
    class BaseClass{public:    int a,b;    BaseClass(int mA=1,int mB=2,int mC=3,int mD=4){        this->a = mA;        this->b = mB;        this->c = mC;        this->d = mD;    }private:    int c;protected:    int d;};  
    class ChildClass: public BaseClass{public:    int m,n;    ChildClass(int mM=5,int mN=6){        this->m = mM;        this->n = mN;    }};  
    MAINvoid test0(){    auto* baseClass = new BaseClass();    LOGD("baseClass   : %p sizeof: %d ",baseClass,sizeof(*baseClass));  
        auto* child1 = new ChildClass(10,20);    LOGD("child1  : %p sizeof: %d", child1, sizeof(*child1));}

  
LOG日志：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)内存情况：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)可以看到实际上单继承就是把
baseClass 的成员变量完全copy了一份放在了我们childClass的前面。  
 **多继承**

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
     // 新增一个BaseNewClass，让ChildClass:BaseClass继承这两个Classclass BaseNewClass{public:    int p,q;    BaseNewClass(int mP=10,int mQ=11){        this->p = mP;        this->q = mQ;    }};  
    class ChildClass:BaseClass,BaseNewClass{public:    int m,n;    ChildClass(int mM=5,int mN=6){        this->m = mM;        this->n = mN;    }};

  *   *   *   *   *   *   *   *   * 

    
    
    // LOG()日志D/ZZZ: baseClass   : 0xf216dd70 sizeof: 16D/ZZZ: childClass  : 0xea17e280 sizeof: 32  
    // 内存情况[Pixel XL::XXX]-> seeHexA(0xea17e280,32)           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFea17e280  01 00 00 00 02 00 00 00 03 00 00 00 04 00 00 00  ................ea17e290  0a 00 00 00 0b 00 00 00 05 00 00 00 06 00 00 00  ................

  
其实也都是成员变量按顺序往后排就完事。

####  

####  **虚函数**

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
     // 测试源码class BaseClass{public:    int a,b;    BaseClass(int mA=1,int mB=2,int mC=3,int mD=4){        this->a = mA;        this->b = mB;        this->c = mC;        this->d = mD;    }    virtual void showLOG(){        LOGD("Called BaseClass showLOG");    }    virtual void showLOG1(){        LOGD("Called BaseClass showLOG1");    }private:    int c;protected:    int d;};  
    class ChildClass:BaseClass{public:    int m,n;    ChildClass(int mM=5,int mN=6){        this->m = mM;        this->n = mN;    }    virtual void showLOG(){        LOGD("Called ChildClass showLOG");    }    virtual void showLOG1(){        LOGD("Called ChildClass showLOG1");    }    virtual void showLOG2(){        LOGD("Called ChildClass showLOG2");    }};  
    MAINvoid test0(){    auto* baseClass = new BaseClass();    LOGD("baseClass   : %p sizeof: %d",baseClass,sizeof(*baseClass));  
        auto* childClass = new ChildClass();    LOGD("childClass  : %p sizeof: %d",childClass,sizeof(*childClass));}

  

  *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    // 日志D/ZZZ: baseClass   : 0xe75a7648 sizeof: 20D/ZZZ: childClass  : 0xe75d8d00 sizeof: 28  
    // 内存情况[Pixel XL::XXX]-> seeHexA(0xe75a7648,20)           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFe75a7648  24 59 5f d2 01 00 00 00 02 00 00 00 03 00 00 00  $Y_.............e75a7658  04 00 00 00                                      ....[Pixel XL::XXX]-> seeHexA(0xe75d8d00,28)           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFe75d8d00  3c 59 5f d2 01 00 00 00 02 00 00 00 03 00 00 00  <Y_.............e75d8d10  04 00 00 00 05 00 00 00 06 00 00 00              ............

  
由上我们可以看到这两个Class的地址的开始位置都多了一个指针，指针后面的才是我们真实的结构体值，这第一个指针就是
vptr(虚函数指针)，指向了虚函数表，然后再去读一下这个指针。

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    //读取vptr指向的位置[Pixel XL::XXX]-> seeHexA(ptr(0xe75a7648).readPointer(),0x20)           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFd25f5924  b1 fa 5a d2 c9 fa 5a d2 d4 60 5f d2 39 29 5f d2  ..Z...Z..`_.9)_.d25f5934  00 00 00 00 48 59 5f d2 e1 fa 5a d2 f9 fa 5a d2  ....HY_...Z...Z.  
    [Pixel XL::XXX]-> Module.findBaseAddress("libdynamic.so")"0xd2593000"[Pixel XL::XXX]-> ptr(0xd25f5924).readPointer().sub(0xd2593000)"0x1cab1"[Pixel XL::XXX]-> ptr(0xd25f5928).readPointer().sub(0xd2593000)"0x1cac9"[Pixel XL::XXX]-> ptr(0xd25f592c).readPointer().sub(0xd2593000)"0x630d4"[Pixel XL::XXX]-> ptr(0xd25f5930).readPointer().sub(0xd2593000)"0x5f939"

  
此时打开IDA验证一下这前两个地址就是真实的函数地址。  
// IDA查看地址：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
同理我们去看看另一个childClass类也会得到类似的结果：

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    //[Pixel XL::XXX]-> seeHexA(ptr(0xe75d8d00).readPointer(),0x20)           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFd25f593c  e1 fa 5a d2 f9 fa 5a d2 11 fb 5a d2 30 61 5f d2  ..Z...Z...Z.0a_.d25f594c  44 29 5f d2 00 00 00 00 01 00 00 00 2c 59 5f d2  D)_.........,Y_.  
    [Pixel XL::XXX]-> ptr(0xd25f593c).readPointer().sub(0xd2593000)"0x1cae1"[Pixel XL::XXX]-> ptr(0xd25f5940).readPointer().sub(0xd2593000)"0x1caf9"[Pixel XL::XXX]-> ptr(0xd25f5944).readPointer().sub(0xd2593000)"0x1cb11"[Pixel XL::XXX]-> ptr(0xd25f5948).readPointer().sub(0xd2593000)"0x63130"[Pixel XL::XXX]-> ptr(0xd25f594c).readPointer().sub(0xd2593000)"0x5f944"

  
第一二三个：明显就是对应的虚函数具体的函数地址。第四五个：应该是和 **C++中的RTTI机制** 相关。 // IDA查看地址：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
简单归纳一下：  
① 继承这种操作其实就是得到了一个父类数据结构的副本，他们的vptr和属于子类部分的数据结构都是独有的。  
② 继承后父类的虚函数表也会被子类完全继承。若无覆盖时，子类的虚函数表会完全拷贝一份父类的虚函数表项，并将自己子类的虚函数表项拼接在上表后面。  
③ 如果子类覆盖了父类的某一个虚函数，虚函数表项值改变顺序不变。  
这里简单的提及了一下，更详细的关于虚函数的介绍可以查看 这篇文章（
_https://blog.csdn.net/smartgps2008/article/details/90745271_ ）。 至于里面提到的关于 安全性
的反思：  
① Base1 b1 = new Derive(); 将子类的指针转为一个父类指针，只是在c++语法上限制了其对部分操作的可能性。
"子类中的未覆盖父类的成员函数" ，对它的理解应该是：它本是是什么还是什么，语法上的限制完全可以使用指针操作来实现一定程度和语法的背道而驰。他提出的第二点
*"访问non-public的虚函数" 其实和上述这一点也差不多的意思。  
②
补充一点：其实对于继承中的成员变量也有同样类似的效果，父类不管把成员的访问权限设置为什么，其实子类都有一个完整的拷贝，同样可以通过指针操作绕过c++语法的禁止，去访问并修改父类非公开成员变量。

####  

####  **拷贝构造**

####  

####  源码以及汇编情况：

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    NOINLINEvoid test1(ChildClass* cls){    cls->showLOG();}  
    NOINLINEvoid test2(ChildClass &cls){    cls.showLOG();}  
    NOINLINEvoid test3(ChildClass cls){    cls.showLOG1();}  
    NOINLINEChildClass test4(ChildClass cls){    return cls;}  
    MAINvoid test0(){    auto* baseClass = new BaseClass();    LOGD("baseClass   : %p sizeof: %d  typeid: %s",baseClass,sizeof(*baseClass),typeid(baseClass).name());  
        auto* child1 = new ChildClass(10,20);    LOGD("child1  : %p sizeof: %d  typeid: %d", child1, sizeof(*child1), typeid(child1).hash_code());  
        auto* child2 = new ChildClass(*child1);    child2->showLOG();  
        test1(child2);    test2(*child2);    test3(*child2);    test4(*child2);}

  
// 全局视图：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

列举出以下的几种情况：函数参数值传递（值传递和引用传递）  
参见 test1 test2
可见：值传递对于基础数据类型会直接mov出一个副本，值传递对象(class/struct)的话会调用对象的拷贝构造函数得到一个新的副本，所以对于类对象太大的情况建议使用指针传递或者使用引用传递（指针传递和引用传递在汇编层面其实是一样的都是传递了一个指针[见上图]）。  
参见 test3 可见：test3进行了值传递，在进入函数前先对ChildClass调用了一次拷贝构造函数，将栈上拷贝出来的该类传递进了 test3。  
函数返回值  
参见 test4 可见：test4 和 test3
同样在调用前都先调用了一次拷贝构造函数，但是test4的第一个参数是在栈上提前申请好预留给test4返回的空间，第二个参数为拷贝好的指向副本的类指针，进入test4后也会发现在内部在调用了一次拷贝构造函数，也就是说值传递加上返回值这种写法相比直接引用传递会多调用两次拷贝构造函数。  
从一个类创建另一个类  
参见 test1(v4)
上面的两句：其实也是调用的拷贝构造函数，v4指向的拷贝好的类在栈上的首地址，第一个代表读取vptr，第二个代表读取vtable的第一个函数（child2->showLOG();就是ChildClass的第一个虚函数），然后再把自己（v4）当成this传递给这个虚函数调用。  
拷贝构造拷贝父类  
详见下图：// 由编译器为我们生成的拷贝构造函数  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  

  *   *   *   *   * 

    
    
    ChildClass(const ChildClass &child){    this->m = child.m;    this->n = 12;    LOGD("called ChildClass拷贝构造函数");}

  
//
由我们自己编写的拷贝构造函数：![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)//
虚函数表：  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
由此可见调用子类的拷贝构造函数会先调用父类的构造函数，然后在调用当前类的拷贝构造，这里的off_85600就是 vptr
，从虚函数表中也可以看见，子类覆盖了父类的虚函数就会指向子类的虚函数。  
若没有覆盖，表项中依旧是指向父类的函数地址，而且顺序是按照父类的虚函数表顺序排列，子类中父类没有的虚函数会按顺序继续排在后面，不同类的虚函数表其实都是在编译期就已经确定了的，不同类的虚函数表处于临近的内存区域。  

####  **类的 构造/析构 函数调用时机**

####  

####  详见下图（ChildClass中新增了一个析构函数），// 新增析构函数：

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

####  

####  **类继承权限**

####  

####
类的继承权限并不会影响子类继承父类子类所拥有的父类的成员变量个数，换句话说，不管父类的成员变量是什么权限，之类都完全拥有一份父类的成员变量的拷贝（这里就不展示）。

####  

####  **类型的强转**

####  

#### 主要是针对 dynamic_cast 向下转型的情况。

  *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    BaseClass* baseTmp = dynamic_cast<BaseClass*>(child1);if (baseTmp!= nullptr){    baseTmp->showLOG1();}  
    BaseClass* baseTmp1 = static_cast<BaseClass*>(child1);if (baseTmp1!= nullptr){    baseTmp1->showLOG1();}  
    ChildClass* baseTmp2 = dynamic_cast<ChildClass*>(baseTmp);if (baseTmp2!= nullptr){    baseTmp2->showLOG1();}

  
// 向下转型  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

由上两图可见对于类 向上转型 dynamic_cast 和 static_cast 本质是一样的，没有做任何处理。  
dynamic_cast 向下转型的时候是借助了 RTTI 机制，就是我们前面图中看到的vptr->vtable
除了虚函数以后的指针标识该类的类型用于动态类型转换，同样也是typeid这个操作符的信息来源，具体可以参考 这篇文章（
_http://c.biancheng.net/view/2343.html_ ）。  
其实虚表什么的都是在编译期间就已经完全确定了，之前还误解以为动态类型转换中的向上转型可以让该子对象调用已经被子对象覆盖的父对象的方法，想多了想多了...
但是如果真想实现这样的"向上转型"也不是不行，借助指针去操作虚函数表即可 ↓  
  
// 实现所谓的"向上转型"  
  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
// 效果图  
  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
最后两条日志可见，我们对同一对象调用 showLOG() 一个是父函数，一个是子函数，对应代码 815 和 819 行。  

####  **简介 lambda**

####  

####  细节介绍参考

#### 这个（ _https://en.cppreference.com/w/cpp/language/lambda_ ） 和

#### 这篇文章（ _https://zhuanlan.zhihu.com/p/384314474_ ）

  

引用传递和值传递  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

####  

####  **关于lambda表达式分为三部分解析**

#####  

#####  1、表达式位于类中 （为了看到最原始的实现，不要开编译器优化）

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    #define xASM(x) __asm __volatile__ (x)using namespace std;  
    class testA{private:    int tempInt0 = 123;    int tempInt1 = 321;    int tempInt2 = 110;public:    testA(){        testFunction();    }  
        NOINLINE    void testFunction(){        [&]()-> void {            LOGD("testA anonymous_0 -> tempInt2:%d",this->tempInt2);        }();  
            []()-> void {            xASM("MOV r4, r0":::"r4");            int** tmp = nullptr;            xASM("MOV %0, r4":"=r"(tmp)::);            LOGD("testA anonymous_1 -> tempInt0:%d",**(tmp + 0x1));        }();  
            []()-> void {            xASM("MOV r4, r0":::"r4");            int tmp = 0;            xASM("LDR r4, [r4, #0x8]":::"r4");            xASM("LDR r4, [r4, #0x4]":::"r4");            xASM("MOV %0, r4":"=r"(tmp)::"r4");            LOGD("testA anonymous_2 -> tempInt1:%d",tmp);        }();    }};

  
构造以及调用testFunction  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
testFunction汇编也可以明显看到被IDA识别为了lambda表达式。  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
从这里我们可以看到虽然源码后面两个lambda表达式虽然没有捕获参数，但是依旧有一个栈地址的传递(可以理解为一个空 this)。
传递栈上地址逐个相差一个指针长度。  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  * 

    
    
    0x4*6 = 24(0x18)  sp+0x4 sp+0x8 sp+0xc

  
上述源代码中没有表现出来，即便是空 lambda 实现，编译器依旧会传递一个栈上地址过去，这里也不做展示了。  
然后后面两个 lambda 实现主要是为了实践，即使不捕获任何的参数，依旧可以拿到类实例，以及去读取类成员变量。  
在类里面的 lambda 可以理解为对 () 的重载（被IDA也是识别为重载 operator()）。  
读取类成员变量日志  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

#####  

##### 2、表达式位于类外无捕获参数

  *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    NOINLINEvoid testB(){    auto testNoCatch = [](int s) -> int {        LOGD("testB called lambda function : %d", ++s);        return s;    };  
        LOGD("testB testNoCatch ---> %p",*testNoCatch);  
    //    using TypeFunc = int(*)(int);    auto testNoCatchNew = *testNoCatch;    testNoCatchNew(5);    testNoCatch(10);}

  
表达式位于类外无捕获参数  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
中间函数用来返回lambda函数真实的地址  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
中间跳板函数  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
lambda函数的实现，和普通函数没有啥差别。  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

类外 lambda 函数，*lambda 都会生产这样的一个跳转逻辑。  

类内 lambda 函数不管有没有捕获参数都是直接理解为匿名类重载 () 运算符。

  
testB 日志  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

#####  

##### 3、表达式位于类外有捕获参数

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    NOINLINEvoid testC(){    int a = 10;    int* b = new int(11);    auto c = make_unique<int>(12);    auto* d = new float(13);  
        auto testNoCatch = [](int s,int t) -> void {        LOGD("testC called lambda function : %d", s+t);    };  
        auto testCatch = [=,&c,&d](int s) -> void {        LOGD("testC called lambda function : { %d} | { %d，%d，%d，%f}", ++s,a,*b,*c,*d);    };  
    //    LOGD("testC  testNoCatch typeid:%s | testCatch typeid:%s",typeid(testNoCatch).name(),typeid(testCatch).name());    LOGD("testC ------ ");    testNoCatch(3,4);    testCatch(2);  
        // &testCatch 拿到的是他准备好的参数在栈区的首地址    LOGD("testC &testCatch %p", &testCatch);    LOGD("testC &testNoCatch %p", &testNoCatch);  
        void* funcAddress = nullptr;    auto testCatchNew= [=,&c,&d,&funcAddress](int s) -> void {//        xASM("MOV %0, lr":"=r"(funcAddress)::);//        [&funcAddress]()-> void{//            if (funcAddress == nullptr) xASM("MOV %0, lr":"=r"(funcAddress)::);//        }();        LOGD("testC called lambda function : { %d} | { %d，%d，%d，%f}", ++s,a,*b,*c,*d);    };  
        testCatchNew(3);    LOGD(" %p ", funcAddress);    free(b);}

  
IDA反汇编  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
testC 日志  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)从
sub_319EC(v7, 3, 4) → testNoCatch(3, 4)  
可以看出 [] 捕获的参数其实都在第一个参数，lambda的传参在 第二个参数往后，结合把lambda理解为一个重载 () 运算符的类也是自洽的。  
从 sub_31A4C(v6, 2) → testCatch(2);  
再去对应看v6的参数，也就可以更加理解，lambda 表达式引用传递和值传递的区别，源码中的 c为一个类 （理解为→ 构造 : sub_3198C(v10,
&v9); | 析构 : sub_31BB4(v10);），栈传参的时候源码中的引用传递放在最前面，其次按顺序传递参数。  
从 sub_3198C(v10, &v9); 和 sub_31BB4(v10)  
sub_3198C(v10, &v9) → auto c = make_unique<int>(12);  
sub_31BB4(v10) → 作用域结束，对unique指针的析构。  
从 上图 29 30 行可见：对带捕获参数的 lambda 表达式取地址得到的只是 匿名类(分配在栈上)的首地址，其实从栈的角度看也是待传参数数组的首地址。  
没有带捕获参数的 lambda 表达式 基本上可以等价于一个普通函数，函数地址通过 来获得（编译器针对表达式特殊处理的）；带捕获参数的 lambda 表达式
不能使用 ，如果使用 & 只能获得该匿名类首地址，而且 匿名lambda类的构造函数可以理解为inline构造。  
lambda 表达式可以使用 [=] / [&] 捕获外部 值传递 /
引用传递，编译器只会把使用到的变量按照对应传递方式传递给匿名lambda类，没用到的变量不会被拷贝。

#####  

由此上结论我们可以将 dobby hook 稍微封装一下。
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)
registerHook的重载第三个参数（Callback）本来是想用模板的但是好像不太行。 得到一个类似于java函数回调一样的写法。  
这里srcCall可以用一个变长参数简写一下代码。![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

#####  

##### 函数返回对象

  *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   * 

    
    
    class testClass {public:    int a = 10;    int b = 11;    int c = 12;    int d = 13;    testClass(){        LOGD("testClass");    }     void callTest() {        LOGD("callTest");    }}; NOINLINEtestClass getTestClass() {    auto tmp = testClass();    LOGD("getTestClass %p %d",&tmp,tmp.c);    return tmp;} void testRetClass() {    testClass tt = getTestClass();    LOGD("testRetClass b -> %d",tt.d);}

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)“SUB
SP, SP, #24” 4*6 总计开辟了 6 个位置，最下面的那个位置(fp-0x4) 用于存放栈检查的fp或者说成sp。  
  
正常情况下 class() 构造出来的类就在当前函数栈中，但是这里有一个特例：对于在 函数getTestClass 中
创建在栈上的class(tmp)，实际上他真实存在的位置是在 函数testRetClass 的栈上 位置
{fp-0x8,fp-0x14},最顶上的那个位置（sp）是空的（在这里分配栈最小差值0x8），结合上述描述再去看地址 0x4F5FC
就是logd中的第三个参数 “tt.d”。  
ps：如果这里的 class 只有三个成员变量，这里的 “SUB SP, SP, #0x18” 将会变成 “SUB SP, SP,
#0x10”,刚好用满栈的四个位置。  
对于地址 0x4F5E8 这里的这个函数调用就是对 类testClass 的初始化，传递了第一个地址（函数testRetClass栈地址）进去 对 int
a，b，c，d 的初始化就放在 “LOGD("testClass");” 之前。  

#####  **模板类的实现**

  
模板类的实现  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
实现  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  * 它的上一层是一个 plt 跳转。

  * 使用模板对应生成了多个实现方法。

  
该文章作为日常学习理解的记录，理解可能又不准确的地方，欢迎大佬们指出！  
  
  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

  

 **看雪ID：唱过阡陌**

https://bbs.pediy.com/user-home-868525.htm

*本文由看雪论坛 唱过阡陌 原创，转载请注明来自看雪社区

  

[![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458432554&idx=1&sn=c2fae9d4ea7ea778a2420b1eaf9c3049&chksm=b18f84a086f80db6cce2e1d3374a2b2302c05e3155b02da0702b9698d873ceef0647ea3ac5ae&scene=21#wechat_redirect)

  

 **#** **往期推荐  
**

1.[CVE-2014-4113提权漏洞学习笔记](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458436393&idx=1&sn=ba0b123c2f6bbb8a064eb98c8f072883&chksm=b18ff3a386f87ab545263604908d5ea80e31f71151d4cbe88e32032b5e84d1703cf672077a2d&scene=21#wechat_redirect)  

2.[Go语言模糊测试工具：Go-
Fuzz](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458436361&idx=1&sn=958edb34ca25f9d92fb82eeb805b4882&chksm=b18ff38386f87a95a93eb8421c6c38eafba637102f260a222bd78ffeb0b637f2d88a4f3e6db7&scene=21#wechat_redirect)

3.[关于黑客泄漏nvidia
Windows显卡驱动代码分析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458435353&idx=1&sn=d083ac0895a4da3cb79bf48a095a6ac2&chksm=b18f8f9386f80685afabc66b558c5699da68d263250d019e5fa285807136c7efe3852c32120d&scene=21#wechat_redirect)

4.[一个BLE智能手环的分析](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458435277&idx=1&sn=d88c653fff7d382ef439d0efa57e2fba&chksm=b18f8e4786f80751ae4423ece82db91f147d73b125c8c1aed7079dc0d00f84aba8e69fe46d24&scene=21#wechat_redirect)

5.[VT虚拟化技术笔记](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458435257&idx=1&sn=4eb2253d86aca58137430161f49ae884&chksm=b18f8e3386f80725a1d67e05c8f217ae53c097c3ca88428735a80d287ebb5686e6750b5a121e&scene=21#wechat_redirect)

6.[通过DWARF
Expression将代码隐藏在栈展开过程中](http://mp.weixin.qq.com/s?__biz=MjM5NTc2MDYxMw==&mid=2458435194&idx=1&sn=993e8680a0ac340939597cac74ffc2ab&chksm=b18f8ef086f807e6c616a2e7e0d6b2b2777b26dbef6858c602c84be38c491c4b21f66f4a7580&scene=21#wechat_redirect)
**  
**

  
  
![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)  
  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

 **球分享**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

 **球点赞**

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

 **球在看**

  

  

![图片](data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==)

点击“阅读原文”，了解更多！

预览时标签不可点

收录于合集 #

个

上一篇 下一篇

[阅读原文](javascript:;)

喜欢此内容的人还喜欢

基于 FFI 的 PyFlink 下一代 Python 运行时介绍

基于 FFI 的 PyFlink 下一代 Python 运行时介绍

...

Apache Flink

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

这个C语言大坑，你见过没？

这个C语言大坑，你见过没？

...

嵌入式微处理器

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

Python 脚本打包 exe，auto-py-to-exe来帮你！

Python 脚本打包 exe，auto-py-to-exe来帮你！

...

杰哥的IT之旅

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

**写留言**

[取消](javascript:;)

[](javascript:; "轻点两下打开表情键盘")留言

 **我的留言**

[写留言](javascript:;)

 __正在加载

展开我的留言

留言被精选后将公开

**精选留言**

[写留言](javascript:;)

[写留言](javascript:;)

 __正在加载

已无更多数据

 __

[发消息](javascript:;)

关闭 __

 **写留言**

提交更多 __

 __正在加载

 __

[表情](javascript:;)

 __正在加载

 **留言** __

![](/mp/qrcode?scene=10000004&size=102&__biz=MjM5NTc2MDYxMw==&mid=2458436558&idx=1&sn=770b20ad3eb60dbb20c83a59f83c8b48&send_time=)

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。 视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看


---
title : 自动快照存档
---

* TIME: 2021-11-02 15:20:17
* URL: <https://mp.weixin.qq.com/s/l5eYzkYAzR-m21-iYBoyCw>

-----

#  OpenGL 之 帧缓冲 使用实践

原创 glumes [ 音视频开发进阶 ](javascript:void\(0\);)

**音视频开发进阶** ![]()

微信号 glumes_blog

功能介绍 抖音多媒体开发工程师，分享 Android 应用开发、图形图像渲染、音视频等相关内容，与你一同技术成长进阶~~~

____

_2018-09-05_

收录于话题 #OpenGL 学习专题 22个内容

帧缓冲(Framebuffer Object)，简称 `FBO`，在渲染绘制中， 图像最终都是绘制到 FBO 上的，一般都是默认的 FBO
上，也就是我们的屏幕。

除此之外，还可以创建自己的 FBO，用来作为绘制的载体，当在自己的 FBO 上绘制好了之后，可以再把绘制内容显示到屏幕上，实现一个双缓冲的绘制。

FBO 实际上是由颜色附件、深度附件、模板附件组成的，作为着色器各方面（一般包括颜色、深度、深度值）绘制结果存储的逻辑对象。

渲染缓冲(Renderbuffer Object)，简称 `RBO`，由应用程序分配的 2D 图像缓冲区，可以用于分配和存储 **深度** 和 **模板**
值，也可以用作 FBO 的 _深度_ 或者 _模板_ 附件，另外，纹理也可以作为 FBO 的颜色和深度附件。

帧缓冲与渲染缓冲和纹理的关系如下：

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/e1icyHPvia5MYSxqy86bq8qKfdicnNnBU9UIlMGuxL9HYxUj9obdM9ghTCILLR4BbmA8UYxXLYHllU2cvHawyxz5A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 使用概述

帧缓冲的使用，首先就创建对应的帧缓冲对象，然后给它添加对应的附件，比如颜色附件或者深度附件等。

接着就是切换到帧缓冲渲染，在帧缓冲中进行绘制，此时绘制的内容都是记录在上一步添加的颜色附件或者深度附件上了。

然后切换到屏幕的缓冲区，这时可以把帧缓冲中记录的颜色或者深度信息取出来，再把他们绘制到屏幕上。

帧缓冲的使用看似很简单，但是用处却很普遍，使用帧缓冲可以在一些相机应用中做美颜处理、滤镜处理，也可以用来作贴纸等等效果。

## 使用步骤

### 创建 FBO

按照上面的步骤，首先是创建 FBO 。

    
    
    1        int[] framebuffers = new int[1];  
    2        GLES20.glGenFramebuffers(1, framebuffers, 0);  
    

和 OpenGL 中创建的大多对象相同，都是通过一个 `int` 型对象来表示的。

接下来就可以给这个 FBO 添加一些附件了。

### 绑定纹理

    
    
    1// 把纹理绑定到颜色附件  
    2GLES20.glFramebufferTexture2D(  
    3    GLES20.GL_FRAMEBUFFER,   
    4    GLES20.GL_COLOR_ATTACHMENT0, // 作为颜色附件  
    5    GLES20.GL_TEXTURE_2D,   
    6    fboTextureId,   
    7    0);  
    

通过 `glFramebufferTexture2D` 函数可以将纹理绑定到 FBO 上作为附件，在绑定时有多种附件选项可以选择。

  * GL_COLOR_ATTACHMENT0

    * 颜色附件

  * GL_DEPTH_ATTACHMENT

    * 深度附件

  * GL_STENCIL_ATTACHMENT

    * 模板附件

当然作为纹理，只有颜色和深度两种可以选择。

如果是使用 OpenGL 3.x 版本，在绑定 FBO 时，还可以选择是绑定只读还是只写的 FBO。

  * GL_READ_FRAMEBUFFER

    * 只读的 FBO

  * GL_DRAW_FRAMEBUFFER

    * 只写的 FBO 

如果是使用 `GL_FRAMEBUFFER` 的话，那么读写皆可以。

### 绑定渲染缓冲

除了纹理之外，还可以绑定到渲染缓冲。

首先还是创建一个渲染缓冲对象：

    
    
    1        int[] renderbuffers = new int[1];  
    2        GLES20.glGenRenderbuffers(1, renderbuffers, 0);  
    

之后，要绑定到当前的渲染缓冲对象，并初始化渲染缓冲对象的数据存储，再把它添加到 FBO 上。

    
    
    1// 绑定到当前渲染缓冲对象  
    2GLES20.glBindRenderbuffer(GLES20.GL_RENDERBUFFER, renderbufferId);  
    3// 初始化渲染数据存储  
    4GLES20.glRenderbufferStorage(GLES20.GL_RENDERBUFFER, GLES20.GL_DEPTH_ATTACHMENT, width, height);  
    5// 将渲染缓冲添加到 FBO 上  
    6GLES20.glFramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT, GLES20.GL_RENDERBUFFER, renderbufferId);  
    

绑定渲染缓冲对象，并且初始化数据存储这一步有点类似于创建纹理并且初始化的操作。

    
    
    1        // 绑定纹理  
    2        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);  
    3        // 初始化纹理数据  
    4        GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGB, width, height,  
    5                0, GLES20.GL_RGB, GLES20.GL_UNSIGNED_SHORT_5_6_5, null);  
    

### 渲染

在渲染时，先渲染到 FBO 上，在渲染到屏幕上。

首先要切换到 FBO 进行渲染：

    
    
    1GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId);  
    

如果 `fboId` 参数为 0 ，则代表切换到默认的屏幕上进行绘制。

此时就可以进行正常的绘制，由添加的附件去记录绘制的信息。

    
    
    1// 加载纹理  
    2int textureId = TextureHelper.loadTexture(context, R.drawable.lgq);  
    3// 将纹理绘制到 FBO 上  
    4mTextureRect.drawSelf(textureId);  
    

在 FBO 上绘制一张纹理贴图，此时 FBO 所绑定的颜色附件，会记录下纹理贴图的所有颜色内容。

也就是说，FBO 所绑定的纹理作为颜色附件，此时它已经被渲染上了颜色，而这个颜色就是我们绘制的内容，那么接下来就可以使用 FBO 绑定的纹理继续用来绘制。

    
    
    1        // 切换到屏幕的缓冲区  
    2        GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);  
    3        // 使用 FBO 所绑定的纹理进行绘制  
    4        mTextureRect.drawSelf(fboTextureId);  
    

切换到屏幕的缓冲区后，直接使用 FBO 绑定的纹理进行绘制，此时看到的效果和未使用 FBO 是相同的。

但是内部的绘制就是完全不一样了。

文章中具体代码部分，可以参考我的 Github 项目，欢迎 Star 。

> https://github.com/glumes/AndroidOpenGLTutorial

## 参考

  1. https://blog.csdn.net/cauchyweierstrass/article/details/53166940

  2. 《OpenGL ES 3.x 游戏开发下卷》

  

推荐文章：

1\. [OpenGL 之 EGL
使用实践](http://mp.weixin.qq.com/s?__biz=MzA4MjU1MDk3Ng==&mid=2451526566&idx=1&sn=44eae0fe0d0f758789fa29fc41109018&chksm=886ffa09bf18731f8e45f98de2bcc86c407b239499c2874a11f451dd8622f57f628588b9dd66&scene=21#wechat_redirect)  

2\. [OpenGL
深度测试与精度值的那些事](http://mp.weixin.qq.com/s?__biz=MzA4MjU1MDk3Ng==&mid=2451526500&idx=1&sn=ae56d8b2b5551bae610b18b21cc6556f&chksm=886ffacbbf1873ddf8190aafaecde5718f2a652eb205bce7fc99b4b123c7702ba84673fc98ca&scene=21#wechat_redirect)

3\. [Android JNI 之 Bitmap
操作](http://mp.weixin.qq.com/s?__biz=MzA4MjU1MDk3Ng==&mid=2451526517&idx=1&sn=5efb4fec9c45fedeecd0057a2e093a83&chksm=886ffadabf1873cc0bd2dcf9dce0c1fdd995c70751cb96071f1ce4f45b9b9a78433bd2c30cf8&scene=21#wechat_redirect)

欢迎关注微信公众号：【纸上浅谈】，获得最新文章推送~~~

![图片](https://mmbiz.qpic.cn/mmbiz_gif/e1icyHPvia5MYSxqy86bq8qKfdicnNnBU9ULVj1AMf4hIQHbfZ9NyCazk7bSjZNg5Rol5Nkhr4ylezCdicl8Wmwib0g/640?wx_fmt=gif&tp=webp&wxfrom=5&wx_lazy=1)扫码关注

  

![]()

glumes

多少不重要，交个朋友💪

![赞赏二维码]() **微信扫一扫赞赏作者** __赞赏

已喜欢，[对作者说句悄悄话](javascript:;)

取消 __

#### 发送给作者

发送

最多40字，当前共字

[](javascript:;) 人赞赏

上一页 [1](javascript:;)/3 下一页

长按二维码向我转账

多少不重要，交个朋友💪

受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。

预览时标签不可点

收录于话题 #

个

上一篇 下一篇

阅读原文

阅读

分享 收藏

赞 在看

____已同步到看一看[写下你的想法](javascript:;)

前往“发现”-“看一看”浏览“朋友在看”

![示意图](//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_like_comment55871f.png)

前往看一看

**看一看入口已关闭**

在“设置”-“通用”-“发现页管理”打开“看一看”入口

[我知道了](javascript:;)

__

已发送

取消 __

####  发送到看一看

发送

OpenGL 之 帧缓冲 使用实践

最多200字，当前共字

__

发送中

喜欢此内容的人还喜欢

WebRTC 实现 Android 传屏 demo

WebRTC 实现 Android 传屏 demo

音视频开发进阶

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

双11买的秋冬单品, 这4件百搭实用超划算

双11买的秋冬单品, 这4件百搭实用超划算

This is CF

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

很环保！拜登炫超长豪华车队，小胖墩又装死了

很环保！拜登炫超长豪华车队，小胖墩又装死了

后沙月光

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

![](/mp/qrcode?scene=10000004&size=102&__biz=MzA4MjU1MDk3Ng==&mid=2451526569&idx=1&sn=b3eb001db2308b469ada2ce2fae04f04&send_time=)

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。 视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

__


---
title : 自动快照存档
---

* TIME: 2023-08-01 14:30:27
* URL: <https://cheetahfun.feishu.cn/docs/doccnMJnXaHGq9raQCrtCiQpfjf>

-----

模板编程

添加快捷方式

最近修改: 2022年2月21日

共有 0 个协作者

+0

分享

0

![](https://s1-imfile.feishucdn.com/static-
resource/v1/83553ca7-e075-48c5-a3f0-0639643cb7ag~?image_size=noop&cut_type=&quality=&format=image&sticker_format=.webp)

  * [模板编程](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#HIT5Q9)
  * [模板常用关键字](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#GpZC4x)
  * [模板参数](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#wrnakI)
  * [模板模板参数（Template Template）](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#IeY3BM)
  * [模板函数](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#c2JGNT)
  * [模板类(结构体)](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#kbVHZO)
  * [模板变量](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#TTbQlr)
  * [模板特化](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#Fsm0ba)
  * [全特化与偏特化](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#tHt3s6)
  * [模板参数包](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#v73Ffl)
  * [std::tuple和std::index_sequence](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#8Fw9h4)
  * [tuple的简单实现](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#fNsxUM)
  * [优先级](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#ZlN7GP)
  * [函数](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#emdwPg)
  * [类（结构体）](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#VibfI3)
  * [模板元编程](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#qv5sKl)
  * [integral_constant](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#mHAh4h)
  * [enable_if](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#QGJMsl)
  * [conditional](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#NzcSqs)
  * [检测语法是否正确](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#KqrSxG)
  * [void_t](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#NhxQP2)
  * [错误示例](/docs/doccnMJnXaHGq9raQCrtCiQpfjf#Tkb5Fz)

  

模板常用关键字​

  

​

C++

    
    
    1template、typename、class、constexpr、static_assert、auto、decltype、using​
    
    2template、typename、class 自不用说，模板编程最常用的东西，后面部分c++新提出来的，​
    
    3又或者是相对比较有深度的东西，其中using其实和typedef差不多，​
    
    4区别在于using更方便，且可以进行模板类型定义，后续具体阐述。​

​

  

​

C++

    
    
    1template<typename Type = int>​
    
    2Type func()​
    
    3{​
    
    4}​
    
    5​
    
    6template<typename _Ty, typename _Alloc = std::allocator<_Ty>>​
    
    7class vector​
    
    8{​
    
    9...​
    
    10}​
    
    11模板参数的写法如下:​
    
    12typename[class] Type = DefaultType​
    
    13他跟函数参数的申明有点类似：​
    
    14可以写成:​
    
    15typename                       //通常用于声明，常见模板模板参数​
    
    16typename Type                 //一般模板参数定义​
    
    17typename = DefaultType        //带默认参数，缺省类型定义。​
    
    18typename Type = DefaultType   //带默认类型的模板参数定义​
    
    19例如：​
    
    20template<typename Type, typename = std::enable_if_t<std::is_pod<Type>>>​
    
    21Type func(){} --- [1]​
    
    22这种写法通常是为验证前一个参数，这里表示验证Type是否为POD类型。​
    
    23​
    
    24还有一种写法如下:​
    
    25template<typename Type, std::enable_if_t<std::is_pod<Type>, int>>>​
    
    26Type func(){} ---[2]​
    
    27这种写法更简洁一点。​
    
    28​
    
    29在C++11以前是用其它方法验证的, 如下所示：​
    
    30template<typename Type>​
    
    31std::enable_if_t<std::is_pod<Type, Type>> ​
    
    32func(){}  ---[3]​
    
    33​
    
    34这三种写法意思一样，我们进行如下调用。​
    
    35​
    
    36func(std::vector<int>()); //报错，由于std::vector<int>不是pod类型​
    
    37代入[1]​
    
    38template<typename std::vector<int>, typename = >​
    
    39std::vector<int> func(){}​
    
    40​
    
    41代入[2]​
    
    42template<typename std::vector<int>,  >​
    
    43std::vector<int> func(){}​
    
    44​
    
    45代入[3]​
    
    46template<typename std::vector<int>>​
    
    47func(){}​
    
    48​
    
    49可以看出当输入参数类型为非POD类型时，推导的函数原型语法不正确。​
    
    50而如下调用：​
    
    51func(int());​
    
    52代入[1]​
    
    53template<typename int, typename = void>​
    
    54int func(){}​
    
    55​
    
    56代入[2]​
    
    57template<typename int, int>​
    
    58int func(){}​
    
    59​
    
    60代入[3]​
    
    61template<typename int>​
    
    62int func(){}​
    
    63​

​

  

​

C++

    
    
    1template<typename T, template<typename> typename container = std::vector>​
    
    2void func(const container<T>& con)​
    
    3{​
    
    4}​
    
    5​
    
    6模板模板参数定义比较简单，只需要在typename之间加上template<typename...>​
    
    7​
    
    8这里说明两点:​
    
    91. 上述写法是错误的。​
    
    102. 如果是函数的定义，还有其它写法，也能达到实际的效果。​
    
    11​
    
    12错误的原因是: std::vector并不只有一个模板参数，上诉申明会报错。​
    
    13应该写成：​
    
    14template<typename T, template<typename, typename> container = std::vector>​
    
    15void func(const container<T, std::allocator<T> >& con)​
    
    16{​
    
    17}​
    
    18​
    
    19其它写法如下：​
    
    20template<typename T, typename container>​
    
    21void func(const container& t)​
    
    22{​
    
    23}​
    
    24好吧，上诉写法仍然是错的。​
    
    25func(std::list<int>()) 显然会报错，因为无法推导出T。​
    
    26所以可以写成:​
    
    27template<typename Container, typename T = typename Container::value_type>​
    
    28void func(const Container& con)​
    
    29{   ​
    
    30}​
    
    31​
    
    32这里是假定Container中定义了value_type这个类型，​
    
    33事实上标准库的容器，都在内部定义了value_type, 因为是假定，所以需要写成​
    
    34typename Container::value_type​
    
    35​
    
    36当然这是建立在标准库的容器下，如果是第三方库实现的容器，例如Qt库中的容器。​
    
    37容器类，并没有定义value_type，同样模板参数也没有_Alloc这个参数，显然这个模板函数​
    
    38就不适用了，那么该如下实现呢？​
    
    39​
    
    40可以使用重载​
    
    41template<typename T, template<typename> typename Container>​
    
    42void func(const Container<T>& con)​
    
    43{​
    
    44    //dosomething weith con.​
    
    45}​
    
    46​
    
    47template<typename T, typename Alloc, ​
    
    48    template<typename, typename> typename Container>​
    
    49void func(const Container<T, Alloc>& con)​
    
    50{​
    
    51    //dosomething weith con.​
    
    52}​
    
    53​
    
    54暂没有什么好的方式，让这两份代码，变成一份。​

​

  

​

C++

    
    
    1template<typename Type>​
    
    2void func(Type type)​
    
    3{​
    
    4}​

​

  

​

C++

    
    
    1func(1);​
    
    2func(1.3);​
    
    3func('a'); ​
    
    4//...​

​

  

​

C++

    
    
    1template<typename Type>​
    
    2struct TempClass​
    
    3{​
    
    4};​

​

  

​

C++

    
    
    1// only function types and reference types can't be const qualified​
    
    2template <class _Ty>​
    
    3constexpr bool is_function_v = !is_const_v<const _Ty> && !is_reference_v<_Ty>;​
    
    4​
    
    5这里有一个知识点，就是只有引用类型和函数类型不能加const修饰，也不是说不能加，是加了没用。​
    
    6可是仔细琢磨这句话，总感觉哪里不对，引用类型不能加const修饰？？？？​
    
    7我们经常写函数成:​
    
    8void func(const A& a);​
    
    9这不是const引用吗？？？​
    
    10​
    
    11其实这就又要说到运算符归并优先级(这里不是运算符，但同样有一个归并优先级)。​
    
    12实际上 const A& a <==> (const A)& a  而不是 const (A&) a， 实际不能这样加括号哈。​
    
    13我们可以这样验证。​
    
    14typedef (const A) constA;​
    
    15constA& a = 3;​
    
    16typedef (A&) ARef;​
    
    17const ARef a = 3; //报错， a是 A& 类型，无法用常量赋值。​
    
    18简单的说 ARef 用 const 修饰是没有用的， 修饰了也是ARef, 右值引用也是同样的。​
    
    19这里的函数，仅仅是指类成员函数和全局函数，跟其它仿函数无关。 ​

​

  

​

C++

    
    
    1template<typename T>​
    
    2void func(const T& t)​
    
    3{​
    
    4}​
    
    5​
    
    6//重载版本​
    
    7void func(const int&)​
    
    8{​
    
    9}​
    
    10​
    
    11//特化版本​
    
    12template<>​
    
    13void func<int>(const int&)​
    
    14{​
    
    15}​
    
    16​
    
    17模板函数之所以没有偏特化，个人感觉完全就是因为函数有重载的概念。​
    
    18不需要偏特化。​
    
    19例如:​
    
    20template<typename Func>​
    
    21static void bind(typename QtPrivate::FunctionPointer<Func>::Object* receiver,​
    
    22     Func func)​
    
    23{​
    
    24​
    
    25}​
    
    26​
    
    27template<typename Func>​
    
    28static void bind(QObject* receiver, Func func)​
    
    29{​
    
    30}​
    
    31​
    
    32这里表示，如果第二个参数是类成员函数，且第一个参数是该类的成员对象指针，则适配第一个函数​
    
    33否则会适配第二个。​
    
    34​

​

  

​

C++

    
    
    1template<typename T, typename U>​
    
    2class TempA​
    
    3{​
    
    4};​
    
    5​
    
    6//偏特化​
    
    7template<typename T>​
    
    8class TempA<T, int>​
    
    9{​
    
    10};​
    
    11​
    
    12//全特化​
    
    13template<>​
    
    14class TempA<int, double>​
    
    15{​
    
    16};​

​

  

​

C++

    
    
    1template<typename T>​
    
    2class TempB​
    
    3{​
    
    4};​
    
    5​
    
    6template<typename T, typename U>​
    
    7class TempB<std::pair<T, U>>​
    
    8{​
    
    9};​

​

  

​

C++

    
    
    1template<int eType, typename ...Args>​
    
    2class KCustomEvent : public QEvent​
    
    3{​
    
    4public:​
    
    5​
    
    6    enum { ArgumentCount = sizeof...(Args) };​
    
    7    using Arguments = QtPrivate::List<Args...>;​
    
    8    using TupleData = std::tuple<Args...>;​
    
    9    using Function = std::function<void(Args...)>;​
    
    10    ​
    
    11    template<typename Object>​
    
    12    using MemberFunction = void(Object::*)(Args...);​
    
    13​
    
    14    using IndexesList = typename QtPrivate::Indexes<sizeof...(Args)>::Value;​
    
    15    static constexpr QEvent::Type EventType = (QEvent::Type)eType;​
    
    16};​

​

  

​

C++

    
    
    1sizeof...(Args) // <==> Args参数的个数。​

​

  

​

C++

    
    
    1template <bool _First_value, class _First, class... _Rest>​
    
    2struct _Conjunction ​
    
    3{ // handle false trait or last trait​
    
    4    using type = _First;​
    
    5};​
    
    6​
    
    7template <class _True, class _Next, class... _Rest>​
    
    8struct _Conjunction<true, _True, _Next, _Rest...> ​
    
    9{ // the first trait is true, try the next one​
    
    10    using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;​
    
    11};​
    
    12​

​

  

​

C++

    
    
    1template<int ...Indexes, typename ...Args>​
    
    2inline void KDataPack::_pack(IndexTuple<Indexes...>, const Args & ...args)​
    
    3{​
    
    4        int a[] = { (_packOne<Indexes>(args), 0)... }; //不赋值会被优化​
    
    5        Q_UNUSED(a); ​
    
    6}​
    
    7​
    
    8//这个函数的意思，挨个打包参数​
    
    9​
    
    10/*​
    
    11int a = (void, 0); // a == 0, 逗号运算符就是取最后一个表达式值为返回结果​
    
    12int b[] = { (void, 0), (void, 0)} // b <==> {0, 1}​
    
    13因此下面声明一个数组a, 目的在于执行前一个表达式。​
    
    14对于_pack(IndexTupe, "abc", 1, 2.5}的函数体为​
    
    15{​
    
    16        int a[] = { (_packOne<0>("abc"), 0), (_packOne<1>(1), 0), ​
    
    17        (_packOne<2>(2.5), 0)};​
    
    18}​
    
    19*/​

​

  

​

C++

    
    
    1std::tuple<double, int> <==> std::pair<double, int> 类似​
    
    2区别在于std::tuple支持任意模板参数个数。​
    
    3而std::index_sequence是真正在编译期才需要的东西，而且和模板参数包高度结合。​

​

  

​

C++

    
    
    1int func1(int x)​
    
    2{​
    
    3    return x;​
    
    4}​
    
    5int func2(int x)​
    
    6{​
    
    7    return 2 * x；​
    
    8}​
    
    9int func3(int x)​
    
    10{​
    
    11    return x * x;​
    
    12}​

​

  

​

C++

    
    
    1template<typename ...Args>​
    
    2class Argments​
    
    3{​
    
    4public:​
    
    5​
    
    6    Argments(const Args& ...args)​
    
    7        :m_args(std::make_tuple(args...))​
    
    8    {​
    
    9       ​
    
    10    }​
    
    11​
    
    12    template<typename Func>​
    
    13    void call(Func func)​
    
    14    {​
    
    15        func(std::get<Args>(args)...);​
    
    16    }​
    
    17    ​
    
    18private:​
    
    19​
    
    20    std::tuple<Args...>  m_args;​
    
    21    ​
    
    22}​

​

  

​

C++

    
    
    1Argments<int, int> arg(3, 4);​
    
    2arg.call([](int a, int b)​
    
    3{​
    
    4    std::cout << a + b << std::endl;​
    
    5});    ​
    
    6//输出的结果是6，这是因为std::tuple<int, int> a = {3, 4};​
    
    7//std::get<int>(a) === 3​

​

  

​

C++

    
    
    1std::get<0>(a); == 3​
    
    2std::get<1>(a); == 4​
    
    3//那现在问题又来了，怎么将 Args...转换为 0,1,2...呢？​
    
    4这就是std::index_sequence的作用了。​
    
    5​
    
    6index_sequence_for<Args...>  <==> std::index_sequence<0...>​
    
    7举例说明:​
    
    8index_sequence_for<int, double, int, char> <==> std::index_sequence<0, 1, 2, 3>​

​

  

​

C++

    
    
    1template<typename ...Args>​
    
    2class Argments​
    
    3{​
    
    4public:​
    
    5​
    
    6    using IndexS = std::index_sequence_for<Args...>;​
    
    7    Argments(const Args& ...args)​
    
    8        :m_args(std::make_tuple(args...))​
    
    9    {​
    
    10       ​
    
    11    }​
    
    12​
    
    13    //更优化的版本应该要推导函数的返回值，这里只是简化版本​
    
    14    template<typename Func>​
    
    15    void call(Func func)​
    
    16    {​
    
    17        _call(IndexS(), func);​
    
    18    }​
    
    19    ​
    
    20    template<typename Func, int...Indexes>​
    
    21    void _call(std::index_sequence<Indexes...>, Func func)​
    
    22    {​
    
    23        func(std::get<Indexes>(m_args)...);​
    
    24    }​
    
    25    ​
    
    26private:​
    
    27​
    
    28    std::tuple<Args...>  m_args;​
    
    29    ​
    
    30}​

​

  

​

C++

    
    
    1template<class T> using InvokeGenSeq = typename T::Type;​
    
    2​
    
    3template<int...> struct IndexesList { using Type = IndexesList; };​
    
    4​
    
    5template<int N, class S1, class S2> struct ConcatSeqImpl;​
    
    6​
    
    7template<int N, int... I1, int... I2>​
    
    8struct ConcatSeqImpl<N, IndexesList<I1...>, IndexesList<I2...>>​
    
    9    : IndexesList<I1..., (N + I2)...>{};​
    
    10​
    
    11template<int N, class S1, class S2>​
    
    12using ConcatSeq = InvokeGenSeq<ConcatSeqImpl<N, S1, S2>>;​
    
    13​
    
    14template<int N> struct GenSeq;​
    
    15template<int N> using makeIndexSequence = InvokeGenSeq<GenSeq<N>>;​
    
    16​
    
    17template<int N>​
    
    18struct GenSeq : ConcatSeq<N/2, makeIndexSequence<N/2>,​
    
    19    makeIndexSequence<N - N/2>>{};​
    
    20​
    
    21template<> struct GenSeq<0> : IndexesList<>{};​
    
    22template<> struct GenSeq<1> : IndexesList<0>{};​
    
    23​
    
    24template<int N>​
    
    25struct Indexes { using Value = makeIndexSequence<N>; };​
    
    26​
    
    27//理解难度非常大，自行代入拆解，还是很好理解的。​

​

  

​

C++

    
    
    1template<typename...Tys>​
    
    2class MyTuple;​
    
    3​
    
    4template<>​
    
    5class MyTuple<> {};​
    
    6​
    
    7//递归性继承​
    
    8template<typename First, typename...Rest>​
    
    9class MyTuple<First, Rest...> : public MyTuple<Rest...>​
    
    10{​
    
    11public:​
    
    12​
    
    13    using _Base = MyTuple<Rest...>;​
    
    14​
    
    15    template<size_t index, typename...Args>​
    
    16    struct select_type_index;​
    
    17​
    
    18    template<typename First, typename...Rest>​
    
    19    struct select_type_index<0, First, Rest...>​
    
    20    {​
    
    21        using type = First;​
    
    22        using tupleType = MyTuple<First, Rest...>;​
    
    23    };​
    
    24​
    
    25    template<size_t index, typename First, typename...Rest>​
    
    26    struct select_type_index<index, First, Rest...>​
    
    27    {​
    
    28        using type = typename select_type_index<index - 1, Rest...>::type;​
    
    29        using tupleType = typename select_type_index<index - 1, ​
    
    30            Rest...>::tupleType;​
    
    31    };​
    
    32​
    
    33    template<typename Type, typename...Args>​
    
    34    struct select_type_type;​
    
    35​
    
    36    template<typename First, typename...Rest>​
    
    37    struct select_type_type<First, First, Rest...>​
    
    38    {​
    
    39        using type = First;​
    
    40        using tupleType = MyTuple<First, Rest...>;​
    
    41    };​
    
    42​
    
    43    template<typename Type, typename First, typename...Rest>​
    
    44    struct select_type_type<Type, First, Rest...>​
    
    45    {​
    
    46        using type = typename select_type_type<Type, Rest...>::type;​
    
    47        using tupleType = typename select_type_type<Type, Rest...>::tupleType;​
    
    48    };​
    
    49​
    
    50public:​
    
    51​
    
    52    template<typename Type>​
    
    53    typename select_type_type<Type, First, Rest...>::type get() const​
    
    54    {​
    
    55        return static_cast<const typename select_type_type<Type, First,​
    
    56             Rest...>::tupleType*>(this)->_value;​
    
    57    }​
    
    58​
    
    59    template<size_t index>​
    
    60    typename select_type_index<index, First, Rest...>::type get() const​
    
    61    {​
    
    62        return static_cast<const typename select_type_index<index, First, ​
    
    63            Rest...>::tupleType*>(this)->_value;​
    
    64    }​
    
    65​
    
    66public:​
    
    67​
    
    68    MyTuple(First first, Rest...rest)​
    
    69        :_Base(rest...), _value(first)​
    
    70    {​
    
    71​
    
    72    }​
    
    73​
    
    74public:​
    
    75    ​
    
    76    //递归多个_value的定义​
    
    77    First        _value;​
    
    78    ​
    
    79};​
    
    80​
    
    81//这是简化版本，除了构造和获取，其它的都没有实现，简单的调用如下:​
    
    82MyTuple<int, double, char> tu = {1, 3.1, 'a'}​
    
    83tu.get<1>();          //3.1​
    
    84tu.get<char>();       //'a'​
    
    85​
    
    86//虽然简单，但囊括了std::tuple大部分的核心思想。​

​

  

​

C++

    
    
    1template<typename T>​
    
    2void func(const T&)                 // ----(1)​
    
    3{​
    
    4    std::cout << "const T&" << std::endl;​
    
    5}​
    
    6​
    
    7template<typename T>​
    
    8void func(const std::vector<T>&)    // ----(2)​
    
    9{​
    
    10    std::cout << "vector<T>" << std::endl;​
    
    11}​
    
    12​
    
    13template<>​
    
    14void func<int>(const int&)         // ----(3)​
    
    15{​
    
    16    std::cout << "int<>" << std::endl;​
    
    17}​
    
    18​
    
    19void func(const int)                // ----(4)​
    
    20{​
    
    21    std::cout << "int" << std::endl;​
    
    22}​
    
    23​
    
    24template<typename T>​
    
    25void func(T t)                      // ----(5)​
    
    26{​
    
    27    std::cout << "T" << std::endl;​
    
    28}​
    
    29​

​

  

​

C++

    
    
    1template<typename T>        //----(1)​
    
    2struct TempA : std::integral_constant<int, 1> {};​
    
    3​
    
    4template<typename C, typename T>    //----(2)​
    
    5struct TempA<std::pair<C, T>> : std::integral_constant<int, 2> {};​
    
    6​
    
    7template<typename T>        //----(3)​
    
    8struct TempA<std::pair<T, T>> : std::integral_constant<int, 3> {};​
    
    9​
    
    10template<typename T>        //----(4)​
    
    11struct TempA<std::pair<T, int>> : std::integral_constant<int, 4> {};​

​

  

​

C++

    
    
    1TempA<int>::value;                          // 1)​
    
    2TempA<std::pair<int, double>>::value;       // 2)​
    
    3TempA<std::pair<double, double>>::value;    // 3)​
    
    4TempA<std::pair<double, int>>::value;       // 4)​
    
    5TempA<std::pair<int, int>>::value;          //Error, 3 和 4 无法抉择​

​

  

​

C++

    
    
    1template<typename T>​
    
    2struct IsDouble​
    
    3{​
    
    4    static constexpr bool value = false;​
    
    5};​
    
    6​
    
    7template<>​
    
    8struct IsDouble<double>​
    
    9{​
    
    10    static constexpr bool value = true;​
    
    11};​
    
    12​
    
    13//又或者​
    
    14template<typename T>​
    
    15struct remove_reference​
    
    16{​
    
    17    using type = T;​
    
    18};​
    
    19​
    
    20template<typename T>​
    
    21struct remove_reference<T&>​
    
    22{​
    
    23    using type = T;​
    
    24};​
    
    25​
    
    26template<typename T>​
    
    27struct remove_reference<T&&>​
    
    28{​
    
    29    using type = T;​
    
    30};​

​

  

​

C++

    
    
    1template<class _Ty, _Ty _Val>​
    
    2struct integral_constant​
    
    3{​
    
    4    static constexpr _Ty value = _Val;​
    
    5    ​
    
    6    //下面这些代码都是多余，核心就上面这一行代码​
    
    7    using value_type = _Ty;​
    
    8    using type = integral_constant;​
    
    9​
    
    10    constexpr operator value_type() const noexcept{​
    
    11        return value;​
    
    12    }​
    
    13    _NODISCARD constexpr value_type operator()()const noexcept{​
    
    14        return value;​
    
    15    }​
    
    16}​

​

  

​

C++

    
    
    1integral_constant<size_t, 0>;​
    
    2integral_constant<int, 2>;​
    
    3​
    
    4integral_constant<bool, true>;​
    
    5integral_constant<bool, false>;​
    
    6​
    
    7上面都是类型，不要把他们理解为变量，bool 是最常用的, 标准库给出如下定义：​
    
    8using true_type = integral_constant<bool, true>;​
    
    9using false_type = integral_constant<bool, false>;​
    
    10​
    
    11那么上面提到的IsDouble的实现可以改为:​
    
    12template<typename _Ty>​
    
    13struct IsDouble : false_type;​
    
    14template<>​
    
    15struct IsDouble<double> : true_type;​
    
    16​
    
    17标准库还有一个is_same的定义：​
    
    18template<class, class>​
    
    19struct is_same : false_type;​
    
    20​
    
    21template<class _Ty>​
    
    22struct is_same<_Ty, _Ty> : true_type;​
    
    23​
    
    24基于is_same实现IsDouble如下:​
    
    25template<typename _Ty>​
    
    26using IsDouble = is_same<_Ty, double>;​

​

  

​

C++

    
    
    1is_same<double, int>::value;     // false​
    
    2is_same<int, int>::value;        // true​
    
    3IsDouble<int>::value;            // false​
    
    4//核心仍然里面的编译器常量值，C++11多出一个模板常量的概念，其实就是为了方便取值。​
    
    5//因此定义如下：​
    
    6​
    
    7template <typename _Ty1, typename _Ty2>​
    
    8const bool is_same_v<_Ty1, _Ty2> = is_same<_Ty1, _Ty2>::value;​
    
    9​
    
    10//当然我们还可以反过来，先定义模板常量，再定义模板类: ​
    
    11template <typename, typename>​
    
    12constexpr bool is_same_v = false;​
    
    13​
    
    14template <typename _Ty>​
    
    15constexpr bool is_same_v<_Ty, _Ty> = true;​
    
    16​
    
    17//然后再定义 is_same​
    
    18template<typename _Ty1, typename _Ty2>​
    
    19struct is_same : integral_constant<bool, is_same_v<_Ty1, _Ty2>>;​

​

  

​

C++

    
    
    1template<bool _Test, class _Ty = void>​
    
    2struct enable_if{};​
    
    3​
    
    4template<class _Ty>​
    
    5struct enable_if<true, _Ty>{​
    
    6    using type = Ty;​
    
    7};​
    
    8//这是定义类型，和定义编译器常量走的两条路线，这里可以看出​
    
    9//特化版本定义type类型， 那么：​
    
    10enable_if<false, void>::type; //error, 没有定义type​
    
    11enable_if<true, void>::type;  //<==> void ​
    
    12//虽然用了第一个，会报错，但是用在模板函数重载时，未必会报错​
    
    13//因为模板函数重载，检验不正确，会尝试用其它的，例如:​
    
    14​
    
    15template<typename Ty>​
    
    16enalbe_if<IsDouble<Ty>::value, void>::type func()​
    
    17{​
    
    18};​
    
    19​
    
    20func<double>(); //正确​
    
    21func<int>(); //错误​
    
    22​
    
    23//但是如果再定义下面的函数​
    
    24template<typename Ty>​
    
    25std::enable_if<is_same<Ty, int>::value, void>::type func()​
    
    26{​
    
    27}​
    
    28func<int>(); //正确，它再尝试第一个失败时，会尝试别的。​
    
    29​
    
    30//也可在模板参数中验证​
    
    31template<typename Ty, typename = std::enable_if_t<is_same_v<Ty,int>>>​
    
    32void func()​
    
    33{​
    
    34}​
    
    35​
    
    36//又或者写成, 标准库基本是下面这种写法​
    
    37template<typename Ty, std::enable_if_t<is_same_v<Ty, int>, int> = 0>​
    
    38void func()​
    
    39{​
    
    40}​

​

  

​

C++

    
    
    1template<bool _Test, class _Ty1, class _Ty2>​
    
    2struct conditional{​
    
    3    using type = _Ty1;​
    
    4}​
    
    5​
    
    6template<class _Ty1, class _Ty2>​
    
    7struct conditional<false, _Ty1, _Ty2>{​
    
    8    using type = _Ty2;​
    
    9}​
    
    10//这个是条件分支​
    
    11std::conditional<true, int, double>::type;     // int​
    
    12std::conditional<false, int, double>::type;    // double​
    
    13​
    
    14//这么一说，可能看出它的作用，参考以下代码:​
    
    15template<int Index, typename T>​
    
    16inline void KDataPack::_packOne(const T& arg)​
    
    17{​
    
    18    using DT = std::decay<T>::type; // 这个行代码的主要目的是将 char [] ==> char*​
    
    19    std::conditional_t<std::is_enum<DT>::value, _Enum<Index, DT>,​
    
    20      std::conditional_t<_CanConstruct<DT>::value, _Constuct<Index, DT>,​
    
    21      std::conditional_t<std::is_pointer<DT>::value, _GuidAdpater<Index, DT>,​
    
    22      std::conditional_t<has_member_kpack<DT, KDataPack>::value, _Convert_Inner<Index, DT>,​
    
    23      std::conditional_t<has_overload_globalPack<DT,KDataPack>::value, _Convert<Index, DT>,​
    
    24      std::conditional_t<has_overload_stream<DT>::value, _Convert_Stream<Index, DT>,​
    
    25      _Error_Convert<Index, DT>>>>>>>::_pack((DT)arg, *this);​
    
    26}​
    
    27​
    
    28//如果是枚举类型，使用_Enum<Index, DT>::_pack进行参数打包​
    
    29//如果是可以用QVariant构造的类型，则用_Construct<Index, DT>::_pack进行参数打包​
    
    30//如果是指针类型，则用_GuidAdapter<Index,DT>::_pack进行参数打包​
    
    31//如果DT有成员函数kpack， 则用_Convert_Inner<Index, DT>::_pack进行参数打包​
    
    32//如果由重载DT全局函数globalPack, 则用_Convert<Index,DT>::_pack进行参数打包​
    
    33//如果Dt有重载流运算QDataStream.operator<<, 则用_Convert_Stream<Index, DT>::_Pack打包​
    
    34//否则用兜底的_Error_Convert<index, DT>::_pack, 内部会直接报错。​

​

  

​

C++

    
    
    1template<typename T>​
    
    2std::wostream& operator<<(std::wostream& stream, const T& t)​
    
    3{​
    
    4    QString buffer;​
    
    5    {​
    
    6        QDebug debug(&buffer);​
    
    7        debug << t;​
    
    8    }​
    
    9    return stream << (LPCWSTR)buffer.utf16();​
    
    10}​

​

  

​

C++

    
    
    1template<typename T>​
    
    2struct CheckDebug​
    
    3{​
    
    4    template<typename U> static auto Check(int)​
    
    5             ->decltype(std::declval<QDebug>() << std::declval<U>(), ​
    
    6                 std::true_type());​
    
    7    template<typename U> static std::false_type Check(...);​
    
    8    static constexpr auto value = decltype(Check<T>(0))::value;​
    
    9}​

​

  

​

C++

    
    
    1Template <typename T>​
    
    2T declval();​
    
    3//它就是这么简单，没有实现，也没法实现，因为同样在这也不知道怎么构造一个T的对象。​
    
    4//因为上述代码是在编译器完成，压根就没打算真正的调用declval函数，不会出现链接错误。​

​

  

​

C++

    
    
    1template<typename ... T>​
    
    2using void_t = void;​
    
    3​
    
    4//乍一看完全不明白void_t是个嘛玩意​
    
    5//他同样是用于检测语法的一个工具模板。 ​
    
    6​
    
    7//例如:​
    
    8template<typename Iterator, typename = void_t<>>​
    
    9struct AssociativeIteratorHasKeyAndValue : std::false_type;​
    
    10​
    
    11template<typename Iterator>​
    
    12struct AssociativeIteratorHasKeyAndValue<Iterator,​
    
    13    void_t<decltype(std::declval<Iterator&>().key()),​
    
    14           decltype(std::declval<Iterator&>().value())>> : std::true_type;​
    
    15​
    
    16//std::declval的作用，这里是借助特化的优先匹配，如果特化版本语法检测不成立​
    
    17//则使用非特化版本​
    
    18​
    
    19//void_t的参数之所以模板参数包，就是便于检测多个语法是否成立，void_t的使用更加简便。​
    
    20​
    
    21//在参考另一个用例​
    
    22template<class _Iter, class _UIter, class = void>​
    
    23constexpr bool _Wrapped_seekable_v = false;​
    
    24​
    
    25template<class _Iter, class _UIter>​
    
    26constexpr bool _Wrapped_seekable_v<_Iter, _UIter, ​
    
    27    void_t<decltype(std::declval<_Iter&>().​
    
    28    _Seek_to(std::declval<_UIter>()))>> = true;​
    
    29    ​
    
    30//这玩意超级简单，见识检查 _Iter 和 _UIter 进行如下调用是否成立​
    
    31// _Iter._Seek_to(_UIter)， 简单说就是_Iter有一个成员函数_Seek_to, 且参数是​
    
    32// UIter类型​
    
    33​

​

  

​

C++

    
    
    1template<typename T, typename = void>​
    
    2constexpr bool CanConstructQVariant = false;​
    
    3​
    
    4template<typename T>​
    
    5constexpr bool CanConstructQVariant<T, ​
    
    6    void_t<decltype(QVariant(std::declval<T&>()))>> = true;​
    
    7    ​
    
    8//这种写法，看似没毛病，实际上有很大的问题，就是QVariant会形成隐式构造，​
    
    9//例如： QVariant(int)这个构造函数，会导致​
    
    10// std::shared_ptr<任意类型> 被该构造函数强行构造。所以为了避免隐式构造，可以换一种​
    
    11// 方式，可以借助 operator=, 如下​
    
    12​
    
    13template<typename T>​
    
    14constexpr bool CanConstructQVariant<T,​
    
    15    void_t<decltype(std::declval<QVariant&>().​
    
    16        operator=(std::declval<T&>()))>> = true;​
    
    17​

​

  

​

C++

    
    
    1struct A{​
    
    2    void funcA(){}​
    
    3}​
    
    4​
    
    5struct B{​
    
    6    void funcB(){}​
    
    7}​
    
    8​
    
    9template<typename T>​
    
    10void myFunc(T t)​
    
    11{​
    
    12    if(is_same<A, T>::value)​
    
    13    {​
    
    14        t.funcA();​
    
    15    }else if (is_same<B, T>::value)​
    
    16    {​
    
    17        t.funcB();​
    
    18    }​
    
    19}​
    
    20​
    
    21//这个的错误原因很简单。当进行如下调用时:​
    
    22​
    
    23myFunc(A());​
    
    24//展开myFunc​
    
    25template<typename T = A>​
    
    26void myFunc(A a)​
    
    27{​
    
    28    if (true)​
    
    29    {​
    
    30        a.funcA();​
    
    31    }else if (false)​
    
    32    {​
    
    33        a.funcB();    //这里报错了，a没有funcB函数。​
    
    34    }​
    
    35}​
    
    36​
    
    37//那么如何解决这个问题呢？最简单的方法+constexpr​
    
    38template<typename T>​
    
    39void myFunc(T t)​
    
    40{​
    
    41    if constexpr (std::is_same_v<T, A>)​
    
    42    {​
    
    43        t.funcA();​
    
    44    }else if constexpr(std::is_same_v<T, B>)​
    
    45    {​
    
    46        t.funcB();​
    
    47    }  ​
    
    48}​
    
    49//这样子。​
    
    50myFunc(A());​
    
    51myFunc(B()); //都不会报错​
    
    52//我猜测，myFunc(A())时，myFunc压根没有生成else if 括号中的代码。​
    
    53​

​

错误示例2：​

​

C++

    
    
    1template<typename ...Args>​
    
    2class Argments​
    
    3{​
    
    4    void callFunc(const std::function<void(Args...)>& func)​
    
    5    {​
    
    6    ​
    
    7    };​
    
    8}；​
    
    9​
    
    10Argments.call([](int, double)  ​
    
    11{​
    
    12});​
    
    13​
    
    14//这个错误是无法推导，传入的参数并不是function<int, double>，没法完成推导​
    
    15//除非强制写成​
    
    16Argments.call([]((std::function<void(int,double)>)[](int, double)​
    
    17{​
    
    18​
    
    19});​

​

​

反向引用 (0)

反向引用 (0)

本文引用 (0)

本文引用 (0)

关系图

本文暂未被其它文档引用

本文暂未引用其它文档

你和其他

2

2

2

人已赞

​

​

文本

链接 确定

####

_ _

如何获取链接

查看示例 确认

显示为

插入标题

标题

卡片

内嵌网页

数据表

链接

卡片

代码

预览失败，请在 Airtable 中获取分享链接。 [ 查看示例 ](/space/help/airtable-block)

预览失败，请使用高德地图网页链接。

插入表格

已废弃

历史记录  本地记录

评论（0）

跳转至首条评论

0 字

  * 上传日志

  * 联系客服

  * 功能更新

  * 帮助中心

  * 效率指南

rangeDom

全局快捷键

  *   * 搜索`Ctrl` \+ `Shift` \+ `F`
  * 新建文档`Ctrl` \+ `Alt` \+ `N`
  * 新建表格`Ctrl` \+ `Shift` \+ `Alt` \+ `N`
  * 撤销`Ctrl` \+ `Z`
  * 重做`Ctrl` \+ `Y`
  * 查看快捷键`Ctrl` \+ `/`
  * 

Markdown

Markdown 是一种快速输入带格式文本的方式，让你书写文档时行云流水，一气呵成，例如输入#空格，即可输入一级标题。

  *   * 一级标题`#` `空格`
  * 二级标题`##` `空格`
  * 三级标题`###` `空格`
  * 四级标题`####` `空格`
  * 五级标题`#####` `空格`
  * 六级标题`######` `空格`
  * 七级标题`#######` `空格`
  * 八级标题`########` `空格`
  * 九级标题`#########` `空格`
  *   * 有序列表`1.` `空格`
  * 无序列表`-` `空格` 或 `*` `空格`
  * 任务列表`[]` `空格`
  * 增加缩进`Tab`
  * 减少缩进`Shift` \+ `Tab`
  * 引用`>` `空格`
  * 代码``代码``
  * 代码块```` 空格 或 ``` 代码语言 空格`
  *   * 加粗`**文字**` `空格`
  * 斜体`*文字*` `空格`
  * 下划线`~文字~` `空格`
  * 删除线`~~文字~~` `空格`
  * 公式`$$文字$$`
  * 分隔线`---` 或 `***`
  * 

H

H


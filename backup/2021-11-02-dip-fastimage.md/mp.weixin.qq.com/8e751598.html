---
title : 自动快照存档
---

* TIME: 2021-11-02 15:09:52
* URL: <https://mp.weixin.qq.com/s/5CNRCL2XGFZOZBNJTGgI-w>

-----

#  最简单的背景颜色检测方法

原创 磐怼怼 [ 深度学习与计算机视觉 ](javascript:void\(0\);)

**深度学习与计算机视觉** ![]()

微信号 uncle_pn

功能介绍
深度学习与计算机视觉碰撞出了新的火花，本公众号将坚持分享原创计算机视觉技术相关文章。主要分为实战教程、视觉领域最新咨询、国内外最新论文翻译三类。欢迎志同道合的朋友关注。

____

_6月26日_

收录于话题

有没有想过 Instagram 如何在你添加图像时自动选择背景？！

他们通过不同的算法分析你的图片并生成与图像匹配的背景。他们主要使用图像中存在的“颜色”来处理输出。

在本文中，你可以找到 2
种技术来检测输入图像的合适背景。在最终用户产品中使用这些算法时，这些方法有点幼稚，但对于学习新东西的开发人员来说，这些方法非常方便且易于复制。

### 让我们了解第一种方法

在这种情况下，我们只需将RGB矩阵分离为单独的颜色通道，然后使用Counter() 函数分别对3个RGB矩阵中的每个像素值进行频率计数。

然后，选择10个出现频率最高的值并取它们的平均值来获得结果像素值。

最后，只需使用np.zeros() 生成一个空白图像，并用获得的背景色填充它即可显示最终结果。这种技术只需40行代码就可以产生结果！

以下是第一种方法的完整代码:

    
    
    import cv2  
    import numpy as np  
    from collections import Counter  
    file_path='YOUR_FILE_PATH'  
    def find_background(path=None):  
     if(path is not None):  
      img=cv2.imread(path)  
      img=cv2.resize(img,(800,600))  
      blue,green,red=cv2.split(img)  
      blue=blue.flatten()  
      green=green.flatten()  
      red=red.flatten()  
      blue_counter=Counter(blue)  
      green_counter=Counter(green)  
      red_counter=Counter(red)  
     blue_most=blue_counter.most_common(10)  
     blue_avg=[i for i,j in blue_most]  
     blue_avg=int(np.mean(blue_avg)  
       
     green_most=green_counter.most_common(10)  
     green_avg=[i for i,j in green_most]  
     green_avg=int(np.mean(green_avg))  
     red_most=red_counter.most_common(10)  
     red_avg=[i for i,j in red_most]  
     red_avg=int(np.mean(red_avg))  
     background=[blue_avg,green_avg,red_avg]  
       
     bg=np.zeros((512,512,3),np.uint8)  
     bg_color=cv2.rectangle(bg,(0,0),(512,512),background,-1)  
     return(bg_color)  
     else:  
       return(None)  
    bg_image=find_background(file_path)  
    cv2.imshow('Image',img)  
    cv2.imshow('Background',bg_image)  
    cv2.waitKey(0)  
    cv2.destroyAllWindows()  
    

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/ABvEnMciauWsIp7V18jDRpSfPF9dbMR0cYC40Ws7ESMZnrYWbPY34H9Ap6xy3Vicct6picf3QWUHyXBQowjuNMCiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

我们得到的原始图像和由此产生的背景颜色

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/ABvEnMciauWsIp7V18jDRpSfPF9dbMR0coqDQqdOkeqyXu50B5oH42NHLYVqWTfrGsSYJBnVqekqGibhXO93IzPg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

获得的原始图像和由此产生的背景颜色

### 什么是更复杂的方法来做到这一点？“ML”在哪里？！

实现相同目标的另一种方法是使用机器学习算法为我们提供我们想要计算最频繁的颜色分离。

第二种方法对 RGB 值使用 K-Means
聚类算法，并找出图像中存在的一组不同颜色的聚类。之后，再次利用频率计数，最后找到背景色。这种方法涉及到无监督机器学习的使用，其应用范围远远超出了背景颜色检测。

图像分割任务大量使用这种方法对图像进行K均值聚类。

以下是K-Means方法的完整代码：

    
    
    import cv2  
    import numpy as np  
    from collections import Counter  
    from sklearn.cluster import KMeans  
    import matplotlib.pyplot as plt  
    img=cv2.imread('YOUR_FILE_NAME')  
    img=cv2.resize(img,(500,500))  
    plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))  
    #Reshaping into a R,G,B -(2x3) 2D-Matrix  
    modified_img=img.reshape(img.shape[0]*img.shape[1],3)  
    #print(modified_img)  
    #plotting all the points in 3D space.  
    x=modified_img[:,0]  
    y=modified_img[:,1]  
    z=modified_img[:,2]  
    fig = plt.figure(figsize=(5,5))  
    ax = plt.axes(projection ='3d')  
    ax.scatter(x, y, z)  
    plt.show()  
    # Performing unpsupervised learning using K-Means  
    kmean=KMeans(n_clusters=10)  
    labels=kmean.fit_predict(modified_img)  
    #print(kmean.labels_)  
    #Points as shown according to the labels of KMeans  
    x=modified_img[:,0]  
    y=modified_img[:,1]  
    z=modified_img[:,2]  
    fig = plt.figure(figsize=(7, 7))  
    ax = plt.axes(projection ='3d')  
    ax.scatter(x, y, z, c=kmean.labels_, cmap='rainbow')  
    ax.scatter(kmean.cluster_centers_[:,0] ,kmean.cluster_centers_[:,1],kmean.cluster_centers_[:,2], color='black')  
    plt.show()  
    #Making frequency of each label set i.e count of no. of data-points in each label  
    count=Counter(labels)  
    center_color=kmean.cluster_centers_  
    ordered_color=[center_color[i] for i in count.keys()]  
    def rgb2hex(color):  
        return "#{:02x}{:02x}{:02x}".format(int(color[0]),          
    int(color[1]), int(color[2]))  
    hex_color=[rgb2hex(ordered_color[i]) for i in count.keys()]  
    plt.figure(figsize = (8, 6))  
    plt.pie(count.values(),labels=hex_color,colors=hex_color,shadow=True)  
    def get_key(val):  
      for key,value in count.items():  
        if val==value:  
          return key  
       
      return "key doesn't exist"  
    # Getting the max. color as our background  
    label_background=get_key(max(count.values()))  
    background_color=ordered_color[label_background]  
    hex_color_background=rgb2hex(background_color)  
    #showing our background in the form of an image.  
    bg=np.zeros((512,512,3),np.uint8)  
    bg_color=cv2.rectangle(bg,(0,0),(512,512),background_color,-1)  
    plt.imshow(bg_color)  
    

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/ABvEnMciauWsIp7V18jDRpSfPF9dbMR0cFqjpHqq9TDVHkmia2GcHYD6JLG83PR91lDYHTYiaxDAMZGY7ia3416fzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

所有不同颜色的 3D 绘图

  

![图片](https://mmbiz.qpic.cn/mmbiz_png/ABvEnMciauWsIp7V18jDRpSfPF9dbMR0cAUbqZZibnU2jpt8owv521s6SBfgcEsFTumEBgKjVeug0eBpvoxpSSSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

  

最常见颜色的饼图

### 结论

通过本文，向你展示了两种技术，你可以在其中使用非常简单的算法获取图像的背景。

  

  
 **☆ END ☆** 如果看到这里，说明你喜欢这篇文章，请转发、点赞。微信搜索「uncle_pn」，欢迎添加小编微信「
mthler」，每日朋友圈更新一篇高质量博文。 ** **↓** 扫描二维码添加小编↓**

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ABvEnMciauWv3xwzzNsxeUzg6sicEibmkUibzwYauw6icBk1AsMYU9plvXxJb80tUmKtTnI4z49YAMZ6wc83ibR9jN0A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![]()

磐怼怼

星标｜在看｜转发 不迷路

![赞赏二维码]() **微信扫一扫赞赏作者** __赞赏

已喜欢，[对作者说句悄悄话](javascript:;)

取消 __

#### 发送给作者

发送

最多40字，当前共字

[](javascript:;) 人赞赏

上一页 [1](javascript:;)/3 下一页

长按二维码向我转账

星标｜在看｜转发 不迷路

受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。

预览时标签不可点

收录于话题 #

个

上一篇 下一篇

阅读

分享 收藏

赞 在看

____已同步到看一看[写下你的想法](javascript:;)

前往“发现”-“看一看”浏览“朋友在看”

![示意图](//res.wx.qq.com/mmbizwap/zh_CN/htmledition/images/pic/appmsg/pic_like_comment55871f.png)

前往看一看

**看一看入口已关闭**

在“设置”-“通用”-“发现页管理”打开“看一看”入口

[我知道了](javascript:;)

__

已发送

取消 __

####  发送到看一看

发送

最简单的背景颜色检测方法

最多200字，当前共字

__

发送中

喜欢此内容的人还喜欢

人脑认知计算模型简介（上）

人脑认知计算模型简介（上）

深度学习与计算机视觉

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

新时代的关键抉择

新时代的关键抉择

共产党员

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

从美国公司视角看中国制造的竞争力

从美国公司视角看中国制造的竞争力

宁南山

不喜欢

不看的原因

确定

  * 内容质量低
  * 不看此公众号

写下你的留言

![](/mp/qrcode?scene=10000004&size=102&__biz=MzU2NTUwNjQ1Mw==&mid=2247503637&idx=1&sn=3cf7d7adacfc59fe0f685158ecd9b628&send_time=)

微信扫一扫  
关注该公众号

[知道了](javascript:;)

微信扫一扫  
使用小程序

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

****

[取消](javascript:void\(0\);) [允许](javascript:void\(0\);)

： ， 。 视频 小程序 赞 ，轻点两下取消赞 在看 ，轻点两下取消在看

__


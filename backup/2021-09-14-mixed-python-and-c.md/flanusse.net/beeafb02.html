<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml"><head>
    <title>Interfacing C++ and Python with Boost.Python - François Lanusse</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />



<link rel="canonical" href="https://flanusse.net/interfacing-c++-with-python.html" />

        <meta name="author" content="François Lanusse" />
        <meta name="keywords" content="tutorial,python,c++" />
        <meta name="description" content="This blog post demonstrates how to simply interface C++ code and Python using the powerful Boost.Python API." />

        <meta property="og:site_name" content="François Lanusse" />
        <meta property="og:type" content="article" />
        <meta property="og:title" content="Interfacing C++ and Python with Boost.Python" />
        <meta property="og:url" content="https://flanusse.net/interfacing-c++-with-python.html" />
        <meta property="og:description" content="This blog post demonstrates how to simply interface C++ code and Python using the powerful Boost.Python API." />
        <meta property="article:published_time" content="2017-04-01" />
            <meta property="article:section" content="coding" />
            <meta property="article:tag" content="tutorial" />
            <meta property="article:tag" content="python" />
            <meta property="article:tag" content="c++" />
            <meta property="article:author" content="François Lanusse" />



    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://flanusse.net/theme/css/bootstrap.cosmo.min.css" type="text/css" />
    <link href="https://flanusse.net/theme/css/font-awesome.min.css" rel="stylesheet" />

    <link href="https://flanusse.net/theme/css/pygments/monokai.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://flanusse.net/theme/css/style.css" type="text/css" />
        <link href="https://flanusse.net/custom.css" rel="stylesheet" />





</head>
<body style="padding-top: 50px;">

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://flanusse.net/" class="navbar-brand">
François Lanusse            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                         <li><a href="https://flanusse.net/pages/about-me.html">
                             About Me
                          </a></li>
                         <li><a href="https://flanusse.net/pages/blog.html">
                             Blog
                          </a></li>
                         <li><a href="https://flanusse.net/pages/publications.html">
                             Publications
                          </a></li>
                         <li><a href="https://flanusse.net/pages/software.html">
                             Software
                          </a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<!-- Banner -->
<!-- End Banner -->

<!-- Content Container -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://flanusse.net/interfacing-c++-with-python.html" rel="bookmark" title="Permalink to Interfacing C++ and Python with Boost.Python">
                        Interfacing C++ and Python with Boost.Python
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2017-04-01T22:23:00-07:00"> Sat 01 April 2017</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="https://flanusse.net/tag/tutorial.html">tutorial</a>
        /
	<a href="https://flanusse.net/tag/python.html">python</a>
        /
	<a href="https://flanusse.net/tag/c.html">c++</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>A large number of methods exist to interface Python and C/C++, the
choice of a particular method mostly depend on the size and
complexity of the codes you are trying to interface. From simple to
more complex, I would first recommend
<a class="reference external" href="https://docs.python.org/2/library/ctypes.html">ctypes</a> for quick
and dirty interfacing with a handful of C functions. For wrapping
a couple of C++ classes, the best approach is probably the popular
<a class="reference external" href="http://www.swig.org/">SWIG</a> for "Simple Wrapper Interface Generator".
Now, if you want to interface a whole C++ library, one of the most
powerful options is <a class="reference external" href="http://www.boost.org/doc/libs/1_63_0/libs/python/doc/html/index.html">Boost.Python</a> ,
which is the solution I'm introducing in this tutorial. You can
find a comparison of the relative benefits of SWIG vs Boost.Python on this
<a class="reference external" href="https://dev.lsstcorp.org/trac/wiki/SwigVsBoostPython">LSST wiki</a>. I should also
mention <a class="reference external" href="https://pybind11.readthedocs.io/en/master/">pybind11</a>, a more recent and
actively developed alternative to Boost.Python.</p>
<p>In this tutorial we will cover the following topics:</p>
<ul class="simple">
<li>Manually wrapping a simple C++ class using Boost.Python</li>
<li>Compilation of Boost.Python project with CMake</li>
<li>Automatic generation of Boost.Python wrapper using Py++</li>
</ul>
<p>The source for all the examples presented here can be found on
<a class="reference external" href="https://github.com/EiffL/Tutorials/tree/master/PythonC%2B%2B">GitHub</a></p>
<div class="section" id="interfacing-hello-world">
<h2>Interfacing Hello World</h2>
<p>This first part of the tutorial demonstrates how to write a simple
Boost.Python wrapper for a C++ class, and, maybe more importantly,
how to get everything to compile and link properly.</p>
<div class="section" id="simple-c-class">
<h3>Simple C++ class</h3>
<p>To get started, let's consider a very basic C++ class, that we will
store in <a class="reference external" href="https://github.com/EiffL/Tutorials/blob/master/PythonC%2B%2B/Bonjour.hpp">Bonjour.hpp</a> :</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="k">class</span> <span class="nc">Bonjour</span>
<span class="p">{</span>
    <span class="c1">// Private attribute</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_msg</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// Constructor</span>
    <span class="n">Bonjour</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">)</span><span class="o">:</span><span class="n">m_msg</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// Methods</span>
    <span class="kt">void</span> <span class="n">greet</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m_msg</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

    <span class="c1">// Getter/Setter functions for the attribute</span>
    <span class="kt">void</span> <span class="n">set_msg</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">m_msg</span> <span class="o">=</span> <span class="n">msg</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_msg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_msg</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="boost-python-interface">
<h3>Boost.Python interface</h3>
<p>Our goal will be to use Boost.Python to include this class in a
module, that we will call <tt class="docutils literal">pylib</tt>, which will be directly importable
from Python. To do so, Boost.Python provides a C++ API which allows us to declare
the classes and functions we wish to export to Python. These declarations
are made in a .cpp interface file, which we will call <a class="reference external" href="https://github.com/EiffL/Tutorials/blob/master/PythonC%2B%2B/pylib.cpp">pylib.cpp</a> :</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;boost/python.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">"Bonjour.hpp"</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">boost</span><span class="o">::</span><span class="n">python</span><span class="p">;</span>

<span class="n">BOOST_PYTHON_MODULE</span><span class="p">(</span><span class="n">pylib</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">class_</span><span class="o">&lt;</span> <span class="n">Bonjour</span> <span class="o">&gt;</span><span class="p">(</span><span class="s">"Bonjour"</span><span class="p">,</span> <span class="n">init</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">())</span>
      <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"greet"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Bonjour</span><span class="o">::</span><span class="n">greet</span><span class="p">)</span>
      <span class="p">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">"msg"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Bonjour</span><span class="o">::</span><span class="n">get_msg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Bonjour</span><span class="o">::</span><span class="n">set_msg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Let's decrypt what's happening here. The <tt class="docutils literal">BOOST_PYTHON_MODULE</tt> macro declares a
Python module that will be called pylib. We can then add classes or functions to
this module by adding the proper declarations between the parenthesis.</p>
<p>To add a class, we create a new <tt class="docutils literal">class_&lt;&gt;</tt> object. The template of this object
is the class that we want to export, in our case <tt class="docutils literal">class_&lt;Bonjour&gt;</tt> will wrap
our C++ class into Python. The first argument of the <tt class="docutils literal"><span class="pre">class_&lt;&gt;()</span></tt> constructor is the
name that we want to use for this class in Python, here, we use the same name as in
C++, "Bonjour", but it doesn't have to be. The second argument is used to define
which C++ constructor to use. Here we only have one C++ constructor, but a C++ class
can have many, which will differ by their prototypes. To identify which one to export,
we use the <tt class="docutils literal">init&lt;&gt;</tt> object which template corresponds to the prototype of the constructor,
here a single argument of type <tt class="docutils literal"><span class="pre">std::string</span></tt>.</p>
<p>Declaring a class this way will just create an empty Python class, we then need
to declare the methods and attributes that we wish to export from C++. To add
a method, we use the <tt class="docutils literal">def()</tt> function, which takes as a first argument the name
of the method in Python, and as a second argument, a reference to the actual C++
method. Finally, we add a property to our Python class using <tt class="docutils literal">add_property()</tt>,
so that we can query and edit the content of the greeting message. The first
argument of this function is the name of the property in Python, the next arguments
are references to getter and setter functions in our C++ implementation.</p>
<p>See this <a class="reference external" href="http://www.boost.org/doc/libs/1_63_0/libs/python/doc/html/tutorial/tutorial/exposing.html">page</a>
for more information on how to export classes.</p>
</div>
<div class="section" id="compilation-with-cmake">
<h3>Compilation with CMake</h3>
<p>Now that the interface file is written, we need to compile it. This compilation
process involves in particular linking to the Python and Boost.Python libraries,
which can be very painful (especially on MacOS X). To make the compilation as
painless as possible, I will be using CMake to automatically identify the default
C++ compiler, Python interpreter and download and build the required Boost modules.</p>
<p>We first need to install CMake, on an Ubuntu machine:</p>
<div class="highlight"><pre><span></span>$ sudo apt-get install cmake
</pre></div>
<p>or whatever package manager you have on your system. If running on a cluster,
you might have to install it locally from source, follow
<a class="reference external" href="https://cmake.org/install/">these instructions</a>.</p>
<p>Now, to compile our module we need to write a <a class="reference external" href="https://github.com/EiffL/Tutorials/blob/master/PythonC%2B%2B/CMakeLists.txt">CMakeLists.txt</a>
file, which specifies the libraries required for compilation and
defines the libraries and/or executables to build :</p>
<div class="highlight"><pre><span></span><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">2.8</span><span class="p">)</span>
<span class="nb">include</span><span class="p">(</span><span class="s">ExternalProject</span><span class="p">)</span>

<span class="c"># Adding customized cmake module for building boost</span>
<span class="nb">list</span><span class="p">(</span><span class="s">APPEND</span> <span class="s">CMAKE_MODULE_PATH</span>  <span class="s2">"${CMAKE_SOURCE_DIR}/cmake/Modules/"</span><span class="p">)</span>

<span class="nb">project</span><span class="p">(</span><span class="s">tutorial</span><span class="p">)</span>

  <span class="c"># Find default python libraries and interpreter</span>
  <span class="nb">find_package</span><span class="p">(</span><span class="s">PythonInterp</span> <span class="s">REQUIRED</span><span class="p">)</span>
  <span class="nb">find_package</span><span class="p">(</span><span class="s">PythonLibs</span> <span class="s">REQUIRED</span><span class="p">)</span>
  <span class="nb">include</span><span class="p">(</span><span class="s">BuildBoost</span><span class="p">)</span> <span class="c"># Custom module</span>

  <span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">Boost_INCLUDE_DIR</span><span class="o">}</span> <span class="o">${</span><span class="nv">PYTHON_INCLUDE_DIRS</span><span class="o">}</span><span class="p">)</span>
  <span class="nb">link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">Boost_LIBRARY_DIR</span><span class="o">}</span><span class="p">)</span>

  <span class="c"># Build and link the pylib module</span>
  <span class="nb">add_library</span><span class="p">(</span><span class="s">pylib</span> <span class="s">SHARED</span> <span class="s">pylib.cpp</span><span class="p">)</span>
  <span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">pylib</span> <span class="o">${</span><span class="nv">Boost_LIBRARIES</span><span class="o">}</span> <span class="o">${</span><span class="nv">PYTHON_LIBRARIES</span><span class="o">}</span><span class="p">)</span>
  <span class="nb">add_dependencies</span><span class="p">(</span><span class="s">mylib</span> <span class="s">Boost</span><span class="p">)</span>

  <span class="c"># Tweaks the name of the library to match what Python expects</span>
  <span class="nb">set_target_properties</span><span class="p">(</span><span class="s">pylib</span> <span class="s">PROPERTIES</span> <span class="s">SUFFIX</span> <span class="s">.so</span><span class="p">)</span>
  <span class="nb">set_target_properties</span><span class="p">(</span><span class="s">pylib</span> <span class="s">PROPERTIES</span> <span class="s">PREFIX</span> <span class="s2">""</span><span class="p">)</span>
</pre></div>
<p>For this file to work, you need to copy locally my <a class="reference external" href="https://github.com/EiffL/Tutorials/blob/master/PythonC%2B%2B/cmake/Modules/BuildBoost.cmake">custom CMake module</a>
for Boost, and put it in a <em>cmake/Modules</em> folder in the current directory. This
file instructs CMake to compile our interface <tt class="docutils literal">pylib.cpp</tt> into a library which
will be named <tt class="docutils literal">pylib.so</tt>. Note that you do not need to have Boost installed on
your system, it will be automatically downloaded and compiled by CMake to match
your specific setup.</p>
<p>Final step, compiling:</p>
<div class="highlight"><pre><span></span>$ mkdir build   <span class="c1"># Creates a folder for CMake to do its thing</span>
$ <span class="nb">cd</span> build
$ cmake ..      <span class="c1"># Runs CMake configuration and produces a MakeFile</span>
$ make pylib    <span class="c1"># Builds the library</span>
</pre></div>
<p>And that's it, this should generate a file called pylib.so, which is a Python
module directly loadable from the interpreter:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">pylib</span> <span class="kn">import</span> <span class="n">Bonjour</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Bonjour</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
<span class="n">Hello</span> <span class="n">World</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">"Bonjour tout le monde"</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
<span class="n">Bonjour</span> <span class="n">tout</span> <span class="n">le</span> <span class="n">monde</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">msg</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="s1">'Bonjour tout le monde'</span>
</pre></div>
<p>So, that's the basic idea of how to write and interface and compile it with CMake.
Check the Boost.Python <a class="reference external" href="http://www.boost.org/doc/libs/1_63_0/libs/python/doc/html/index.html">documentation</a> for more details.</p>
</div>
</div>
<div class="section" id="automated-interface-generation-with-py">
<h2>Automated interface generation with Py++</h2>
<p>Something that may already be apparent in the simple example considered above is
that to wrap an entire C++ library in Boost.Python, someone has to declare every
single method and property of every single C++ class, which can be a lot of work.
Luckily, that someone doesn't have to be a Human. Instead one can rely on
automated code generators, which will parse your C++ files and automatically
create the corresponding Boost.Python declarations.</p>
<p>The official interface generator for Boost.Python used to be
<a class="reference external" href="http://www.boost.org/doc/libs/1_60_0/libs/python/pyste/">Pyste</a>, unfortunately
it is no longer maintained and has been removed from current versions of Boost.
It has now been superseded by a different project called
<a class="reference external" href="http://pyplusplus.readthedocs.io/en/latest/">Py++</a>.</p>
<p>A word of warning here, installing and using Py++ in 2017 is a non trivial endeavor,
most of the documentation and resources you can find online are out of date.
The official documentation points to a stale branch of the project, from 2008.
Luckily, the development of Py++ is not completely dead, an up to date version
is being maintained as part of the Open Motion Planning Library <a class="reference external" href="http://ompl.kavrakilab.org/">OMPL</a> .</p>
<div class="section" id="installing-requirements">
<h3>Installing requirements</h3>
<p>Py++ relies on <a class="reference external" href="https://github.com/CastXML/CastXML">CastXML</a> (formerly GCC-XML)
a tool that parses C++ header files into an XML tree, and on
<a class="reference external" href="http://pygccxml.readthedocs.io/en/develop/">pygccxml</a> to process the output
XML files.</p>
<p>CastXML is available as a package at least in Ubuntu 16.04+ and MacPorts, to install:</p>
<div class="highlight"><pre><span></span>$ sudo apt-get install castxml
</pre></div>
<p>Pygccxml can be installed through PyPI using pip:</p>
<div class="highlight"><pre><span></span>$ pip install --user pygccxml
</pre></div>
<p>Finally, a working version of Py++ itself can be installed from the OMPL bitbucket
repository (as of April 2017):</p>
<div class="highlight"><pre><span></span>$ pip install --user https://bitbucket.org/ompl/pyplusplus/get/1.7.0.zip
</pre></div>
</div>
<div class="section" id="writing-a-py-script">
<h3>Writing a Py++ script</h3>
<p>Py++ is a Python library which you can use in a Python script to parse the source
files of your C++ project and produce the corresponding interface. Here is an
example of such a script, that will automatically create the interface for our
C++ class in a new module <tt class="docutils literal">pylib_auto</tt> (to differentiate with the previous one).
We will call this script <a class="reference external" href="https://github.com/EiffL/Tutorials/blob/master/PythonC%2B%2B/pylib_generator.py">pylib_generator.py</a> :</p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python</span>
<span class="kn">from</span> <span class="nn">pygccxml</span> <span class="kn">import</span> <span class="n">parser</span>
<span class="kn">from</span> <span class="nn">pyplusplus</span> <span class="kn">import</span> <span class="n">module_builder</span>

<span class="c1"># Configurations that you may have to change on your system</span>
<span class="n">generator_path</span> <span class="o">=</span> <span class="s2">"/usr/bin/castxml"</span>
<span class="n">generator_name</span> <span class="o">=</span> <span class="s2">"castxml"</span>
<span class="n">compiler</span> <span class="o">=</span> <span class="s2">"gnu"</span>
<span class="n">compiler_path</span> <span class="o">=</span> <span class="s2">"/usr/bin/gcc"</span>

<span class="c1"># Create configuration for CastXML</span>
<span class="n">xml_generator_config</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">xml_generator_configuration_t</span><span class="p">(</span>
                                    <span class="n">xml_generator_path</span><span class="o">=</span><span class="n">generator_path</span><span class="p">,</span>
                                    <span class="n">xml_generator</span><span class="o">=</span><span class="n">generator_name</span><span class="p">,</span>
                                    <span class="n">compiler</span><span class="o">=</span><span class="n">compiler</span><span class="p">,</span>
                                    <span class="n">compiler_path</span><span class="o">=</span><span class="n">compiler_path</span><span class="p">)</span>

<span class="c1"># List of all the C++ header of our library</span>
<span class="n">header_collection</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Bonjour.hpp"</span><span class="p">]</span>

<span class="c1"># Parses the source files and creates a module_builder object</span>
<span class="n">builder</span> <span class="o">=</span> <span class="n">module_builder</span><span class="o">.</span><span class="n">module_builder_t</span><span class="p">(</span>
                        <span class="n">header_collection</span><span class="p">,</span>
                        <span class="n">xml_generator_path</span><span class="o">=</span><span class="n">generator_path</span><span class="p">,</span>
                        <span class="n">xml_generator_config</span><span class="o">=</span><span class="n">xml_generator_config</span><span class="p">)</span>

<span class="c1"># Automatically detect properties and associated getters/setters</span>
<span class="n">builder</span><span class="o">.</span><span class="n">classes</span><span class="p">()</span><span class="o">.</span><span class="n">add_properties</span><span class="p">(</span><span class="n">exclude_accessors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Define a name for the module</span>
<span class="n">builder</span><span class="o">.</span><span class="n">build_code_creator</span><span class="p">(</span><span class="n">module_name</span><span class="o">=</span><span class="s2">"pylib_auto"</span><span class="p">)</span>

<span class="c1"># Writes the C++ interface file</span>
<span class="n">builder</span><span class="o">.</span><span class="n">write_module</span><span class="p">(</span><span class="s1">'pylib_auto.cpp'</span><span class="p">)</span>
</pre></div>
<p>This script should be mostly self-explanatory, the most important part is the
creation of the <tt class="docutils literal">module_builder</tt> which takes a list of C++ header files to
parse. See the <a class="reference external" href="http://pyplusplus.readthedocs.io/en/latest/">Py++ documentation</a>
for more indications on how to fine-tune the process (which can be necessary for
more complex projects).</p>
<p>We can now parse our source code by running this script:</p>
<div class="highlight"><pre><span></span>$ python pylib_generator.py
</pre></div>
<p>If everything works as expected, this script should create a new interface file
<a class="reference external" href="https://github.com/EiffL/Tutorials/blob/master/PythonC%2B%2B/pylib_auto.cpp">pylib_auto.cpp</a> . To compile this new module, let's just add a new
section at the end of our CMakeLists.txt:</p>
<div class="highlight"><pre><span></span><span class="c"># Build and link the pylib_auto module</span>
<span class="nb">add_library</span><span class="p">(</span><span class="s">pylib_auto</span> <span class="s">SHARED</span> <span class="s">pylib_auto.cpp</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">pylib_auto</span> <span class="o">${</span><span class="nv">Boost_LIBRARIES</span><span class="o">}</span> <span class="o">${</span><span class="nv">PYTHON_LIBRARIES</span><span class="o">}</span><span class="p">)</span>
<span class="nb">add_dependencies</span><span class="p">(</span><span class="s">pylib_auto</span> <span class="s">Boost</span><span class="p">)</span>

<span class="c"># Tweaks the name of the library to match what Python expects</span>
<span class="nb">set_target_properties</span><span class="p">(</span><span class="s">pylib_auto</span> <span class="s">PROPERTIES</span> <span class="s">SUFFIX</span> <span class="s">.so</span><span class="p">)</span>
<span class="nb">set_target_properties</span><span class="p">(</span><span class="s">pylib_auto</span> <span class="s">PROPERTIES</span> <span class="s">PREFIX</span> <span class="s2">""</span><span class="p">)</span>
</pre></div>
<p>Let's update the CMake configuration and compile:</p>
<div class="highlight"><pre><span></span>$ <span class="nb">cd</span> build
$ cmake ..
$ make pylib_auto
</pre></div>
<p>We can now test our newly created module:</p>
<div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">from</span> <span class="nn">pylib_auto</span> <span class="kn">import</span> <span class="n">Bonjour</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Bonjour</span><span class="p">(</span><span class="s2">"Hello World"</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
<span class="n">Hello</span> <span class="n">World</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="s2">"Bonjour tout le monde"</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">5</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>
<span class="n">Bonjour</span> <span class="n">tout</span> <span class="n">le</span> <span class="n">monde</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="n">b</span><span class="o">.</span><span class="n">msg</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">6</span><span class="p">]:</span> <span class="s1">'Bonjour tout le monde'</span>
</pre></div>
<p>And that's it, we have created an interface for our code without manually
specifying anything, and it behaves just the same.</p>
</div>
</div>
<div class="section" id="going-further">
<h2>Going Further</h2>
<p>The goal of this tutorial was to illustrate the basics of Boost.Python, which
is only scratching the surface. Unfortunately, the documentation surrounding
Boost.Python is notoriously sparse, but here are some links you might find useful:</p>
<ul class="simple">
<li><a class="reference external" href="http://www.boost.org/doc/libs/1_63_0/libs/python/doc/html/index.html">Official Boost.Python documentation</a></li>
<li><a class="reference external" href="http://pyplusplus.readthedocs.io/en/latest/">Official Py++ documentation</a></li>
</ul>
<p>Oh, and did I mention that Boost.Python now has official support for interfacing
with Numpy, through Boost.Numpy ?</p>
<ul class="simple">
<li><a class="reference external" href="http://www.boost.org/doc/libs/1_63_0/libs/python/doc/html/numpy/index.html">Boost.Numpy documentation</a> (part of Boost.Python as of 1.63)</li>
</ul>
</div>

            </div>
            <!-- /.entry-content -->
        </article>
    </section>

        </div>
    </div>
</div>
<!-- End Content Container -->

<footer>
   <div class="container">
      <hr />
      <div class="row">
         <div class="col-xs-10">© 2017 François Lanusse
            · Powered by <a href="https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>                <p><small>  <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/deed.en"><img alt="Creative Commons License" style="border-width:0" src="//i.creativecommons.org/l/by-nc/4.0/80x15.png" /></a>
    Content
  licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/4.0/deed.en">Creative Commons Attribution-NonCommercial 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script type="text/javascript" async="" src="https://ssl.google-analytics.com/ga.js"></script><script src="https://flanusse.net/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://flanusse.net/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://flanusse.net/theme/js/respond.min.js"></script>


    <script src="https://flanusse.net/theme/js/bodypadding.js"></script>
    <!-- Google Analytics -->
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-93566311-1']);
        _gaq.push(['_trackPageview']);

        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <!-- End Google Analytics Code -->



</body></html>
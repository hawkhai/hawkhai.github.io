<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="initial-scale=1.0, width=device-width" />

    <title>GPU 优化技术-OpenCL 运行时 API 介绍 - 极术社区 - 连接开发者与智能计算生态</title>

    <link rel="apple-touch-icon" sizes="180x180" href="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/favicon-16x16.png" />
    <link rel="manifest" href="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/site.webmanifest" />
    <link rel="mask-icon" href="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/safari-pinned-tab.svg" color="#5bbad5" />
    <link rel="icon" href="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/favicon.ico" />
    <meta name="msapplication-config" content="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/browserconfig.xml" />
    <meta name="msapplication-TileColor" content="#da532c" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="keywords" content="核芯动力,XPU,NPU,ISP,周易,玲珑,山海,星辰,Arm架构,Arm处理器,Arm开发,Arm计算,嵌入式开发,Cortex,RISC,IoT,边缘计算,中国芯,MCU,FPGA,SoC,云服务器,自动驾驶,数据中心,元宇宙,云游戏" />
            <meta name="description" content="OpenCL 作为一套通用异构平台编程框架，由两个部分组成：其一是在主机处理器（Host）执行的运行时 API；其二是基于 C99 标准扩展的 OpenCL C 语言，用于编写在设备处理器（OpenCL device）运行的内核（kernel）代码。" />
    

    <link rel="stylesheet" href="https://cdn-assets.aijishu.com/v-3f2b4b21/global/index.css" />
            <link rel="stylesheet" href="https://cdn-assets.aijishu.com/v-3f2b4b21/article/index.css" />
    
    
    <!-- 搜索引擎验证 -->
    <meta name="google-site-verification" content="XcyZUtQhpeXA50xtZ63xnFmA5iIqiorFMOxhV2fC4XQ" />
    <meta name="baidu-site-verification" content="s0lFk3Hoik" />
    <meta name="sogou_site_verification" content="hxHtsr4JvB" />
    <meta name="360-site-verification" content="988f9e138fa5db3d4e3dcf410291387a" />
    <meta name="msvalidate.01" content="204A27EF763804B2A276CFF09E503E3F" />
    <meta name="shenma-site-verification" content="6f78bb6a6ae2bb74a97324e1ef7cce25_1590631795" />

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script type="text/javascript" async="" src="https://www.google-analytics.com/analytics.js"></script><script async="" defer="" src="https://sponsor.segmentfault.com/fl.js"></script><script async="" defer="" src="https://sponsor.segmentfault.com/spc.php?zones=18%7C19%7C20&amp;source=&amp;r=50322087&amp;block=1&amp;charset=UTF-8&amp;loc=https%3A//aijishu.com/a/1060000000293412"></script><script async="" defer="" src="https://sponsor.segmentfault.com/spcjs.php?id=2&amp;block=1"></script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-918487-15"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        function imgError(image) {
            image.onerror = "";
            image.src = "https://cdn-assets.aijishu.com/v-3f2b4b21/public/avatar/user.svg";
            return true;
        }
        gtag('js', new Date());

        gtag('config', 'UA-918487-15');
            </script>

    <script>
        var _oa = [], OA_google = false;

        function OA_script(src, cb) {
            var s = document.createElement('script'), m = document.getElementsByTagName('script')[0];

            if (cb) {
                s.onload = cb;
            }

            s.async = 1;
            s.defer = 1;
            s.src = src;
            m.parentNode.insertBefore(s, m);
        }

        function OA_show(name) {
            _oa.push(name);
            document.write('&lt;div id=\"OA_holder_' + name + '\"&gt;&lt;/div&gt;');
        }

        OA_script('https://sponsor.segmentfault.com/spcjs.php?id=2&amp;block=1');
    </script>
</head>
<body class="">
<div class="d-none"><img src="https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/wechat-share-icon.png" alt="" /></div>
    <nav class="ent-header navbar navbar-expand-lg navbar-dark bg-primary shadow-sm">
        <div class="container">
            <a class="navbar-brand font-weight-bold text-hide" id="logo" href="/">极术社区</a>

                        
            <a class="btn btn-primary d-lg-none px-1 ml-auto mr-2" href="/search" data-target=""><i class="far fa-search"></i></a>
                            <a class="btn btn-light d-lg-none mr-2" href="/login" data-target="#loginModal">注册</a>
                                                                                                                                                                                                
            <button class="navbar-toggler px-2" type="button" data-toggle="collapse" data-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>

            <div class="collapse navbar-collapse" id="navbarNavDropdown">
                <ul class="navbar-nav font-weight-bold">
                                                                <li class="nav-item">
                            <a class="nav-link " href="/">
                                <span class="position-relative">
                                首页
                                                                </span>

                            </a>
                        </li>
                                            <li class="nav-item">
                            <a class="nav-link " href="/blogs">
                                <span class="position-relative">
                                Top 专栏
                                                                    <img class="blog-badge" src="https://cdn-assets.aijishu.com/v-3f2b4b21/public/top100@2x.png" alt="" />
                                                                </span>

                            </a>
                        </li>
                                            <li class="nav-item">
                            <a class="nav-link " href="/topics">
                                <span class="position-relative">
                                专题
                                                                </span>

                            </a>
                        </li>
                                            <li class="nav-item">
                            <a class="nav-link " href="/questions">
                                <span class="position-relative">
                                问答
                                                                </span>

                            </a>
                        </li>
                                            <li class="nav-item">
                            <a class="nav-link " href="/lives">
                                <span class="position-relative">
                                公开课
                                                                </span>

                            </a>
                        </li>
                                            <li class="nav-item">
                            <a class="nav-link " href="/events">
                                <span class="position-relative">
                                活动
                                                                </span>

                            </a>
                        </li>
                                    </ul>
                <form class="ent-header-search form-inline my-2 my-lg-0 mx-auto d-none d-lg-block" action="/search" style="width: 35%">
                    <input class="form-control border-0 w-100" type="search" name="q" value="" placeholder="搜索关键字" aria-label="搜索" />
                </form>
                <ul class="navbar-nav">
                                            <li class="nav-item d-none d-lg-block">
                            <a class="nav-link pr-0" href="/login" data-target="#loginModal">注册 · 登录</a>
                        </li>
                                    </ul>
            </div>
        </div>
    </nav>

<div data-js-back2top="" hidden="" class="back2top">
    <button type="button" class="btn btn-light d-none d-lg-block">▲</button>
</div>

    <div class="container position-relative">
                <div class="row py-4">
            <div class="col-lg-1 handle-bar text-center d-none d-lg-block">
                <div class="">
                    <a id="article-like-side-btn" data-icon-count="" data-toggle-button-api="/api/article/1060000000293412/vote/up" data-count-sel="[data-icon-count-size]" data-link-sel="#article-like-bottom-btn" data-toggle-style="link" data-state="false" href="javascript:;" style="width: 38px; height: 38px" class="bg-white d-inline-flex align-items-center justify-content-center rounded-circle">
                        <i class="far fa-thumbs-up"></i>
                    </a>
                    <div data-icon-count-size="" class="mt-1 h5 text-body">3</div>
                </div>

                <div>
                    <hr />
                </div>

                <div class="mb-3">
                    <a id="article-bookmark-side-btn" data-toggle-button-api="/api/article/1060000000293412/bookmark" data-count-sel="[data-bookmark-count-size]" data-link-sel="#article-bookmark-bottom-btn" data-toggle-style="link" data-state="false" href="javascript:;">
                        <i class="far fa-bookmark"></i>
                    </a>
                </div>
                <div class="dropdown d-inline" data-qr-direct="right" data-share-title="%E6%88%91%E5%9C%A8+%40%E6%9E%81%E6%9C%AF%E7%A4%BE%E5%8C%BA+%E4%B8%8A%E5%8F%91%E7%8E%B0%E4%BA%86%E3%80%8AGPU+%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF-OpenCL+%E8%BF%90%E8%A1%8C%E6%97%B6+API+%E4%BB%8B%E7%BB%8D%E3%80%8B%EF%BC%8C%E5%BF%AB%E6%9D%A5%E7%9C%8B%E7%9C%8B%E5%90%A7" data-share-url="/a/1060000000293412"><a href="#" role="button" id="share-9388707" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <i class="far fa-share-alt"></i>
      </a>

      <div class="dropdown-menu" aria-labelledby="share-9388707">
        <a class="dropdown-item share-link" data-clipboard-text="https://aijishu.com/a/1060000000293412" href="javascript:;"><i class="far fa-link mr-2 text-secondary"></i>复制链接</a>
        <a class="dropdown-item share-weibo" href="javascript:;"><i class="fab fa-weibo mr-2 text-danger"></i>新浪微博</a>
        <a class="dropdown-item share-weixin" href="javascript:;" data-original-title="" title=""><i class="fab fa-weixin mr-2 text-success"></i>微信扫一扫</a>
      </div></div>
            </div>

            <div class="col-lg-8">
                <div class="card border-0">
                    <div class="card-body">
                        <div class="d-flex align-items-center font-size-14 mb-3">
                            <a class="d-flex align-items-center" href="/u/jackli">
                                <picture class="mr-2">
                                    <img class="d-inline-block rounded-circle" width="24" src="https://cdn-avatar.aijishu.com/384/927/384927933-5dc918b794754_24" aria-hidden="true" onerror="imgError(this);" />
                                </picture>
                                <span class="text-body">JackLi</span>
                            </a>
                                                        <span class="ml-1 text-secondary">·
								1月14日</span>
                        </div>

                        <h1 class="h2 mb-3">
                            <a class="text-body" href="/a/1060000000293412">GPU 优化技术-OpenCL 运行时 API 介绍</a>
                        </h1>

                        <div class="d-flex flex-wrap mb-4">
                            <div class="m-n1"><a class="m-1 badge-tag" href="/t/embedded-system">嵌入式系统</a></div>
                        </div>

                        <article class="fmt">
                            <blockquote>原文：<a href="/link?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F451101452" target="blank">知乎</a><br />文章发表于知乎专栏<a href="/link?target=https%3A%2F%2Fwww.zhihu.com%2Fcolumn%2Fc_1409292193428979712" target="blank">《移动端算法优化》</a><br />作者：高性能计算学院</blockquote><h2 id="item-1">一、概述</h2><p>OpenCL 作为一套通用异构平台编程框架，由两个部分组成：其一是在<strong>主机处理器（Host）</strong>执行的<strong>运行时 API</strong>；其二是基于 C99 标准扩展的 OpenCL C 语言，用于编写在<strong>设备处理器（OpenCL device）</strong>运行的<strong>内核（kernel）</strong>代码。</p><p>Host 端的运行时 API 负责管理资源，控制 host 和 device 端程序执行，构成了 OpenCL 程序的框架。不恰当地使用 OpenCL 运行时 API 可能带来极大的性能损失，甚至造成程序崩溃。</p><p>接下来我们会对 OpenCL 运行时 API 做系统而详细的介绍。首先给出 OpenCL 运行时 API 的整体编程流程图，然后针对每一步结合实例说明，最后展示基于 OpenCL 的图像转置代码并计算加速比。</p><h2 id="item-2">二、OpenCL 运行时 API 的编程流程</h2><h3 id="item-2-1">2.1 OpenCL Host 端编程全流程</h3><p>下图展示了一张典型的 OpenCL Host 端编程流程图。接下来我们会解释每一步的作用，列出相关的API并展示实例代码。<br /><img referrerpolicy="no-referrer" src="/img/bVbouE" alt="image.png" title="image.png" /><br />使用 OpenCL API 编程<strong>务必及时检查 API 的返回值</strong>是否为 <code>CL_SUCCESS</code>。为了简化篇幅，第二节示例代码不检查 API 返回值，省略 <code>malloc</code> 内存释放。</p><h3 id="item-2-2">2.2 OpenCL Host端编程分步详解</h3><h4>2.2.1 获取平台Platform</h4><p><strong>作用说明</strong></p><p>Host 端编程第 1 步是获取硬件<strong>平台 Platform</strong>，查询 OpenCL 版本等平台信息。使用 <code>clGetPlatformIDs</code> 和 <code>clGetPlatformInfo</code> 两个API。</p><p><strong>API函数说明</strong></p><ul><li><strong>clGetPlatformIDs</strong></li></ul><pre><code>cl_int clGetPlatformIDs( cl_uint num_entries, 
                         cl_platform_id *platforms, 
                         cl_uint *num_platforms)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />OpenCL 使用 <code>cl_platform_id</code> 表示平台，通过 <code>clGetPlatformIDs</code> 获取可使用的平台数组。当平台数未知，第一次调用 <code>clGetPlatformIDs</code> 获取平台个数，第二次调用 <code>clGetPlatformIDs</code> 获取平台对象。  </p><p><strong>参数说明：</strong>  <br />num_entries[IN] ：要获取的平台数量，如果 platforms 非空，则 num_entries 不能为 0。  <br />platforms[OUT] ：返回获取的平台对象数组。  <br />num_platforms[OUT] ：用于查询返回可用的平台数目，num_platforms 可设为 NULL 忽略。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值请参考[1]中 4.1节。</p></blockquote><ul><li><strong>clGetPlatformInfo</strong></li></ul><pre><code>cl_int clGetPlatformInfo( cl_platform_id platform, 
                          cl_platform_info param_name, 
                          size_t param_value_size, 
                          void *param_value, 
                          size_t *param_value_size_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />获取平台相关信息，如 OpenCL 配置版本。  </p><p><strong>参数说明：</strong>  <br />platform[IN] ：查询的平台对象。  <br />param_name[IN] ：表示平台查询参数的枚举常量，参考表 2-1。  <br />param_value_size[IN] ：param_value 指向内存空间的字节数。  <br />param_value[OUT] ：指向返回查询参数结果的内存指针。  <br />param_value_size_ret[OUT] ：返回查询参数的实际长度。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值请参考[1]中 4.1 节。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouF" alt="image.png" title="image.png" /></p><p><strong>实例代码</strong></p><p>下面给出两步查询法获取平台及相关信息的实例代码。</p><pre><code>void PrintPlatformMsg(cl_platform_id *platform, cl_platform_info platform_info,
                      const char *platform_msg)
{
    size_t size;
    int err_num;
    // 1. 第一步通过size获取打印字符串长度
    err_num             = clGetPlatformInfo(*platform, platform_info, 0, NULL, &amp;size);
    char *result_string = (char *)malloc(size);
    // 2. 第二步获取平台信息到result_string 
    err_num             = clGetPlatformInfo(*platform, platform_info, size, result_string, NULL);
    printf("%s=%s\n", platform_msg, result_string);
    free(result_string);
    result_string = NULL;
}

cl_int err_num;
cl_uint num_platform;
cl_platform_id *platform_list;
// 1. 第一次调用获取平台数
err_num = clGetPlatformIDs(0, NULL, &amp;num_platform);
printf("num_platform=%d\n", num_platform);
platform_list = (cl_platform_id *)malloc(sizeof(cl_platform_id) * num_platform);
// 2. 第二次调用获取平台对象数组
err_num       = clGetPlatformIDs(num_platform, platform_list, NULL);
printf("err_num = %d\n", err_num);
// 打印平台信息
PrintPlatformMsg(&amp;platform_list[0], CL_PLATFORM_PROFILE, "Platform Profile");
PrintPlatformMsg(&amp;platform_list[0], CL_PLATFORM_VERSION, "Platform Version");
PrintPlatformMsg(&amp;platform_list[0], CL_PLATFORM_NAME, "Platform Name");
PrintPlatformMsg(&amp;platform_list[0], CL_PLATFORM_VENDOR, "Platform Vendor");</code></pre><p>在高通865平台运行结果如下：</p><pre><code>num_platform=1
err_num = 0
Platform Profile=FULL_PROFILE
Platform Version=OpenCL 2.0 QUALCOMM build: commit #d970ca5f2e changeid #Ifead41f47e Date: 07/14/21 Wed Local Branch:  Remote Branch: 
Platform Name=QUALCOMM Snapdragon(TM)
Platform Vendor=QUALCOMM</code></pre><h4>2.2.2 获取设备Device</h4><p><strong>作用说明</strong></p><p>获取平台下的 OpenCL <strong>设备 Device</strong>，查询设备的硬件参数。使用 <code>clGetDeviceIDs</code> 和 <code>clGetDeviceInfo</code>两个API。</p><p><strong>API函数说明</strong></p><ul><li><strong>clGetDeviceIDs</strong></li></ul><pre><code>cl_int clGetDeviceIDs (cl_platform_id platform, 
                       cl_device_type device_type, 
                       cl_uint num_entries, 
                       cl_device_id *devices, 
                       cl_uint *num_devices)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />获取平台可使用的 Device 对象数组。OpenCL 使用 <code>cl_device_id</code> 表示 Device 对象。  </p><p><strong>参数说明：</strong>  <br />platform[IN] ：<code>clGetPlatformIDs</code> 获取的 Platform ID。  <br />device_type[IN] ：获取 OpenCL Device 的类型，参考表 2-2。  <br />num_entries[IN] ：要获取的设备数量。  <br />devices[OUT] ：返回获取的设备对象数组。  <br />num_devices[OUT]：返回平台连接 device_type 类型设备数目，可设为 NULL 忽略。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 4.2 节。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouG" alt="image.png" title="image.png" /></p><ul><li><strong>clGetDeviceInfo</strong></li></ul><pre><code>cl_int clGetDeviceinfo(cl_device_id device,
                       cl_device_info param_name,
                       size_t param_value_size,
                       void *param_value,
                       size_t *param_value_size_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />获取设备相关信息，例如并行计算单元数，全局内存大小等等。  </p><p><strong>参数说明：</strong>  <br />device[IN] ：<code>clGetDeviceIDs</code> 获取的 Device ID。  <br />param_name[IN] ：表示设备查询参数的枚举常量。  <br />param_value_size[IN] ：param_value 指向内存空间的字节数。  <br />param_value[OUT] ：指向返回查询参数结果的内存指针。  <br />param_value_size_ret[OUT]：返回查询参数的实际长度。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值请参考[1]中 4.2 节。  </p><p><code>clGetDeviceInfo</code> 与 <code>clGetPlatformInfo</code>的使用方式基本一致，由于设备属性较多，表 2-3 仅列出部分常用设备硬件属性。设备属性全表请参考[1]中表 4.3。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouH" alt="image.png" title="image.png" /><br /><strong>实例代码</strong></p><p>下面给出获取设备及设备参数的实例代码。</p><pre><code>cl_uint num_device;
cl_device_id device;
// 1. 获取平台GPU类型OpenCL设备的数量
err_num = clGetDeviceIDs(platform_list[0], CL_DEVICE_TYPE_GPU, 0, NULL, &amp;num_device);
printf("GPU num_device=%d\n", num_device);
// 2. 获取一个GPU类型的OpenCL设备
err_num = clGetDeviceIDs(platform_list[0], CL_DEVICE_TYPE_GPU, 1, &amp;device, NULL);

// 对于cl_uint cl_ulong等返回类型参数只需要一步查询
cl_uint max_compute_units;
// 获取并打印OpenCL设备的并行计算单元数量
err_num = clGetDeviceInfo(device, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint),
                          &amp;max_compute_units, NULL);
printf("max_compute_units=%d\n", max_compute_units);

cl_ulong global_mem_size;
// 获取并打印OpenCL设备的全局内存大小
err_num = clGetDeviceInfo(device, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(cl_ulong),
                          &amp;global_mem_size, NULL);
printf("global_mem_size=%ld\n", global_mem_size);

size_t *p_max_work_item_sizes=NULL;
size_t size;
// CL_DEVICE_MAX_WORK_ITEM_SIZES表示work_group每个维度的最大工作项数目
// 1. 返回类型是size_t[]，首先查询返回信息的大小
err_num = clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_ITEM_SIZES, 0, NULL, &amp;size);
p_max_work_item_sizes = (size_t *)malloc(size);
// 2. 申请空间后查询结果并打印
err_num = clGetDeviceInfo(device, CL_DEVICE_MAX_WORK_ITEM_SIZES, size, p_max_work_item_sizes, NULL);
for (size_t i = 0; i &lt; size / sizeof(size_t);i++)
{
    printf("max_work_item_size_of_work_group_dim %zu=%zu\n", i, p_max_work_item_sizes[i]);
}</code></pre><p>在高通865平台运行结果如下</p><pre><code>GPU num_device=1
max_compute_units=3
global_mem_size=3988809728
max_work_item_size_of_work_group_dim 0=1024
max_work_item_size_of_work_group_dim 1=1024
max_work_item_size_of_work_group_dim 2=1024</code></pre><h4>2.2.3 创建上下文Context</h4><p><strong>作用说明</strong></p><p>选择获取的设备，创建<strong>上下文 Context</strong>。使用的API是 <code>clCreateContext</code>。OpenCL 使用 Context 管理命令队列、程序内核、内存等资源对象。</p><p><strong>API函数说明</strong></p><ul><li><strong>clCreateContext</strong></li></ul><pre><code>cl_context clCreateContext(const cl_context_properties *properties,
                           cl_uint num_devices,
                           const cl_device_id *devices,
                           void ( CL_CALLBACK *pfn_notify)(const char *errinfo, const void *private_info, size_t cb, void *user_data),
                           void *user_data,
                           cl_int *errcode_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />基于获取的平台和设备，创建一个 OpenCL 上下文，类型是 <code>cl_context</code>。  </p><p><strong>参数说明：</strong>  <br />properties[IN] ：上下文属性数组，每一项属性包含一个枚举常量，一个属性值，数组以 0 结尾。properties 指定了创建 Context 基于的 Platform，也可以设为 NULL，程序实现时自行选择 Platform。  <br />num_devices[IN] ：devices 中指定的设备数。  <br />devices[IN] ：<code>clGetDeviceIDs</code> 返回的设备对象数组。  <br />pfn_notify[IN] ：注册回调函数，当 OpenCL 创建上下文失败时会执行回调函数。没有回调可设为 NULL  <br />user_data[INOUT]：传递给回调函数 pfn_notify 的指针参数，可设为 NULL。  <br />errcode_ret[OUT] ：返回错误码，如果 errcode_ret 设为 NULL 不再返回错误码。  <br />Return ：OpenCL 上下文成功创建时，返回创建的 cl_contex t对象，errcode_ret返回<code>CL_SUCCESS</code>。创建失败时返回 NULL，errorcode_ret 返回错误码。</p></blockquote><p><strong>实例代码</strong></p><p>下面的代码使用高通 865 平台的 GPU 设备创建 Context。</p><pre><code>cl_context_properties context_prop[16] = {0};
context_prop[0]                        = CL_CONTEXT_PLATFORM;
context_prop[1]                        = (cl_context_properties)platform_list[0];

context = clCreateContext(context_prop, 1, &amp;device, NULL, NULL, &amp;err_num);
if (err_num != CL_SUCCESS)
{
    printf("Create Context failed with code=%d!\n", err_num);
}
else
{
    printf("Context successfully created!\n");
}</code></pre><p>在高通 865 平台运行结果如下：</p><pre><code>Context successfully created!</code></pre><h4>2.2.4 创建命令队列 CommandQueue</h4><p><strong>作用说明</strong></p><p>为单个设备创建<strong>命令队列</strong>，使用的 API 是 <code>clCreateCommandQueueWithProperties</code>。操作命令入队后依据队列属性<strong>顺序或者乱序执行</strong>。</p><p><strong>API函数说明</strong></p><ul><li><strong>clCreateCommandQueueWithProperties</strong></li></ul><pre><code>cl_command_queue 
clCreateCommandQueueWithProperties(cl_context context,
                                   cl_device_id device,
                                   const cl_queue_properties *properties,
                                   cl_int *errcode_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />基于 Context 和唯一的 Device，按照 <em>properties</em> 属性创建命令队列 <code>cl_command_queue</code>。  </p><p><strong>参数说明：</strong>  <br />context[IN] ：有效的上下文对象 <code>cl_context</code>。  <br />device[IN] ：与 context 关联的设备。  <br />properties[IN] ：命令队列属性数组，每一项属性包含一个枚举常量，一个属性值，数组以 0 结尾。参考表 2-4。  <br />errcode_ret[OUT]：返回错误码，如果 errcode_ret 设为 NULL 不再返回错误码。  <br />Return ：OpenCL 命令队列成功创建时，返回创建的 <code>cl_command_queue</code> 对象，errcode_ret 返回 <code>CL_SUCCESS</code>。创建失败时返回NULL，errorcode_ret 返回错误码。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouK" alt="image.png" title="image.png" /><br /><strong>实例代码</strong></p><p>下面的代码创建一个 Host 端入队的命令队列，设置 <code>CL_QUEUE_PROFILING_ENABLE</code> 属性用于性能分析。</p><pre><code>// OpenCL设备命令执行分为入队、提交、启动、结束和完成5个时间点，创建命令队列时使能CL_QUEUE_PROFILING_ENABLE才能获取设备记录的相应时间。
cl_command_queue_properties queue_prop[] = {CL_QUEUE_PROPERTIES, CL_QUEUE_PROFILING_ENABLE, 0};
cl_command_queue command_queue           = NULL;
command_queue = clCreateCommandQueueWithProperties(context, device, queue_prop, &amp;err_num);
if (err_num != CL_SUCCESS)
{
    printf("Create CommandQueue failed with code=%d!\n", err_num);
}
else
{
    printf("Host in-order profiling CommandQueue successfully created!\n");
}</code></pre><p>在高通 865 平台运行结果如下</p><pre><code>Host in-order profiling CommandQueue successfully created!</code></pre><h4>2.2.5 创建并编译内核程序 Program</h4><p><strong>作用说明</strong></p><p>这一步通过 OpenCL C 源码字符串或程序二进制两种方式之一创建<strong>内核程序 Program</strong>。编译 Program 生成二进制，检查编译错误并获取二进制代码。使用二进制代码创建 Program 能显著减少编译时间。</p><p><strong>API函数说明</strong></p><ul><li><strong>clCreateProgramWithSource</strong></li></ul><pre><code>cl_program clCreateProgramWithSource(cl_context context,
                                     cl_uint count,
                                     const char **strings,
                                     const size_t *lengths,
                                     cl_int *errcode_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />使用 OpenCL C 源代码创建 <code>cl_program</code>，程序对象关联 context 中的所有设备。  </p><p><strong>参数说明：</strong>  <br />context[IN] ：有效的Context对象。  <br />count[IN] ：表示 strings 中字符串的个数。  <br />strings[IN] ：字符串数组指针，所有的字符串构成设备源代码。  <br />lengths[IN] ：表示 strings 每个字符串的长度。lengths 可以设为 NULL，字符串以 0 结尾自动计算长度。  <br />errcode_ret[OUT]：返回错误码。errcode_ret 设为 NULL 则不再返回错误码。  <br />Return ：Program 对象成功创建时，返回创建的 <code>cl_program</code> 对象，errcode_ret 返回<code>CL_SUCCESS</code>。创建失败时返回 NULL，errorcode_ret 返回错误码。</p></blockquote><ul><li><strong>clCreateProgramWithBinary</strong></li></ul><pre><code>cl_program clCreateProgramWithBinary(cl_context context,
                                     cl_uint num_devices,
                                     const cl_device_id *device_list,
                                     const size_t *lengths,
                                     const unsigned char **binaries,
                                     cl_int *binary_status,
                                     cl_int *errcode_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />向设备载入构建好的可执行程序二进制并创建 <code>cl_program</code>。  </p><p><strong>参数说明：</strong>  <br />context[IN] : 有效的 Context 对象。  <br />num_devices[IN] : device_list 中设备个数。  <br />device_list[IN] ：context 关联的设备数组。程序二进制需要载入 device_list 所列出的设备中，因此不能为NULL。  <br />lengths[IN] ：binaries 数组中每个二进制文件的长度。  <br />binaries[IN] ：二进制文件数组。对于设备device_list[i]，其程序二进制文件是 binaries[i]，文件的长度是 lengths[i]，三者一一对应。  <br />binarystatus[OUT]：返回每个设备对应的二进制是否成功加载。成功加载返回 <code>CL_SUCCESS</code>。binary_status可设为NULL以忽略。  <br />errcode_ret[OUT] ：返回错误码。errcode_ret 设为NULL则不再返回错误码。  <br />Return ：Program 对象成功创建时，返回创建的 <code>cl_program</code> 对象，errcode_ret 返回CL_SUCCESS。创建失败时返回NULL，errorcode_ret 返回错误码。</p></blockquote><ul><li><strong>clBuildProgram</strong></li></ul><pre><code>cl_int clBuildProgram(cl_program program,
                      cl_uint num_devices,
                      const cl_device_id *device_list,
                      const char *options,
                      void (CL_CALLBACK *pfn_notify)( cl_program program, void *user_data),
                      void *user_data)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />使用 Program 源代码或者二进制生成设备可执行程序。  </p><p><strong>参数说明：</strong>  <br />program[IN] ：创建的程序对象。  <br />num_devices[IN] ：device_list 中的设备数目。  <br />device_list[IN] ：program 关联的设备对象数组。device_list 设为 NULL 时，为 program 关联的所有设备编译可执行程序。device_list 非空则仅为 device_list 中给出的设备编译可执行程序。  <br />options[IN] ：表示编译选项的字符串，例如按 OpenCL2.0 标准编译，<code>-cl-std=CL2.0</code>。请参考[1]中5.8.4节 CompilerOptions。  <br />pfn_notify[IN] ：注册回调函数。如果 pfn_notify 非空，<code>clBuildProgram</code> 在编译开始后立即返回，生成结束时异步调用回调函数。如果 pfn_notify 为空，<code>clBuildProgram</code> 必须等待生成结束才能返回。  <br />user_data[INOUT]：传递给回调函数的参数，可以设置为 NULL。  <br />Return ：成功生成可执行程序返回 <code>CL_SUCCESS</code>，错误码参考[1]中 5.8.2 节。  </p><p><code>clBuildProgram</code> 包含编译和链接过程，OpenCL2.0 也可以单独调用 <code>clCompileProgram</code> 编译，调用<code>clLinkProgram</code> 链接。</p></blockquote><ul><li><strong>clGetProgramBuildInfo</strong></li></ul><pre><code>cl_int clGetProgramBuildInfo(cl_program program,
                             cl_device_id device,
                             cl_program_build_info param_name,
                             size_t param_value_size,
                             void *param_value,
                             size_t *param_value_size_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />查询 Program 对象关联设备的编译信息，尤其是<strong>编译错误信息</strong>。  </p><p><strong>参数说明：</strong>  <br />program[IN] ：查询的程序对象。  <br />device[IN] ：指定查询编译信息的设备，设备必须与program 关联。  <br />param_name[IN] ：表示编译信息查询参数的枚举常量，参考表 2-5。  <br />param_value_size[IN] ：param_value 指向内存空间的字节数。  <br />param_value[OUT] ：指向返回查询参数结果的内存指针。  <br />param_value_size_ret[OUT]：返回查询参数的实际长度。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.8.7 节。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouO" alt="image.png" title="image.png" /></p><ul><li><strong>clGetProgramInfo</strong></li></ul><pre><code>cl_int clGetProgramInfo(cl_program program,
                        cl_program_info param_name,
                        size_t param_value_size,
                        void *param_value,
                        size_t *param_value_size_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />查询程序信息，例如获取 <code>clCreateProgramWithBinary</code> 所需的可执行二进制。  </p><p><strong>参数说明：</strong>  <br />program[IN] ：查询的程序对象。  <br />param_name[IN] ：表示编译信息查询参数的枚举常量，参考表 2-6。  <br />param_value_size[IN] ：param_value 指向内存空间的字节数。  <br />param_value[OUT] ：指向返回查询参数结果的内存指针。  <br />param_value_size_ret[OUT]：返回查询参数的实际长度。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.8.7 节。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouP" alt="image.png" title="image.png" /><br /><strong>实例代码</strong></p><p>下面代码使用 OpenCL C 代码创建 Program，编译生成后将可执行二进制保存到 bin 文件。</p><pre><code>// 1. 读取OpenCL C源代码
char *source = ClUtilReadFileToString(prog_name);
cl_int err   = 0;
// 2. 使用源代码创建program
program      = clCreateProgramWithSource(context, 1, (const char **)&amp;source, NULL, &amp;err);
// 3. 使用OpenCL2.0标准编译Program
err |= clBuildProgram(program, 0, NULL, "-cl-std=CL2.0", NULL, NULL);
if (err != CL_SUCCESS)
{
    // 如果编译失败，获取并打印错误信息
    fprintf(stderr, "Error %d with clBuildProgram.", err);
    static const size_t LOG_SIZE = 2048;
    char log[LOG_SIZE];
    log[0] = 0;
    err    = clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, LOG_SIZE, log, NULL);
    if (CL_INVALID_VALUE == err)
    {
        fprintf(stderr, "There was a build error, but there is insufficient space allocated to "
                            "show the build logs.\n");
    }
    else
    {
        fprintf(stderr, "Build error:\n%s\n", log);
    }
    exit(-1);
}
else
{
    // 4. 打印编译成功信息
    printf("Program built Ok!\n");
}
cl_uint num_devices;
// 5. 获取程序关联设备数
err |= clGetProgramInfo(program, CL_PROGRAM_NUM_DEVICES, sizeof(cl_uint), &amp;num_devices, NULL);
// 6. 获取程序关联设备ID
cl_device_id *p_devices = (cl_device_id *)malloc(sizeof(cl_device_id) * num_devices);
err |= clGetProgramInfo(program, CL_PROGRAM_DEVICES, sizeof(cl_device_id) * num_devices,
                        p_devices, NULL);
// 7. 获取设备程序二进制代码长度
size_t *p_program_binary_sizes = (size_t *)malloc(sizeof(size_t) * num_devices);
// 8. 获取设备程序二进制代码
err |= clGetProgramInfo(program, CL_PROGRAM_BINARY_SIZES, sizeof(size_t) * num_devices,
                        p_program_binary_sizes, NULL);
cl_uchar **p_program_binaries = (cl_uchar **)malloc(sizeof(cl_uchar *) * num_devices);
for (cl_uint i = 0; i &lt; num_devices; i++)
{
    p_program_binaries[i] = (cl_uchar *)malloc(p_program_binary_sizes[i]);
    printf("Binary size for device %d=%zu\n", i, p_program_binary_sizes[i]);
}
err |= clGetProgramInfo(program, CL_PROGRAM_BINARIES, sizeof(cl_uchar *) * num_devices,
                        p_program_binaries, NULL);

if (err != CL_SUCCESS)
{
    printf("Error Occur!\n");
}
// 9. 保存可执行二进制代码到文件
for (cl_uint i = 0; i &lt; num_devices; i++)
{
    char fname[25];
    sprintf(fname, "Device%dProg.bin", i);
    ClUtilWriteStringToFile(p_program_binaries[i], p_program_binary_sizes[i], fname);
    printf("Wrote file %s\n", fname);
}</code></pre><p>在高通865平台运行结果如下</p><pre><code class="console">Program built Ok!
Binary size for device 0=3516
Wrote file Device0Prog.bin</code></pre><h4>2.2.6 创建内核对象Kernel</h4><p><strong>作用说明</strong></p><p>第 6 步使用生成好的 Program 对象创建<strong>内核对象 kernel</strong>，类型为 <code>cl_kernel</code>。查询 kernel 的工作组属性以设置第 9 步执行参数。</p><p><strong>API函数说明</strong></p><ul><li><strong>clCreateKernel</strong></li></ul><pre><code>Program built Ok!
Binary size for device 0=3516
Wrote file Device0Prog.bin</code></pre><blockquote><p><strong>功能描述：</strong>  <br />根据内核函数名，从 program 对象创建 kernel 对象。  </p><p><strong>参数说明：</strong>  <br />program[IN] ：已经生成可执行二进制的内核程序对象。  <br />kernel_name[IN] ：program 中以 <code>__kernel</code> 修饰的函数名。  <br />errcode_ret[OUT] ：返回错误码，如果 errcode_ret 设为 NULL 不再返回错误码。  <br />Return ：Kernel对象成功创建时，返回创建的 <code>cl_kernel</code> 对象，errcode_ret 返回<code>CL_SUCCESS</code>。创建失败时返回 NULL，errorcode_ret 返回错误码。</p></blockquote><ul><li><strong>clGetKernelWorkGroupInfo</strong></li></ul><pre><code>cl_int clGetKernelWorkGroupInfo(cl_kernel kernel,
                                cl_device_id device,
                                cl_kernel_work_group_info param_name,
                                size_t param_value_size,
                                void *param_value,
                                size_t *param_value_size_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />返回指定设备kernel对象的工作组信息，例如最大工作组尺寸。  </p><p><strong>参数说明：</strong>  <br />kernel[IN] ：查询的内核对象。  <br />device[IN] ：与 kernel 关联的指定 Device ID。kernel 只与单个设备关联时，可以设为 NULL。  <br />param_name[IN] ：表示工作组信息查询参数的枚举常量，参考表 2-7。<br />param_value_size[IN] ：param_value 指向内存空间的字节数。  <br />param_value[OUT] ：指向返回查询参数结果的内存指针。  <br />param_value_size_ret[OUT]：返回查询参数的实际长度。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.9.3 节。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouQ" alt="image.png" title="image.png" /><br /><strong>实例代码</strong></p><pre><code>cl_kernel kernel;
// 1. 创建Kernel
kernel = clCreateKernel(program, kernel_name, &amp;err_num);
if (err_num != CL_SUCCESS)
{
    printf("create kernel failed.\n ");
    return NULL;
}
size_t max_work_group_size;
size_t perferred_work_group_size_multiple;
err_num = clGetKernelWorkGroupInfo(kernel, device, CL_KERNEL_WORK_GROUP_SIZE, sizeof(size_t),
                                   &amp;max_work_group_size, NULL);
err_num |=
    clGetKernelWorkGroupInfo(kernel, device, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE,
                             sizeof(size_t), &amp;perferred_work_group_size_multiple, NULL);
if (err_num != CL_SUCCESS)
{
    printf("Get kernel info failed.\n ");
    return NULL;
}
printf("Kernel %s max workgroup size=%zu\n", kernel_name, max_work_group_size);
printf("Kernel %s perferred workgroup size multiple=%zu\n", kernel_name,
       perferred_work_group_size_multiple);</code></pre><p>基于第三节转置 kernel，在高通 865 平台运行结果如下：</p><pre><code>Kernel TransposeKernel max workgroup size=1024
Kernel TransposeKernel perferred workgroup size multiple=128</code></pre><h4>2.2.7 创建内存对象</h4><p><strong>作用说明</strong></p><p>创建内存对象并读入数据。OpenCL <strong>Buffer 对象</strong>用于存储一维的标量、向量或自定义结构体数据。<strong>Image 对象</strong>则专门用于保存一到三维的图像数据。OpenCL 通过这两种内存对象实现 Host 和 Device 之间大量数据交换。</p><h5>2.2.7.1 OpenCL Buffer API 说明</h5><p>本节介绍 Buffer 对象的创建和读写，给出实例代码。</p><ul><li><strong>clCreateBuffer</strong></li></ul><pre><code>cl_mem clCreateBuffer(cl_context context,
                        cl_mem_flags flags,
                        size_t size,
                        void *host_ptr,
                        cl_int *errcode_ret)</code></pre><blockquote><strong>功能描述：</strong>  <br />创建 Buffer 对象。  <br /><strong>参数说明：</strong>  <br />context[IN] ：为context 对象分配 buffer 对象。  <br />flags[IN] ：以组合 bit 位枚举常量的方式，指定 buffer 的分配和使用信息，参考表 2-8。  <br />size[IN] ：申请内存空间字节数。  <br />host_ptr[IN] ：应用程序在 Host 端已经申请的内存空间指针。  <br />errcode_ret[OUT] ：返回错误码。errcode_ret 设为 NULL 则不再返回错误码。  <br />Return ：buffer 对象成功创建时，返回创建的 <code>cl_mem</code> 对象，errcode_ret 返回 <code>CL_SUCCESS</code>。创建失败时返回 NULL，errorcode_ret 返回错误码。</blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouR" alt="image.png" title="image.png" /></p><ul><li><strong>clEnqueueRead/WriteBuffer</strong></li></ul><pre><code>cl_int clEnqueueReadBuffer (cl_command_queue command_queue,
                            cl_mem buffer,
                            cl_bool blocking_read,
                            size_t offset,
                            size_t size,
                            void *ptr,
                            cl_uint num_events_in_wait_list,
                            const cl_event *event_wait_list,
                            cl_event *event)
cl_int clEnqueueWriteBuffer(cl_command_queue command_queue,
                            cl_mem buffer,
                            cl_bool blocking_write,
                            size_t offset,
                            size_t size,
                            const void *ptr,
                            cl_uint num_events_in_wait_list,
                            const cl_event *event_wait_list,
                            cl_event *event)</code></pre><blockquote><p><strong>功能描述：</strong>  <br /><code>clEnqueueReadBuffer</code> 从 buffer 对象读取数据到 Host 端内存，<code>clEnqueueWriteBuffer</code> 将 Host 内存数据写入 buffer 对象。  </p><p><strong>参数说明：</strong>  <br />command_queue[IN] ：读写指令入队的命令队列对象。命令队列和 buffer 应在同一 context 下创建。  <br />buffer[IN] ：有效的 buffer 对象。  <br />blocking_write和 blocking_read[IN]：如果设置为 <code>CL_TRUE</code>，表示阻塞式操作，数据传输结束才能返回。CL_FALSE表示非阻塞操作，命令入队立即返回。  <br />offset[IN] ：读写 buffer object 的字节偏移量。  <br />size[IN] ：读写数据的字节数。  <br />ptr[IN/OUT] ：host 端内存缓冲区地址。  <br />num_events_in_wait_list[IN] ：event_wait_list 内事件的数目。  <br />event_wait_list[IN] ：<code>cl_event</code> 数组。执行内核操作前，需要等待 event_wait_list 内事件执行完成。如果不需要等待，event_wait_list 设为 NULL，num_events_in_wait_list 设为 0。  <br />event[OUT] ：如果非 NULL，则此参数用于查询命令执行状态，或等待命令完成。<code>clEnqueue</code> 指令普遍包含 num_events_in_wait_list，event_wait_list，event 这三个参数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.2.2 节。</p></blockquote><p><strong>Buffer 操作实例代码</strong></p><pre><code>int num_of_elements = 512;
int err             = 0;
cl_uchar *h_A       = (cl_uchar *)malloc(num_of_elements);
cl_uchar *h_B       = (cl_uchar *)malloc(num_of_elements);
 for (int i = 0; i &lt; num_of_elements; i++)
{
    h_A[i] = i % 0xFF;
}
cl_mem buffer_A =
    clCreateBuffer(context, CL_MEM_READ_ONLY, sizeof(cl_uchar) * num_of_elements, NULL, &amp;err);
cl_mem buffer_B =
    clCreateBuffer(context, CL_MEM_WRITE_ONLY, sizeof(cl_uchar) * num_of_elements, NULL, &amp;err);
// write from host ptr to buffer     
err = clEnqueueWriteBuffer(cmd_queue, buffer_A, CL_TRUE, 0, sizeof(cl_uchar) * num_of_elements, h_A,
                           0, NULL, NULL);

/* Run a device kernel copy data from buffer_A to buffer_B */

// Read from buffer to host ptr
err = clEnqueueReadBuffer(cmd_queue, buffer_B, CL_TRUE, 0, sizeof(cl_uchar) * num_of_elements, h_B, 0,
                          NULL, NULL);
                          
clReleaseMemObject(buffer_A);
clReleaseMemObject(buffer_B);
// Return true if two arrays match
bool match = CompareArray(h_A, h_B, num_of_elements);
if (match)
    printf("A and B match!\n");
else
    printf("A and B mismatch!\n");
free(h_A);
free(h_B);</code></pre><p>高通865平台运行结果如下</p><pre><code>A and B match!</code></pre><h5>2.2.7.2 OpenCL Image API 说明</h5><p>Image 对象封装了图像大小、图像格式、坐标模式、插值模式等多种信息。Image 对象在 Device 端可使用采样器 Sampler 方便地读取图像。本节介绍 Image 对象和采样器对象的创建，Image 对象的读写并给出实例代码。</p><ul><li><strong>clCreateImage</strong></li></ul><pre><code>cl_mem clCreateImage(cl_context context,
                     cl_mem_flags flags,
                     const cl_image_format *image_format,
                     const cl_image_desc *image_desc,
                     void *host_ptr,
                     cl_int *errcode_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />创建指定格式、类型、尺寸的图像。  </p><p><strong>参数说明：</strong>  <br />context[IN] ：为 context 对象分配 Image 对象。  <br />flags[IN] ：指定缓冲区的分配和使用信息，枚举类型与 <code>clCreateBuffer</code> 一致。  <br />image_format[IN]：图像格式，包括图像通道顺序和数据类型。  <br />image_desc[IN] ：图像描述，包括图像类型、图像宽高和 pitch 等参数。 <br />host_ptr[IN] ：host端内存地址，可用于初始化图像数据或设为 NULL。 <br />errcode_ret[OUT] ：返回错误码。errcode_ret 设为 NULL 则不再返回错误码。  <br />Return ：buffer 对象成功创建时，返回创建的 <code>cl_mem</code> 对象，errcode_ret 返回 <code>CL_SUCCESS</code>。创建失败时返回 NULL，errorcode_ret 返回错误码。</p><p><code>cl_image_format</code> 结构体包含<code>image_channel_order</code> 和<code>image_channel_data_type</code> 两个成员，详情查询[1]中表 5.6 和 5.7。举例来说，<code>image_channel_order=CL_RGBA</code>，<code>image_channel_data_type=CL_UNSIGNED_INT8</code>表示图像每个像素包括 RGBA 四个通道，每个通道的数据都是 8 位无符号整数。内存布局如下。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouS" alt="image.png" title="image.png" /></p><blockquote><code>cl_image_desc</code> 结构体包含图像类型，图像尺寸和一个 <code>cl_mem</code> 对象，参考[1]中 5.3.1.2 节。  <br />以 2D 图像为例，关键的尺寸参数 <code>image_height</code>，<code>image_width</code> 和 <code>image_row_pitch</code>。其中 <code>image_height</code> 和 <code>image_width</code> 以像素为单位。为了内存对齐，往往在图像每一行结尾填充位数，<code>image_row_pitch</code> 表示图像每一行的字节数。</blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouT" alt="image.png" title="image.png" /></p><pre><code>cl_image_format image_format;
image_format.image_channel_order     = CL_RGBA;
image_format.image_channel_data_type = CL_UNSIGNED_INT8;

cl_image_desc image_desc;
cl_uint pitch_align;
// 查询设备的2Dimage对齐字节
err_num = clGetDeviceInfo(device, CL_DEVICE_IMAGE_PITCH_ALIGNMENT, sizeof(cl_uint),
                          &amp;pitch_align, NULL);
printf("image2D pitch align=%d\n", pitch_align);
memset(&amp;image_desc, 0, sizeof(cl_image_desc));
image_desc.image_type   = CL_MEM_OBJECT_IMAGE2D;
image_desc.image_height = height;
image_desc.image_width  = width;
// 图像每一行的字节数，宽度*通道*元素大小，做内存对齐
image_desc.image_row_pitch = (width*channels*sizeof(cl_uchar) + pitch_align - 1) / pitch_align * pitch_align;</code></pre><p>高通865平台的查询结果是</p><pre><code>image2D pitch align=64</code></pre><ul><li><strong>clEnqueueRead/WriteImage</strong></li></ul><pre><code>cl_int clEnqueueReadImage(cl_command_queue command_queue,
                           cl_mem image,
                           cl_bool blocking_read,
                           const size_t *origin,
                           const size_t *region,
                           size_t row_pitch,
                           size_t slice_pitch,
                           void *ptr,
                           cl_uint num_events_in_wait_list,
                           const cl_event *event_wait_list,
                           cl_event *event)
cl_int clEnqueueWriteImage(cl_command_queue command_queue,
                           cl_mem image,
                           cl_bool blocking_write,
                           const size_t *origin,
                           const size_t *region,
                           size_t input_row_pitch,
                           size_t input_slice_pitch,
                           const void * ptr,
                           cl_uint num_events_in_wait_list,
                           const cl_event *event_wait_list,
                           cl_event *event)</code></pre><blockquote><p><strong>功能描述：</strong>  <br /><code>clEnqueueReadImage</code> 从 image 对象读取数据到 host 内存，<code>clEnqueueWriteImage</code> 将 host 内存数据写入 image 对象。  </p><p><strong>参数说明：</strong>  <br />command_queue[IN] ：读写指令入队的命令队列对象。命令队列和 image 应在同一 context 下创建  <br />image[IN] ：有效的 image 或 image array 对象。  <br />blocking_read/blocking_write[IN] ：如果设置为 <code>CL_TRUE</code>，表示阻塞式操作，数据传输结束才能返回。 <code>CL_FALSE</code> 表示非阻塞操作，命令入队立即返回。  <br />origin[IN] ：定义 image 对象的三维原点坐标 (x,y,z)，用于控制像素数据读写偏移。  <br />region[IN] ：定义 image 对象的 (width,height,depth) 坐标范围。因此图像数据读写的坐标范围是 (x,y,z) 到 (x+width,y+height,z+depth)。 <br />row_pitch[IN] ：表示 2D 以上图像每行的字节数。  <br />slice_pitch[IN] ：表示 3D 图像每层的字节数。  <br />ptr[IN/OUT] ：host 端内存缓冲区地址。  <br />num_events_in_wait_list[IN] ：event_wait_list 内事件的数目。<br />event_wait_list[IN] ：<code>cl_event</code> 数组。执行内核操作前，需要等待 event_wait_list 内事件执行完成。如果不需要等待，event_wait_list 设为NULL，num_events_in_wait_list 设为 0。  <br />event[OUT] ：如果非 NULL，则此参数用于查询命令执行状态，或等待命令完成。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.3.3 节。</p></blockquote><ul><li><strong>clCreateSampler</strong></li></ul><pre><code>cl_sampler clCreateSamplerWithProperties (cl_context context,
                                          const cl_sampler_properties *sampler_properties,
                                          cl_int *errcode_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />创建 Sampler 对象。GPU 设备通过 Sampler 读取图像时，使用更高效的纹理处理器和纹理缓存提高读取效率；使用硬件内建的边界及插值处理，降低编程复杂度。  </p><p><strong>参数说明：</strong>  <br />context[IN] ：为 context 对象分配 Sampler 对象。  <br />sampler_properties[IN] ：采样器属性，包括坐标归一化，采样边界处理模式和采样插值滤波模式。  <br />errcode_ret[OUT] ：返回错误码。errcode_ret 设为 NULL 则不再返回错误码。  <br />Return ：sampler 对象成功创建时，返回创建的 <code>cl_sampler</code> 对象，errcode_ret 返回<code>CL_SUCCESS</code>。创建失败时返回 NULL，errorcode_ret 返回错误码。</p></blockquote><p><strong>Image操作实例代码</strong></p><p>下面例子通过 OpenCV 读取图像，展示了 Image 对象的运行时 API 操作。</p><pre><code>cl_mem memobject[2] = {0, 0};
cv::Mat src = cv::imread("./lena512x512.jpg", 1);
cv::cvtColor(src, src, cv::COLOR_BGR2BGRA);

// create opencl memobject
cl_image_format image_format;
image_format.image_channel_order = CL_RGBA;
image_format.image_channel_data_type = CL_UNORM_INT8;

cl_image_desc image_desc;
memset(&amp;image_desc, 0, sizeof(cl_image_desc));
image_desc.image_type = CL_MEM_OBJECT_IMAGE2D;
image_desc.image_width = src.cols;
image_desc.image_height = src.rows;

// Create Image with CL_MEM_COPY_HOST_PTR
memobject[0] = clCreateImage(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, &amp;image_format, &amp;image_desc, src.data, &amp;err_num);
memobject[1] = clCreateImage(context, CL_MEM_WRITE_ONLY, &amp;image_format, &amp;image_desc, NULL, &amp;err_num);

/**************Set Arg and Run Kenel*********************/

// copy result from device to host
cv::Mat gpu_dst(src.size(), src.type());
size_t origin[3] = {0, 0, 0};
size_t region[3] = {(size_t)src.cols, (size_t)src.rows, 1};
err_num = clEnqueueReadImage(command_queue, memobject[1], CL_TRUE, origin, region,
                                0, 0, gpu_dst.data, 0, NULL, NULL);</code></pre><h4>2.2.8 设置 kernel 参数</h4><p><strong>作用说明</strong></p><p>准备好 kernel 对象和输入输出 mem 对象后，这一步设置 kernel 函数参数。</p><p><strong>API函数说明</strong></p><ul><li><strong>SetKernelArg</strong></li></ul><pre><code>cl_int clSetKernelArg(cl_kernel kernel,
                      cl_uint arg_index,
                      size_t arg_size,
                      const void *arg_value)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />设置kernel函数的单个参数。  </p><p><strong>参数说明：</strong>  <br />kernel[IN] ：有效的内核对象。  <br />arg_index[IN]：内核函数参数索引，对于 n 个参数的内核函数，arg_index 从 0 编号到 n-1。  <br />arg_size[IN] ：第 arg_index 个参数占内存大小。  <br />arg_value[IN]：指向传入参数数据的指针。  <br />Return ：成功生成可执行程序返回 <code>CL_SUCCESS</code>，错误码参考[1]中 5.9.2 节。</p></blockquote><p><strong>实例代码</strong></p><p>例如对于下面的 kernel 函数</p><pre><code>// 依次设置参数
err |= clSetKernelArg(kernel, 0, sizeof(cl_mem), &amp;image_src);
err |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &amp;image_dst);
err |= clSetKernelArg(kernel, 2, sizeof(cl_sampler), &amp;sampler);
err |= clSetKernelArg(kernel, 3, sizeof(int), &amp;image_width);
err |= clSetKernelArg(kernel, 4, sizeof(int), &amp;image_height);

/* // 对应的 kernel 代码
__kernel
void kernel_func(__read_only image2d_t src_img,    // arg_idx=0 
                 __write_only image2d_t dst_img,  // arg_idx=1 
                 sampler_t sampler,               // arg_idx=2
                 int width,                       // arg_idx=3
                 int height)                      // arg_idx=4
*/</code></pre><h4>2.2.9 执行内核</h4><p><strong>作用说明</strong></p><p>设置 kernel 的任务网格尺寸，并执行内核。</p><p><strong>API 函数说明</strong></p><ul><li><strong>clEnqueueNDRangeKernel</strong></li></ul><pre><code>cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue,
                              cl_kernel kernel,
                              cl_uint work_dim,
                              const size_t *global_work_offset,
                              const size_t *global_work_size,
                              const size_t *local_work_size,
                              cl_uint num_events_in_wait_list,
                              const cl_event *event_wait_list,
                              cl_event *event)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />提交内核执行命令，提交后 API 立即返回 Host。设备会按照设定的 work-item 网格尺寸启动内核函数执行。  </p><p><strong>参数说明：</strong>  <br />command_queue[IN] ：提交内核执行命令的命令队列。  <br />kernel[IN] ：在设备上执行的内核函数。  <br />work_dim[IN] ：work-item 的组织维度，0 &lt; work_dim &lt;= 3，全局 work-item 和工作组内work-item维度相同。  <br />global_work_offset[IN] ：数组，表示 0~ work_dim-1 维全局工作项 ID 的偏移量。可设为 NULL，每个维度偏移量为 0。  <br />global_work_size[IN] ：全局工作项尺寸数组，全局工作项总数为 <code>global_work_size[0]*...* global_work_size[work_dim-1]</code> 。  <br />local_work_size[IN] ：工作组尺寸数组，工作组内工作项个数为<code>local_work_size[0]*...* local_work_size[work_dim-1]</code> 。  <br />num_events_in_wait_list[IN]：event_wait_list 内事件的数目。  <br />event_wait_list[IN] ：<code>cl_event</code> 数组。执行内核操作前，需要等待 event_wait_list 内事件执行完成。如果不需要等待，event_wait_list 设为 NULL，num_events_in_wait_list 设为 0。  <br />event[OUT] ：如果非 NULL，则此参数用于查询命令执行状态，或等待命令完成。</p></blockquote><p><strong>实例代码</strong></p><p>下面的代码按照图像数据的 width 和 height 划分全局工作项，以 16x16 个工作项为单位构建工作组。</p><pre><code>size_t global_worksize[2] = {width, height};

// work_group尺寸不能超过clGetKernelWorkGroupInfo查询的CL_KENREL_WORK_GROUP_SIZE
size_t local_worksize[2] = {16, 16};
err_num = clEnqueueNDRangeKernel(command_queue, buffer_kernel, 2, NULL, 
                                 global_worksize, local_worksize, 0, NULL, NULL);</code></pre><h4>2.2.10 主机和设备同步</h4><p><strong>作用说明</strong></p><p>OpenCL Host 和 Device 之间为异步操作，Host 读取 Device 数据前应确保 Device 端相关命令执行完成。可使用 <code>clFinish</code> 或 <code>clWaitForEvents</code> 进行同步。此外 <code>clEnqueueRead/WriteBuffer</code> 等也能起到阻塞同步的作用。</p><p><strong>API函数说明</strong></p><ul><li><strong>clFinsh</strong></li></ul><pre><code>cl_int clFinish (cl_command_queue command_queue)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />阻塞 Host 直到 command_queue 中入队命令全部执行完成，应谨慎使用。 </p><p><strong>参数说明：</strong>  <br />command_queue[IN] ：要阻塞等待的命令队列。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中5.15节。</p></blockquote><ul><li><strong>clWaitForEvents</strong></li></ul><pre><code>cl_int clWaitForEvents (cl_uint num_events, const cl_event *event_list)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />等待事件列表关联的设备命令执行完成。  </p><p><strong>参数说明：</strong>  <br />num_events[IN] ：event_list 中事件数量。  <br />event_list[IN] ：所有要等待执行完成的事件。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.11 节。</p></blockquote><ul><li><strong>clGetProfilingInfo</strong></li></ul><pre><code>cl_int clGetEventProfilingInfo (cl_event event,
                                cl_profiling_info param_name,
                                size_t param_value_size,
                                void *param_value,
                                size_t *param_value_size_ret)</code></pre><blockquote><p><strong>功能描述：</strong>  <br />使用 <code>clEnqueue</code> 命令返回的 Event 对象抓取设备计时。命令队列属性需要使能<code>CL_QUEUE_PROFILING_ENABLE</code>。  </p><p><strong>参数说明：</strong>  <br />event[IN] ：<code>clEnqueue</code> 命令返回的 Event 对象。  <br />param_name[IN] ：表示 Profiling 信息查询参数的枚举常量，参考表 2-9。  <br />param_value_size[IN] ：param_value 指向内存空间的字节数。  <br />param_value[OUT] ：指向返回查询参数结果的内存指针。  <br />param_value_size_ret[OUT] ：返回查询参数的实际长度。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回查询[1]中 5.14 节。</p></blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouU" alt="image.png" title="image.png" /></p><blockquote>表 2-9 列出了命令执行的入队(queue)、提交(submit)、启动(start)、结束(end)和完成(complete)五个时间点，按时间线分为4个时间段。其中最值得关注的是启动到结束的时间，表示kernel函数的运行时间。</blockquote><p><img referrerpolicy="no-referrer" src="/img/bVbouV" alt="image.png" title="image.png" /></p><blockquote>下面给出 Host 端打印各阶段时长的代码</blockquote><pre><code>void PrintProfilingInfo(cl_event event)
{
    cl_ulong t_queued;
    cl_ulong t_submitted;
    cl_ulong t_started;
    cl_ulong t_ended;
    cl_ulong t_completed;
    
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_QUEUED, sizeof(cl_ulong), &amp;t_queued, NULL);
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_SUBMIT, sizeof(cl_ulong), &amp;t_submitted, NULL);
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_START, sizeof(cl_ulong), &amp;t_started, NULL);
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_END, sizeof(cl_ulong), &amp;t_ended, NULL);
    clGetEventProfilingInfo(event, CL_PROFILING_COMMAND_COMPLETE, sizeof(cl_ulong), &amp;t_completed, NULL);

    printf("queue -&gt; submit : %fus\n", (t_submitted - t_queued) * 1e-3);
    printf("submit -&gt; start : %fus\n", (t_started - t_submitted) * 1e-3);
    printf("start -&gt; end : %fus\n", (t_ended - t_started) * 1e-3);
    printf("end -&gt; finish : %fus\n", (t_completed - t_ended) * 1e-3);
}</code></pre><blockquote>对第三节示例代码的 kernel 做 Profiling 分析，可以看到 start -&gt; end 的 kernel 函数执行时间占主体。kernel 函数内没有设备端入队指令，end-&gt;finish 耗时为 0。</blockquote><pre><code>queue -&gt; submit : 145.920000us
submit -&gt; start : 88.064000us
start -&gt; end : 10540.032000us
end -&gt; finish : 0.000000us</code></pre><h4>2.2.11 读取 Device 处理结果</h4><p><strong>作用说明</strong></p><p>OpenCL Device kernel 以 buffer 或者 Image 的方式向 Host 返回数据，可使用 <code>clEnqueueReadBuffer</code> 或 <code>clEnqueueReadImage</code> 读取计算处理结果。</p><h4>2.2.12 清理 OpenCL 资源</h4><p><strong>作用说明</strong></p><p>OpenCL 程序执行的最后一步是手动清理在 Context 上申请的全部资源。我们建议停止使用的 OpenCL 资源尽早释放，按照与创建时相反的次序释放 OpenCL 系统资源。</p><p>OpenCL 资源普遍采用引用计数机制进行管理，当引用计数降为 0，且相关设备命令执行完成、附属资源释放后，资源对象删除。</p><p><strong>API函数说明</strong></p><ul><li><strong>clReleaseMemObject</strong></li></ul><pre><code>cl_int clReleaseMemObject(cl_mem memobj)</code></pre><blockquote><strong>参数说明：</strong>  <br />memobj[IN] ：减少memobj 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 5.5.1 节。</blockquote><ul><li><strong>clReleaseEvent</strong></li></ul><pre><code>cl_int clReleaseEvent (cl_event event)</code></pre><blockquote><strong>参数说明：</strong>  <br />event[IN] ：减少 event 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 5.11 节。</blockquote><ul><li><strong>clReleaseSampler</strong></li></ul><pre><code>cl_int clReleaseSampler (cl_sampler sampler)</code></pre><blockquote><strong>参数说明：</strong>  <br />sampler[IN] ：减少 sampler 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 5.7.1 节。</blockquote><ul><li><strong>clReleaseKernel</strong></li></ul><pre><code>cl_int clReleaseKernel (cl_kernel kernel)</code></pre><blockquote><strong>参数说明：</strong>  <br />kernel[IN] ：减少 kernel 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 5.9.1 节。</blockquote><ul><li><strong>clReleaseProgram</strong></li></ul><pre><code>cl_int clReleaseProgram (cl_program program)</code></pre><blockquote><strong>参数说明：</strong>  <br />program[IN] ：减少 program 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 5.8.1 节。</blockquote><ul><li><strong>clReleaseCommandQueue</strong></li></ul><pre><code>cl_int clReleaseCommandQueue (cl_command_queue command_queue)</code></pre><blockquote><strong>参数说明：</strong>  <br />command_queue[IN] ：减少command_queue 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 5.1 节。</blockquote><ul><li><strong>clReleaseContext</strong></li></ul><pre><code>cl_int clReleaseContext (cl_context context)</code></pre><blockquote><strong>参数说明：</strong>  <br />context[IN] ：减少 context 的引用计数。  <br />Return ：正常执行返回 <code>CL_SUCCESS</code>，异常返回值参考[1]中 4.4 节。</blockquote><h3 id="item-2-3">2.3 API 使用注意事项</h3><p>OpenCL API 函数在 CPU 主机上执行，用于管理 OpenCL 资源和控制应用程序的执行。API 函数相较于设备内核代码，计算工作量更低，但不恰当地使用 API 函数可能带来很大的性能损失。开发人员可参考以下几点注意事项。</p><p>（1）内存资源的使用</p><ul><li>尽可能重用 OpenCL 内存和上下文对象，避免高开销的资源创建工作。</li><li>避免在 <code>clEnqueueNDRangeKernel</code> 之间创建或释放 OpenCL 内存对象。</li><li>由于主机和设备之间内存拷贝成本高昂，可以依据硬件厂商支持，采用不同的零拷贝机制。例如 Intel HD Graphics 使用 Map 取代 Copy，OpenCL2.0 支持的 SVM 内存，高通平台扩展的 ION 内存等等。</li></ul><p>（2）二进制程序加载</p><ul><li>运行时加载编译 OpenCL C 源代码极为耗时。首次使用 <code>clCreateProgramWithSource</code> 创建 program 并编译生成后，可保存设备的可执行二进制到文件。之后使用 <code>clCreateProgramWithBinary</code> 加载 program。下面是同一段 OpenCL C 代码使用源码加载编译和二进制加载编译的时间对比，可以看到程序加载时间显著降低。</li><li>编译好的二进制代码只适用于指定设备，如果设备加载了不匹配的二进制代码，应退回使用源码编译。</li></ul><pre><code># clCreateProgramWithSource and clBuildProgram
Source Compiling consumes average time: 41441 us
# clCreateProgramWithBinary and clBuildProgram
Binary Compiling consumes average time: 39 us</code></pre><p>（3）基于事件驱动(Event-driven)设备命令运行</p><ul><li>调用阻塞式 API 会<strong>挂起主机端 CPU 进程/线程</strong>，OpenCL 程序应尽可能避免阻塞式 API 调用。<br /><img referrerpolicy="no-referrer" src="/img/bVbouX" alt="image.png" title="image.png" /></li><li>OpenCL enqueue API 可以接收事件列表作为输入参数，列表中所有事件完成后，命令开始在设备端执行。使用事件列表建立命令之间的依赖关系，主机端只要将 <code>clEnqueue</code> 命令入队，交由设备按事件依赖执行，无需在主机端做阻塞式的同步操作。<br /><img referrerpolicy="no-referrer" src="/img/bVbouY" alt="image.png" title="image.png" /></li></ul><pre><code>// CL_FALSE表示 Non-blocking API，命令入队后立即返回
clEnqueueWriteBuffer(command_queue, buffer_src, CL_FALSE, 0, buffer_size_in_bytes,
                     host_src_matrix, 0, NULL, &amp;write_event);
// 命令依次入队，在Device端按照event依赖执行
clEnqueueNDRangeKernel(command_queue, native_kernel, 2, NULL, global_work_size, local_work_size, 1,
                       &amp;write_event, &amp;kernel_event);
clEnqueueReadBuffer(command_queue, buffer_dst, CL_FALSE, 0, buffer_size_in_bytes,
                    host_dst_matrix, 1, &amp;kernel_event, &amp;read_event);
/*CPU do something*/
// Sync between host and device
clWaitForEvents(1, &amp;read_event);</code></pre><h2 id="item-3">三、OpenCL图像转置示例</h2><h3 id="item-3-1">3.1 代码展示</h3><p>以 8 位灰度图像转置为例编写 CPU C 代码和 OpenCL 代码，压缩包下载链接参见附录。为简化图像格式操作，用cl_uchar 矩阵表示图像。CPU 代码采用行读列写的方式，</p><pre><code>void CpuTranspose(cl_uchar *src, cl_uchar *dst, int src_width, int src_height)
{
    for (int src_row = 0; src_row &lt; src_height; src_row++)
    {
        for (int src_col = 0; src_col &lt; src_width; src_col++)
        {
            //执行主体
            dst[src_col * src_height + src_row] = src[src_row * src_width + src_col];
        }
    }
}</code></pre><p>OpenCL C 源码的 kernel 函数只需要执行 CPU 循环的主体，每个工作项处理一个像素。</p><pre><code>__kernel void TransposeKernel(__global uchar *src, __global uchar *dst, int width, int height)
{
    uint g_idx = get_global_id(0);
    uint g_idy = get_global_id(1);
    if ((g_idx &gt;= width) || (g_idy &gt;= height))
        return;
    dst[g_idx * height + g_idy] = src[g_idy * width + g_idx];
}</code></pre><p>在 Host 端，使用本文介绍的 API，按步骤完成 OpenCL 设置，调用 <code>clEnqueueNDRangeKernel</code> 在设备端执行。</p><pre><code> cl_device_id device;
    cl_context context;
    cl_command_queue command_queue;
    cl_program program;
    cl_kernel kernel;
    cl_mem buffer_src;
    cl_mem buffer_dst;
    cl_int err_num = CL_SUCCESS;
    cl_uint buffer_size_in_bytes;
    timeval start;
    // Step 1-3 查询平台设备并创建context
    context = CreateContext(&amp;device);
    if (NULL == context)
    {
        printf("MainError:Create Context Failed!\n");
        return -1;
    }
    // Step 4 创建command queue
    command_queue = CreateCommandQueue(context, device);
    if (NULL == command_queue)
    {
        printf("MainError:Create CommandQueue Failed!\n");
        return -1;
    }
    // 读取OpenCL C源代码
    char *device_source_str = ClUtilReadFileToString("kerneltest.cl");
    program                 = CreateProgram(context, device, device_source_str);
    // Step 5 创建编译program
    if (NULL == program)
    {
        printf("MainError:Create CommandQueue Failed!\n");
        return -1;
    }
    // Step 6 创建编译kernel
    kernel = CreateKernel(program, "TransposeKernel", device);
    if (NULL == kernel)
    {
        printf("MainError:Create Kernel Failed!\n");
        return -1;
    }

    const int c_loop_count = 30;

    int width                          = 4096;
    int height                         = 4096;
    buffer_size_in_bytes               = width * height * sizeof(cl_uchar);
    cl_uchar *host_src_matrix          = (cl_uchar *)malloc(buffer_size_in_bytes);
    cl_uchar *host_transposed_matrix   = (cl_uchar *)malloc(buffer_size_in_bytes);
    cl_uchar *device_transposed_matrix = (cl_uchar *)malloc(buffer_size_in_bytes);
    memset(device_transposed_matrix, 0, buffer_size_in_bytes);
    DataInit(host_src_matrix, width, height);
    printf("Matrix Width =%d Height=%d\n", width, height);
    gettimeofday(&amp;start, NULL);
    for (int i = 0; i &lt; c_loop_count; i++)
    {
        CpuTranspose(host_src_matrix, host_transposed_matrix, width, height);
    }
    // 计算CPU多次运行的平均时间
    PrintDuration(&amp;start, "Cpu Transpose", c_loop_count);
    // Step 7 创建内存对象
    buffer_src = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                                buffer_size_in_bytes, host_src_matrix, &amp;err_num) 
    CheckClStatus(err_num, "Create src buffer");
    buffer_dst = clCreateBuffer(context, CL_MEM_WRITE_ONLY, buffer_size_in_bytes, NULL, &amp;err_num);
    CheckClStatus(err_num, "Create dst buffer");
    // Step 8 设置kernelArg
    err_num = clSetKernelArg(kernel, 0, sizeof(cl_mem), &amp;buffer_src);
    err_num |= clSetKernelArg(kernel, 1, sizeof(cl_mem), &amp;buffer_dst);
    err_num |= clSetKernelArg(kernel, 2, sizeof(int), &amp;width);
    err_num |= clSetKernelArg(kernel, 3, sizeof(int), &amp;height);

    size_t global_work_size[3];
    size_t local_work_size[3];
    // 设置NDRange尺寸
    local_work_size[0] = 32;
    local_work_size[1] = 32;
    local_work_size[2] = 0;
    
    global_work_size[0] =
        (width + local_work_size[0] - 1) / local_work_size[0] * local_work_size[0];
    global_work_size[1] =
        (height + local_work_size[1] - 1) / local_work_size[1] * local_work_size[1];
    global_work_size[2] = 0;

    printf("global_work_size=(%zu,%zu)\n", global_work_size[0], global_work_size[1]);
    printf("local_work_size=(%zu,%zu)\n", local_work_size[0], local_work_size[1]);
    cl_event kernel_event = NULL;
    gettimeofday(&amp;start, NULL);
    for (int i = 0; i &lt; c_loop_count; i++)
    {
        // Step 9 入队kernel执行
        err_num = clEnqueueNDRangeKernel(command_queue, kernel, 2, NULL, global_work_size,
                                         local_work_size, 0, NULL, &amp;kernel_event);
        CheckClStatus(err_num, "ClEnqueueNDRangeKernel");
        // Step 10 同步
        err_num = clWaitForEvents(1, &amp;kernel_event);
        CheckClStatus(err_num, "ClWaitForEvents");
    }
     // 计算GPU多次运行的平均时间
    PrintDuration(&amp;start, "OpenCL Transpose", c_loop_count);
    // Step 11 读取OpenCL计算结果
    err_num = clEnqueueReadBuffer(command_queue, buffer_dst, CL_TRUE, 0, buffer_size_in_bytes,
                                  device_transposed_matrix, 0, NULL, NULL);

    compare(host_transposed_matrix, device_transposed_matrix, width, height);

    free(device_source_str);
    free(host_src_matrix);
    free(host_transposed_matrix);
    free(device_transposed_matrix);
    // Step 12 清理OpenCL资源
    clReleaseEvent(kernel_event);
    clReleaseMemObject(buffer_src);
    clReleaseMemObject(buffer_dst);

    CleanUp(context, command_queue, program, kernel);</code></pre><h3 id="item-3-2">3.2 运行结果</h3><p>在高通 865 平台，对 4096x4096 图像做转置，运行结果如下，CPU 运行时间除以 OpenCL 运行时间作为加速比，约 10.1 倍。</p><pre><code>Cpu Transpose consume average time: 135815 us
Kernel TransposeKernel max workgroup size=1024
Kernel TransposeKernel perferred workgroup size multiple=128
global_work_size=(4096,4096)
local_work_size=(32,32)
OpenCL Transpose consume average time: 13412 us
A and B match!</code></pre><p>使用不同尺寸图像计算 OpenCL 转置加速比。随着数据量上升，OpenCL 相较于 CPU 加速优势显著。<br /><img referrerpolicy="no-referrer" src="/img/bVbouZ" alt="image.png" title="image.png" /></p><h3 id="item-3-3">3.3 说明</h3><p>本节 OpenCL 转置示例仅为展示 OpenCL 运行时 API 的使用，程序可以深度优化并得到数倍的性能提升。优化措施包括且不限于：<br /><img referrerpolicy="no-referrer" src="/img/bVbou0" alt="image.png" title="image.png" /></p><h2 id="item-4">四、总结</h2><p>本文首先给出 OpenCL 运行时 API 的整体编程流程图，然后针对每一步介绍使用的运行时 API，讲解 API 参数，并给出编程运行实例。总结运行时 API 使用的注意事项。最后展示基于 OpenCL 的图像转置代码。在 865 平台下，对于 4096x4096 的 8 位图像加速比达到 10 倍以上。</p><h2 id="item-5">五、工程代码</h2><p><a href="/link?target=https%3A%2F%2Fgithub.com%2Fmobile-algorithm-optimization%2Fguide%2Ftree%2Fmain%2FOpenCLTranspose" target="blank">https://github.com/mobile-algorithm-optimization/guide/tree/main/OpenCLTranspose</a></p><p><strong>参考资料</strong></p><p>[1] <a href="/link?target=https%3A%2F%2Fwww.khronos.org%2Fregistry%2FOpenCL%2Fspecs%2Fopencl-2.0.pdf" target="blank">https://www.khronos.org/registry/OpenCL/specs/opencl-2.0.pdf</a><br />[2] Qualcomm snapdragon mobile platform opencl general programming and optimization<br />[3] OpenCL 异构并行计算<br />[4] Heterogeneous Computing with OpenCL 2.0<br />[5] <a href="/link?target=https%3A%2F%2Fwww.khronos.org%2Fregistry%2FOpenCL%2Fsdk%2F2.1%2Fdocs%2Fman%2Fxhtml%2F" target="blank">https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/</a><br />[6] OpenCL in Action</p><p><strong>推荐阅读</strong></p><ul><li><a href="https://aijishu.com/a/1060000000292869"><strong>GPU 优化技术-OpenCL 介绍</strong></a></li><li><a href="https://aijishu.com/a/1060000000276738"><strong>CPU 优化技术-NEON 自动向量化</strong></a></li><li><a href="https://aijishu.com/a/1060000000273042"><strong>CPU 优化技术-NEON 指令介绍</strong></a></li></ul><blockquote>更多嵌入式AI技术相关内容请关注<a href="https://aijishu.com/blog/embeddedai"><strong>嵌入式AI</strong></a>专栏。</blockquote>

                                                    </article>


                        <div class="handle-bar text-secondary d-flex align-items-center justify-content-between mt-4">
                            <div>
                                <a id="article-like-bottom-btn" data-icon-count="" data-toggle-button-api="/api/article/1060000000293412/vote/up" data-count-sel="[data-icon-count-size]" data-link-sel="#article-like-side-btn" data-toggle-style="link" data-state="false" class="mr-3" href="javascript:;">
                                    <i class="far fa-thumbs-up mr-2"></i>
                                    <span data-icon-count-size="" data-count-hidden="true">3</span>
                                </a>
                                <span>阅读
									791</span>
                                                            </div>
                            <div>
                                <a id="article-bookmark-bottom-btn" data-icon-count="" data-toggle-button-api="/api/article/1060000000293412/bookmark" data-count-sel="[data-bookmark-count-size]" data-link-sel="#article-bookmark-side-btn" data-toggle-style="link" data-state="false" class="ml-3" href="javascript:;">
                                    <i class="far fa-bookmark mr-2"></i>
                                    <span data-bookmark-count-size="" data-count-hidden="true" class="d-none">0</span>
                                </a>

                                <div class="dropdown ml-3 d-inline" data-qr-direct="left" data-share-title="%E6%88%91%E5%9C%A8+%40%E6%9E%81%E6%9C%AF%E7%A4%BE%E5%8C%BA+%E4%B8%8A%E5%8F%91%E7%8E%B0%E4%BA%86%E3%80%8AGPU+%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF-OpenCL+%E8%BF%90%E8%A1%8C%E6%97%B6+API+%E4%BB%8B%E7%BB%8D%E3%80%8B%EF%BC%8C%E5%BF%AB%E6%9D%A5%E7%9C%8B%E7%9C%8B%E5%90%A7" data-share-url="/a/1060000000293412"><a href="#" role="button" id="share-8764026" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
        <i class="far fa-share-alt"></i>
      </a>

      <div class="dropdown-menu" aria-labelledby="share-8764026">
        <a class="dropdown-item share-link" data-clipboard-text="https://aijishu.com/a/1060000000293412" href="javascript:;"><i class="far fa-link mr-2 text-secondary"></i>复制链接</a>
        <a class="dropdown-item share-weibo" href="javascript:;"><i class="fab fa-weibo mr-2 text-danger"></i>新浪微博</a>
        <a class="dropdown-item share-weixin" href="javascript:;" data-original-title="" title=""><i class="fab fa-weixin mr-2 text-success"></i>微信扫一扫</a>
      </div></div>

                                <div class="dropdown ml-3 d-inline">
                                    <a class="" href="#" role="button" id="dropdownMenuLink" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                        <i class="far fa-ellipsis-h"></i>
                                    </a>

                                    <div class="dropdown-menu dropdown-menu-right" aria-labelledby="dropdownMenuLink">
                                                                                <a class="dropdown-item" data-report="1060000000293412" data-report-type="article" href="#">举报</a>

                                        
                                                                            </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                                                    <h5 class="mt-4">推荐阅读</h5>
                    <div class="card border-0 mb-4">
                        <div class="list-group list-group-flush">
                                        <a href="/a/1060000000001088" class="list-group-item list-group-item-action">
            什么是嵌入式系统（上）
                            <span class="ml-1 text-primary d-inline-block">
					<i class="mr-2 far fa-comment-alt-lines"></i>
					2</span>
                    </a>
            <a href="/a/1060000000003304" class="list-group-item list-group-item-action">
            什么是嵌入式系统（中）
                    </a>
            <a href="/a/1060000000235232" class="list-group-item list-group-item-action">
            免费好课|国家精品MOOC课程《嵌入式系统与应用》，嵌入式系统理论及实践入门及强化必选课程
                    </a>
            <a href="/a/1060000000271148" class="list-group-item list-group-item-action">
            AI嵌入式学习必备参考书:《AI嵌入式系统: 算法优化与实现》
                    </a>
            <a href="/a/1060000000291251" class="list-group-item list-group-item-action">
            读《AI嵌入式系统》，看AI大规模商业落地的未来
                    </a>
            <a href="/a/1060000000101782" class="list-group-item list-group-item-action">
            快速嵌入式系统设计-基于ST Nucleo-F401RE平台
                    </a>
    
                        </div>
                    </div>
                
                <h5 class="mt-4">0
                    条评论</h5>

                <div class="card border-0 mb-4">
                    <div class="card-body">
                        <div class="media mb-4">
                            <img class="d-block rounded-circle mr-3" width="38" src="https://cdn-assets.aijishu.com/v-3f2b4b21/public/avatar/user.svg" aria-hidden="true" onerror="imgError(this);" />
                            <form class="media-body article-comment-form" action="/api/comment/add">
                                <div class="form-group">
                                    <div class="form-control comment-text" style="height: auto;" contenteditable="true" name="text"></div>
                                </div>
                                <div class="d-flex justify-content-end">
                                    <button data-js-replay-submit-btn="" type="submit" class="btn btn-primary float-right">
                                        提交
                                    </button>
                                    <input type="hidden" name="objectId" value="1060000000293412" autocomplete="off" />
                                </div>
                            </form>
                        </div>

                        <div id="blogArticleCommentStream" data-js-stream-list="" data-next-page="1">
                            <div data-js-stream-load-more="" data-api-url="/api/comment/list/1060000000293412" class="text-center">
                                <div data-js-stream-loading="" class="ent-home-loading spinner-border spinner-border-sm text-secondary" role="status" hidden="">
                                    <span class="sr-only">Loading...</span>
                                </div>
                                <div data-js-stream-reload="" class="ent-home-reload" hidden="">
                                    <i class="far fa-redo-alt text-secondary"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                            </div>

            <div class="col-lg-3">
                <div class="mb-4">
                    <div>
                                                        <div class="card mb-4 border-0">
        <div class="card-body">
            <div class="media align-items-center mb-3">
                <img src="https://cdn-avatar.aijishu.com/858/509/858509858-5e4e4063e8403_36" width="48" class="rounded align-self-center mr-2" aria-hidden="true" onerror="imgError(this);" />
                <div class="media-body">
                    <a class="text-body h5" href="/blog/embeddedai">嵌入式AI</a>
                </div>
            </div>
            <div class="d-flex mb-2">
                <div class="mr-5">
                    <div class="text-secondary">关注数</div>
                    <div class="h5" id="blog-followers-count">14538</div>
                </div>
                <div>
                    <div class="text-secondary">内容数</div>
                    <div class="h5">690</div>
                </div>
            </div>
            <div class="mb-3 text-secondary">
                嵌入式端AI，包括AI算法在推理框架Tengine，MNN,NCNN，PaddlePaddle及相关芯片上的实现。欢迎加入微信交流群，微信号：aijishu20（备注：嵌入式）
            </div>
            <div class="d-flex">
                <a data-toggle-button-api="/api/blog/1070000000092053/follow" data-on-text="已关注" data-off-text="关注专栏" data-count-sel="#blog-followers-count" data-state="false" class="btn btn-primary btn-sm mr-2" href="javascript:;">关注专栏</a>
                <a class="btn btn-outline-primary btn-sm" href="/blog/embeddedai">专栏主页</a>
            </div>
        </div>
    </div>

                        
                        <div class="card border-0 mb-4 overflow-hidden" data-article-nav="" style="width: 255px;">
                            <div class="card-body d-none d-lg-block">
                                <h6 class="pt-3 position-relative bg-white" style="margin-top:-1.25rem; height:45px">
                                    目录</h6>
                                <nav data-article-nav-list="" class="font-size-14"><a class="nav-link pl-3 text-secondary py-1" href="#item-1" data-offsettop="0">一、概述</a><a class="nav-link pl-3 text-secondary py-1" href="#item-2" data-offsettop="0">二、OpenCL 运行时 API 的编程流程</a><nav class="pl-3">
        <a class="nav-link text-secondary my-1  py-0" href="#item-2-1" data-offsettop="0">2.1 OpenCL Host 端编程全流程</a>
      <a class="nav-link text-secondary my-1 py-0" href="#item-2-2" data-offsettop="0">2.2 OpenCL Host端编程分步详解</a><a class="nav-link text-secondary my-1 py-0" href="#item-2-3" data-offsettop="0">2.3 API 使用注意事项</a></nav><a class="nav-link pl-3 text-secondary py-1" href="#item-3" data-offsettop="0">三、OpenCL图像转置示例</a><nav class="pl-3">
        <a class="nav-link text-secondary my-1  py-0" href="#item-3-1" data-offsettop="0">3.1 代码展示</a>
      <a class="nav-link text-secondary my-1 py-0" href="#item-3-2" data-offsettop="0">3.2 运行结果</a><a class="nav-link text-secondary my-1 py-0" href="#item-3-3" data-offsettop="0">3.3 说明</a></nav><a class="nav-link pl-3 text-secondary py-1" href="#item-4" data-offsettop="0">四、总结</a><a class="nav-link pl-3 text-secondary py-1" href="#item-5" data-offsettop="0">五、工程代码</a></nav>
                            </div>
                        </div>

                        
<div class="mb-4" id="qr_code">
    <div class="card border-0">
        <div class="card-body py-3">
            <div class="d-flex align-items-center">
                <div class="mr-1 wechat-qrcode-jishu">
                    <img width="98" class="wechat-qrcode ml-n1" src="https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQE88DwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyRjNldThJUDlkM2wxdUl0SXh5YzYAAgSsUEViAwQAjScA" alt="极术微信服务号" />
                </div>
                <div class="font-size-14">
                    <strong>关注极术微信号</strong><br />
                    <span class="text-secondary">实时接收点赞提醒和评论通知</span>
                </div>
            </div>
            <div class="d-flex align-items-center">
                <div class="mr-1">
                    <img width="98" class="wechat-qrcode ml-n1" src="https://cdn-assets.aijishu.com/v-3f2b4b21/public/qr-code/arm-school.png" alt="安谋科技学堂公众号" />
                </div>
                <div class="font-size-14">
                    <strong>关注安谋科技学堂</strong><br />
                    <span class="text-secondary">实时获取安谋科技及 Arm 教学资源</span>
                </div>
            </div>
            <div class="d-flex align-items-center">
                <div class="mr-1">
                    <img width="98" class="wechat-qrcode ml-n1" src="https://cdn-assets.aijishu.com/v-3f2b4b21/public/qr-code/arm-jobs.png" alt="安谋科技招聘公众号" />
                </div>
                <div class="font-size-14">
                    <strong>关注安谋科技招聘</strong><br />
                    <span class="text-secondary">实时获取安谋科技中国职位信息</span>
                </div>
            </div>
        </div>
    </div>
</div>

<ul class="mb-4 font-size-14 text-secondary list-unstyled">
    <li class="my-2">
        <a class="text-secondary" href="/help">用户指南</a> ·
        <a class="text-secondary" href="/tos">用户协议</a> ·
        <a class="text-secondary" href="/privacy">隐私政策</a>
    </li>
    <li class="my-2">
        <a class="text-secondary" href="/about">关于我们</a> ·
        <a class="text-secondary" href="mailto:corp@aijishu.com" target="_blank">联系合作</a>
        
    </li>
    <li class="my-2">
        <a class="text-secondary" href="http://beian.miit.gov.cn" target="_blank">粤ICP备18004469号</a>
    </li>
    <li class="my-2">
        <a class="text-secondary" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030502008014" target="_blank">粤公网安备 44030502008014号</a>
    </li>
    <li class="my-2">
        版权所有 © 2022 极术社区
    </li>
    <li class="my-2">
        由 <a class="text-secondary" href="//segmentfault.com" target="_blank">SegmentFault</a> 提供技术支持
    </li>
    <li><hr /><a class="text-secondary" href="/links">友情链接</a></li>
    <li>    
            <ul class="list-inline">
                                                <li class="list-inline-item mt-2">
                        <a href="https://www.armchina.com" target="_blank" class="text-secondary">安谋科技</a>
                    </li>
                                                                                            <li class="list-inline-item mt-2">
                        <a href="http://www.armaccelerator.com" target="_blank" class="text-secondary">安创空间</a>
                    </li>
                                                                                                                                                    <li class="list-inline-item mt-2">
                        <a href="https://www.oschina.net" target="_blank" class="text-secondary">开源中国</a>
                    </li>
                                                                                                                                                                                <li class="list-inline-item mt-2">
                        <a href="http://byjs.com.cn" target="_blank" class="text-secondary">边缘计算社区</a>
                    </li>
                                                                                                                                                    <li class="list-inline-item mt-2">
                        <a href="https://www.21ic.com" target="_blank" class="text-secondary">21IC 电子网</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="https://harmonyos.51cto.com" target="_blank" class="text-secondary">HarmonyOS 技术社区</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="https://www.icxbk.com/" target="_blank" class="text-secondary">电子芯吧客</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="https://www.csdn.net/" target="_blank" class="text-secondary">CSDN</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="http://www.aw-ol.com/" target="_blank" class="text-secondary">全志在线</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="https://mangopi.org/" target="_blank" class="text-secondary">芒果派</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="http://deeprl.neurondance.com/" target="_blank" class="text-secondary">深度强化学习实验室</a>
                    </li>
                                                                <li class="list-inline-item mt-2">
                        <a href="https://www.livevideostack.cn/" target="_blank" class="text-secondary">LiveVideoStake</a>
                    </li>
                                    </ul>
    
    </li>
</ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    (function (w) {
        w.GLOBAL = {
            staticUrl: "https://cdn-assets.aijishu.com/v-3f2b4b21/",
            wxLogin: "https://open.weixin.qq.com/connect/qrconnect?appid=wx28bb22f416bf4d6b&amp;redirect_uri=https%3A%2F%2Faijishu.com%2Fuser%2Foauth%2Fwechat&amp;scope=snsapi_login&amp;self_redirect=false&amp;login_type=jssdk&amp;style=dark&amp;https://cdn-assets.aijishu.com/v-3f2b4b21/public/wx-qrcode.css",
            wxLoginParams: {"id":"wx-login-qrcode","appid":"wx28bb22f416bf4d6b","scope":"snsapi_login","redirect_uri":"https%3A%2F%2Faijishu.com%2Fuser%2Foauth%2Fwechat","state":"","style":"dark","href":"https:\/\/cdn-assets.aijishu.com\/v-3f2b4b21\/public\/wx-qrcode.css"},
            hasLogin: false,
            hasActivated: false,
            pageName: "detail",
            actionBase: location.protocol + "//" + location.host,
            allowedPrivacy:true
        };
        w.GLOBAL.token = (function () {
    var _nQL9a = //'nZo'
'629'+//'UDM'
'1a'+//'o'
'5'+//'oeq'
'10'+'135'//'cH'
+//'f'
'f'+'8'//'n'
+'dd'//'ZN'
+//'e'
'e'+//'1'
'1'+'715'//'kl'
+'917'//'ICz'
+'b'//'2V'
+'0a'//'UDB'
+'61'//'z5'
+'3eb'//'G'
+//'ma'
'1'+//'As'
'5'+//'G'
'G'+//'h'
'h'+'f'//'V7'
, _eSxw5mh = [[11,12],[14,15],[31,32],[31,32]];

    for (var i = 0; i &lt; _eSxw5mh.length; i ++) {
        _nQL9a = _nQL9a.substring(0, _eSxw5mh[i][0]) + _nQL9a.substring(_eSxw5mh[i][1]);
    }

    return _nQL9a;
})();;
    })(window);
</script>
<script src="//res.wx.qq.com/connect/zh_CN/htmledition/js/wxLogin.js"></script>
<script src="https://cdn-assets.aijishu.com/v-3f2b4b21/global/index.js"></script>

    <script src="https://cdn-assets.aijishu.com/v-3f2b4b21/article/index.js"></script>

    <script type="text/javascript">
        // 文章详情页，往下滑动时，右侧目录保持在视野内
        var articleIndex = $("[data-article-nav]");
        var blogId = "1070000000092053";
        var articleIndexPrimaryTop = articleIndex.offset().top;
        $(document).on("scroll", function () {
            var scrollHeight = $(this).scrollTop();
            scrollHeight &gt; articleIndexPrimaryTop
                ? articleIndex.addClass("sticky-top").css("position", "fixed")
                : articleIndex.removeClass("sticky-top").css("position", "relative");
        });
    </script>

<script src="https://res.wx.qq.com/open/js/jweixin-1.6.0.js"></script>
<script>
    var signPackage = {"appId":"wx233d8320263618de","nonceStr":"5bNEgggMqDQKGtfF","timestamp":1651151910,"url":"https:\/\/aijishu.com\/a\/1060000000293412","signature":"5f617909f2e63ac3538af1cf63ffaca8ff20bca0","rawString":"jsapi_ticket=HoagFKDcsGMVCIY2vOjf9q-Q8WQqOlb4LVKDz-fTChmogyCOZn2e7dlZnrSVOl97PtSpmUSsJv8YnMYwiL_Duw&amp;noncestr=5bNEgggMqDQKGtfF&amp;timestamp=1651151910&amp;url=https:\/\/aijishu.com\/a\/1060000000293412"};
    if (signPackage) {
        wx.config({
            debug: false,
            appId: signPackage.appId,
            timestamp: signPackage.timestamp,
            nonceStr: signPackage.nonceStr,
            signature: signPackage.signature,
            jsApiList: [
                'onMenuShareTimeline',
                'onMenuShareAppMessage',
                'onMenuShareQQ',
                'showAllNonBaseMenuItem',
            ]
        });
    }
</script>
<script type="text/javascript">
    $(document).ready(function () {
        // 在这里调用 API
        var shareConfig = {
            title: 'GPU 优化技术-OpenCL 运行时 API 介绍',
            desc: "OpenCL 作为一套通用异构平台编程框架，由两个部分组成：其一是在主机处理器（Host）执行的运行时 API；其二是基于 C99 标准扩展的 OpenCL C 语言，用于编写在设备处理器（OpenCL device）运行的内核（kernel）代码。",
            imgUrl: "https://cdn-assets.aijishu.com/v-3f2b4b21/public/favicons/wechat-share-icon.png",
            success: function () {
            },
            cancel: function () {
            },
        };
        wx.ready(function () {
            wx.updateAppMessageShareData(shareConfig);
            wx.updateTimelineShareData(shareConfig);
            // wx.onMenuShareTimeline(shareConfig);
            // wx.onMenuShareAppMessage(shareConfig);
            // wx.onMenuShareQQ(shareConfig);
            // wx.onMenuShareQZone(shareConfig);
        });
    });
</script>



  <div class="is-active ImageView p-4" style="display: none;">
      <div class="ImageView-inner" style="overflow: auto;">
          <img src="" class="ImageView-img" alt="preview" style="max-width: 100%" />
      </div>
  </div></body></html>
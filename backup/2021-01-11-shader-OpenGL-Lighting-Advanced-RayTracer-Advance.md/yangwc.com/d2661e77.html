---
title : 自动快照存档
---

* TIME: 2023-08-01 14:23:59
* URL: <https://yangwc.com/2019/05/23/RayTracer-Advance/>

-----

[ YangWC's Blog ](/)

  * [ __个人](/about/)
  * [ __博客](/)
  * [ __归档](/archives/)
  * [ __分类](/categories/)
  * [ __标签](/tags/)

__

  * [](javascript:void\(0\))
  * [](javascript:void\(0\))

光线追踪器Ray Tracer：进阶篇

  * [](javascript:void\(0\))
  * [](javascript:void\(0\))

  * [ __个人](/about/)
  * [ __博客](/)
  * [ __归档](/archives/)
  * [ __分类](/categories/)
  * [ __标签](/tags/)

#  [ 光线追踪器Ray Tracer：进阶篇 ](/2019/05/23/RayTracer-Advance/)

[ ![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg)

WC Yang

](https://yangwc.com)

__

2019-05-23

[ __

Computer Graphics / Ray Tracer

](/categories/Ray-Tracer/)

__

117710

* * *

本篇文章在前面的基础上，丰富光线追踪器的各种特性。本篇内容主要包含添加纹理映射、平面光源和球形光源、三角网格模型渲染、增加天空盒背景、构建BVH树、tbb多线程渲染加速、蒙特卡罗积分方法、重要性采样，后面部分涉及的高等数学和概率论内容较多。相关的全部代码在[这里](https://github.com/ZeusYang/Ray-
Tracer/releases/tag/1.1.0)。

![header](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/header.png)

  * 纹理映射
  * 三角网格模型
  * 添加光源
  * 天空盒背景
  * 构建BVH树
  * tbb多线程渲染
  * 蒙特卡罗积分
  * 重要性采样
  * MC光线追踪
  * 程序效果
  * 参考资料

# 一、纹理映射

纹理映射对渲染的重要性不言而喻，为了丰富物体表面的细节，我们在这里创建一个纹理加载和采样的类。实际上，除了图片纹理，还有一些过程式产生的纹理。我们创建一个虚类TextureTexture，并将samplesample类作为虚接口。然后创建子类ImageTextureImageTexture，图片的加载我采用了stb_image库。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    44  
    45  
    46  
    47  
    48  
    

|  __复制

    
    
     class Texture  
    {  
    public:  
        typedef std::shared_ptr<Texture> ptr;  
          
        Texture() = default;  
        virtual ~Texture() = default;  
        virtual Vector3D sample(const float &u, const float &v, const Vector3D &p) const = 0;  
    };  
      
    class ImageTexture : public Texture  
    {  
    private:  
        unsigned char *m_data;  
        int m_width, m_height, m_channel;  
          
    public:  
        typedef std::shared_ptr<ImageTexture> ptr;  
          
        ImageTexture() = default;  
        ImageTexture(const std::string &path);  
        virtual ~ImageTexture();  
          
        virtual Vector3D sample(const float &u, const float &v, const Vector3D &p) const;  
          
    };  
      
    ImageTexture::ImageTexture(const std::string &path)  
    {  
        m_data = stbi_load(path.c_str(), &m_width, &m_height, &m_channel, 0);  
        if (m_data == nullptr)  
            std::cout << "Failed to load the image->" << path.c_str() << std::endl;  
    }  
      
    Vector3D ImageTexture::sample(const float &u, const float &v, const Vector3D &p) const  
    {  
        int i = static_cast<int>(u * m_width);  
        int j = static_cast<int>((1.0f - v)*m_height) - 0.001;  
        if (i < 0) i = 0;  
        if (j < 0) j = 0;  
        if (i > m_width - 1) i = m_width - 1;  
        if (j > m_height - 1) j = m_height - 1;  
        int index = (j * m_width + i) * m_channel;  
        float r = static_cast<int>(m_data[index + 0]) / 255.0f;  
        float g = static_cast<int>(m_data[index + 1]) / 255.0f;  
        float b = static_cast<int>(m_data[index + 2]) / 255.0f;  
        return Vector3D(r, g, b);  
    }  
      
  
---|---  
  
纹理坐标转换为像素数组下标要注意是否越界了，这里实现的纹理环绕方式是clamp。然后对于球体，我们要计算球体上每个点的纹理坐标，这里采用球面坐标的一个技巧。球体的上每一个点，都对应着一组唯一的方向角和天顶角(θ,ϕ)(θ,ϕ)，我们把(θ,ϕ)(θ,ϕ)映射到二维纹理坐标即可。映射方法如下：

u=ϕ/(2π)v=θ/π(1)(1)u=ϕ/(2π)v=θ/π

那么如何根据一个球面的点计算它的方向角和天顶角呢？从球面坐标(θ,ϕ)(θ,ϕ)转到笛卡尔坐标(x,y,z)(x,y,z)，不难理解，有如下关系：

x=cos(ϕ)cos(θ)y=sin(ϕ)cos(θ)z=sin(θ)(2)(2)x=cos(ϕ)cos(θ)y=sin(ϕ)cos(θ)z=sin(θ)

注意到y/x=tan(ϕ)y/x=tan(ϕ)，所以我们可以采用下面的方式得到球面上点的天顶角和方位角：

ϕ=atan2(y,x)θ=asin(2)(3)(3)ϕ=atan2(y,x)θ=asin(2)

需要注意的是，atan2atan2函数返回的角度范围是[−π,+π][−π,+π]，asinasin返回的角度范围是[−π/2,π/2][−π/2,π/2]。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    

|  __复制

    
    
     static void getSphereUV(const Vector3D &p, Vector2D &tex)  
    {  
        float phi = atan2(p.z, p.x);  
        float theta = asin(p.y);  
        tex.x = 1 - (phi + M_PI) / (2*M_PI);  
        tex.y = (theta + M_PI/2) / M_PI;  
    }  
      
  
---|---  
  
# 二、三角网格模型

除了像球体、圆柱、圆锥等等这类有显示数学表达式的几何体，我们接触到更多的是没有表达式的网格模型。有显示的数学表达式当然好，因为我们直接直接求交点的解析解，非常准确。这里我们构建一个通用的网格模型类，它由一个个三角形构成。obj模型的导入我不再赘述，这里重点讲述了射线与三角形求交的推导过程。

一个三角形由空间中的三个顶点P0P0、P1P1、P2P2的位置表示，三角形所在平面的法向量NN可由下式计算而得：

N=(P1−P0)×(P2−P0)(4)(4)N=(P1−P0)×(P2−P0)

平面与原点的距离dd等于平面法向量NN与平面中任意一点的内积的负数，这里选P0P0，则dd为：

d=−N⋅P0(5)(5)d=−N⋅P0

则三角形所在的平面可以用四维向量(N,−N⋅P0)(N,−N⋅P0)表示，实际上三角形所在平面的表达式为N⋅(x,y,z)+d=0N⋅(x,y,z)+d=0，首先我们求射线与该平面的交点，然后再判断交点是否在三角形内部。将射线方程P(t)=S+tVP(t)=S+tV带入平面的方程，则有：

N⋅P(t)+d=0→N⋅S+(N⋅V)t+d=0→t=−(N⋅S+d)N⋅VN⋅P(t)+d=0→N⋅S+(N⋅V)t+d=0→t=−(N⋅S+d)N⋅V

通过以上的方程我们就可以得到射线在平面LL上的交点处的tt值。 **需要注意的是，当
N⋅V=0N⋅V=0时，射线与平面平行，不存在交点。**然后我们把tt值带入射线方程即可求出射线与平面的交点PP。接下来的问题是判断点PP是否位于三角形内部，通过计算点PP对于三角形的三个顶点P0P0、P1P1、P2P2的重心坐标可以完成该判断。重心坐标是三角形顶点加权平均值，由三个标量ω0ω0、ω1ω1和ω2ω2组成，有：

P=ω0P0+ω1P1+ω2P2(6)(6)P=ω0P0+ω1P1+ω2P2

其中，ω0+ω1+ω2=1ω0+ω1+ω2=1，用1−ω1−ω21−ω1−ω2代替ω0ω0，可得：

P=(1−ω1−ω2)P0+ω1P1+ω2P2=P0+ω1(P1−P0)+ω2(P2−P0)(7)(7)P=(1−ω1−ω2)P0+ω1P1+ω2P2=P0+ω1(P1−P0)+ω2(P2−P0)

定义以下的等式：

R=P−P0Q1=P1−P0Q2=P2−P0(8)(8)R=P−P0Q1=P1−P0Q2=P2−P0

将公式(9)(9)带入公式(8)(8)，可得：

R=ω1Q1+ω2Q2(9)(9)R=ω1Q1+ω2Q2

分别给式(10)(10)两边乘Q1Q1和Q2Q2可得以下两个方程：

R⋅Q1=ω1Q21+ω2(Q1⋅Q2)R⋅Q2=ω1(Q1⋅Q2)+ω2Q22(10)(10)R⋅Q1=ω1Q12+ω2(Q1⋅Q2)R⋅Q2=ω1(Q1⋅Q2)+ω2Q22

写成矩阵形式如下：

[Q21Q1⋅Q2Q1⋅Q2Q22][ω1ω2]=[R⋅Q1R⋅Q2](11)(11)[Q12Q1⋅Q2Q1⋅Q2Q22][ω1ω2]=[R⋅Q1R⋅Q2]

解以上关于ω1ω1和ω2ω2的方程，可得：

[ω1ω2]=[Q21Q1⋅Q2Q1⋅Q2Q22]−1[R⋅Q1R⋅Q2]=1Q21Q22−(Q1⋅Q2)2[Q22−Q1⋅Q2−Q1⋅Q2Q21][R⋅Q1R⋅Q2](12)(12)[ω1ω2]=[Q12Q1⋅Q2Q1⋅Q2Q22]−1[R⋅Q1R⋅Q2]=1Q12Q22−(Q1⋅Q2)2[Q22−Q1⋅Q2−Q1⋅Q2Q12][R⋅Q1R⋅Q2]

**当且仅当
ω0ω0、ω1ω1和ω2ω2三个权值均为非负值时，点RR位于三角形内部，由于ω0=1−ω1−ω2ω0=1−ω1−ω2，则此时应有ω1+ω2≤1ω1+ω2≤1且ω1≥0
and ω2≥0ω1≥0 and
ω2≥0。**若顶点P0P0、P1P1和P2P2上关联有一些属性信息，如颜色、法向量或者纹理坐标，则可以利用权值ω0ω0、ω1ω1和ω2ω2对这些属性信息进行插值。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    

|  __复制

    
    
     bool MeshHitable::triangleHit(const Ray &ray, const float &t_min, const float &t_max,  
        HitRecord &ret, const Vertex &p0, const Vertex &p1,  
        const Vertex &p2, const Vector3D &normal) const  
    {  
        float n_dot_dir = normal.dotProduct(ray.getDirection());  
        // no intersection.  
        if (equal(n_dot_dir, 0.0))  
            return false;  
        float d = -normal.dotProduct(p0.m_position);  
        float t = -(normal.dotProduct(ray.getOrigin()) + d) / n_dot_dir;  
        if (t < t_min || t > t_max)  
            return false;  
        ret.m_t = t;  
        ret.m_position = ray.pointAt(t);  
        ret.m_material = m_material;  
        // judge inside or not.  
        Vector3D r = ret.m_position - p0.m_position;  
        Vector3D q1 = p1.m_position - p0.m_position;  
        Vector3D q2 = p2.m_position - p0.m_position;  
        float q1_squaredLen = q1.getSquaredLength();  
        float q2_squaredLen = q2.getSquaredLength();  
        float q1_dot_q2 = q1.dotProduct(q2);  
        float r_dot_q1 = r.dotProduct(q1);  
        float r_dot_q2 = r.dotProduct(q2);  
        float determinant = 1.0f / (q1_squaredLen * q2_squaredLen - q1_dot_q2 * q1_dot_q2);  
      
        float omega1 = determinant * (q2_squaredLen * r_dot_q1 - q1_dot_q2 * r_dot_q2);  
        float omega2 = determinant * (-q1_dot_q2 * r_dot_q1 + q1_squaredLen * r_dot_q2);  
        if (omega1 + omega2 > 1.0f || omega1 < 0.0f || omega2 < 0.0f)  
            return false;  
        ret.m_normal = p0.m_normal * (1.0f - omega1 - omega2) + p1.m_normal * omega1 + p2.m_normal * omega2;  
        ret.m_texcoord = p0.m_texcoord * (1.0f - omega1 - omega2) + p1.m_texcoord * omega1 + p2.m_texcoord * omega2;  
        if (ret.m_normal.dotProduct(ray.getDirection()) > 0.0f)  
            ret.m_normal = -ret.m_normal;  
        return true;  
    }  
      
  
---|---  
  
既然模型是由一个个三角形组成，那么在判断射线与当前的模型是否存在交点时，我们就遍历所有的三角形，一个一个三角形与射线做相交判断：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    

|  __复制

    
    
     bool MeshHitable::hit(const Ray &ray, const float &t_min, const float &t_max, HitRecord &ret) const  
    {  
        HitRecord tmpRec;  
        bool hitAny = false;  
        float closestSoFar = t_max;  
        for (int x = 0; x < m_indices.size(); x += 3)  
        {  
            int index1 = m_indices[x + 0];  
            int index2 = m_indices[x + 1];  
            int index3 = m_indices[x + 2];  
            if (triangleHit(ray, t_min, closestSoFar, tmpRec,  
                m_vertices[index1],  
                m_vertices[index2],  
                m_vertices[index3],  
                m_faceNormal[x / 3]))  
            {  
                hitAny = true;  
                closestSoFar = tmpRec.m_t;  
                ret = tmpRec;  
            }  
        }  
        return hitAny;  
    }  
      
  
---|---  
  
# 三、添加光源

光源是一种特殊的物体，一般情况下它不反射、折射光线，而是自身发射光线。因此，为了实现一个光源，当我们的射线碰撞到光源表面时，我们直接返回光源的碰撞点的颜色，不再做折射和反射。我们将发光的逻辑放到材质中，并将发光这一行为抽象为emittedemitted函数。对于非光源物体，我们可以看成发出的光rgb均为0。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    

|  __复制

    
    
     class Material  
    {  
    public:  
        typedef std::shared_ptr<Material> ptr;  
          
        Material() = default;  
        virtual ~Material() = default;  
          
        virtual bool scatter(const Ray &in, const HitRecord &rec, ScatterRecord &srec) const  
        { return false; }  
          
        virtual float scattering_pdf(const Ray &in, const HitRecord &rec,  
                                     const Ray &scattered) const  
        { return 1.0f; }  
          
        virtual Vector3D emitted(const Ray &in, const HitRecord &rec, const float &u,  
                                 const float &v, const Vector3D &p) const  
        { return Vector3D(0.0f, 0.0f, 0.0f); }  
    };  
      
    class DiffuseLight : public Material  
    {  
    private:  
        unsigned int m_emitTex;  
          
    public:  
        typedef std::shared_ptr<DiffuseLight> ptr;  
          
        DiffuseLight(unsigned int a) : m_emitTex(a) { }  
          
        virtual bool scatter(const Ray &in, const HitRecord &rec, ScatterRecord &srec) const  
        { return false; }  
          
        virtual Vector3D emitted(const Ray &in, const HitRecord &rec, const float &u,  
                                 const float &v, const Vector3D &p) const;  
    };  
      
    Vector3D DiffuseLight::emitted(const Ray &in, const HitRecord &rec, const float & u,  
                                   const float & v, const Vector3D & p) const  
    {  
        return TextureMgr::getSingleton()->getTexture(m_emitTex)->sample(u, v, p);  
    }  
      
  
---|---  
  
这样，对于任意的物体，我们都可以把它当作一个光源，只要给这个物体赋予的材质为DiffuseLightDiffuseLight即可，同时要注意给发光材质设置一个纹理。

# 四、天空盒背景

之前在光线投射到背景中时，我们是直接返回设定的背景颜色（或通过插值、或直接指定背景）。同样，我们可以通过天空盒来丰富我们的场景细节。天空盒的相关原理比较简单，不再赘述。一个天空盒用边长为1的立方体表示，一个立方体我采用多个三角形构成立方体网格。这里有个问题，就是如何实现天空盒永远无法靠近的效果。在实时渲染时我们直接移除视图矩阵的位移，在光追这里我们直接将光源的出发点设为原点，方向保持不变，这样的一条射线再与天空盒立方体做求交并采样纹理即可。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    

|  __复制

    
    
     Vector3D Skybox::sampleBackground(const Ray &ray)  
    {  
        HitRecord rec;  
        Ray r(Vector3D(0,0,0), ray.getDirection());  
        TextureMgr::ptr texMgr = TextureMgr::getSingleton();  
        int index = -1;  
        for (int x = 0; x < m_indices.size(); x += 3)  
        {  
            int index1 = m_indices[x + 0];  
            int index2 = m_indices[x + 1];  
            int index3 = m_indices[x + 2];  
            if (triangleHit(r, 0.001f, FLT_MAX, rec,  
                m_vertices[index1], m_vertices[index2], m_vertices[index3],  
                m_vertices[index1].m_normal))  
            {  
                index = x;  
                break;  
            }  
        }  
      
        if(index != -1)  
        {  
            int map = index / 6;  
            return texMgr->getTexture(m_cubemap[map])  
                    ->sample(rec.m_texcoord.x, rec.m_texcoord.y, rec.m_position);  
        }  
        else  
            return Vector3D(0.0,0.0,0.0);  
    }  
      
  
---|---  
  
# 五、构建BVH树

在整个光线追踪算法的渲染过程中，计算量最大的就是光线与场景图元的求交过程。如果不采用一些特殊的数据结构而只是用线性表存储场景物体的话，那么每一条射线都需要对这个存储场景物体的线性表遍历一次，这个射线碰撞检测的算法时间复杂度是O(n)O(n)的，当nn比较大时，那么射线碰撞检测需要耗费绝大部分的光线追踪算法时间。射线相交检测的时间是目前光线追踪算法从理论到大规模实际应用过渡的主要瓶颈。为此，我们需要一些特殊的场景管理数据结构来加速这个过程，BVH树（全称为bounding
volume
hierachy，即层次包围体）是光线追踪领域常用的一种3D场景管理数据结构。它的启发思路就是通过一个简单的包围盒把物体包围起来，射线和场景中的物体求交之前，会先和这个包围盒进行求交，如果该射线没有碰到该包围盒，表明该直线一定不会和包围盒里的物体相交；如果该射线碰到该包围盒，那么再来计算射线是否和包围盒中的物体相交。我们采用包围体是AABB包围盒（即axis-
aligned minimum bounding box，轴对齐的最小包围盒，简称轴向包围盒）。

BVH树本质上是对空间做分割，然后采用二分搜索快速判断射线会与哪些包围盒发生碰撞，从而使得算法的时间复杂度从O(n)O(n)降到了O(log(n))O(log(n))，这是一个非常明显的算法效率的提升，特别是当nn数量逐渐增大的时候。每一次的判断过程如下列伪代码所示。如果射线与父节点的包围盒有交点，则进一步判断子节点与射线的相交情况，否则直接退出。

    
    
    1  
    2  
    3  
    4  
    

|  __复制

    
    
     if (ray hits bounding object)  
        return whether ray hits bounded objects  
    else  
        return false  
      
  
---|---  
  
BVH树全称是层次包围盒，故名思意，它是一个树形的层次结构，父节点的包围盒包围全部子节点所在的空间，正如下图11所示。蓝色和红色的包围盒被包含在紫色的大包围盒中，它们可能重叠，并且它们不是有序的，它们只是单纯地被包含在内部。

![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/4.png)

图1 层次包围盒

对于图1，检测的伪代码如下：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    

|  __复制

    
    
     if (hits purple)  
        hit0 = hits blue enclosed objects  
        hit1 = hits red enclosed objects  
    if (hit0 or hit1)  
      return true and info of closer hit  
    return false  
      
  
---|---  
  
#### 1、射线与包围盒相交判断

我们采用的紧凑的包围盒是AABB包围盒，计算出了包围盒之后，我们还需要一个判断射线是否与包围盒相交的办法，不需要求出射线与包围盒的交点，只需判断是否存在交点即可！我们采用一种常见的”slab“方法，它是基于AABB包围盒的。三维的AABB包围盒由三个轴的区间表示，假设分别为[x0,x1][x0,x1]、[y0,y1][y0,y1]、[z0,z1][z0,z1]。

对于每一个区间，我们首先判断射线在边界的投影交点情况。三维空间中，x=x0x=x0和x=x1x=x1是一个平面，射线在这两个平面上的交点的xx值可以通过将x=x0x=x0和x=x1x=x1带入射线的方程P(t)=S+tVP(t)=S+tV的xx分量得到：

x0=Sx+t0∗Vxx1=Sx+t1∗Vx(13)(13)x0=Sx+t0∗Vxx1=Sx+t1∗Vx

![1558612929075](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/hit.png)

图2 射线与边界的交点

从而可以求出t0t0和t1t1如下所示：

t0=x0−SxVxt1=x1−SxVx(14)(14)t0=x0−SxVxt1=x1−SxVx

关于yy轴和zz轴同理，我们求出了每条轴的交点分量，那么如何快速判断射线与包围盒区域是否存在相交的情况呢？为了便于理解，我们以二维的情况为例，则射线与二维的包围区域相交由如下三种情况：

![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/1.png)

![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/2.png)

![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/3.png)

图3 射线与边界相交的三种情况

我们求得tt值是关于射线上的电到射线原点的距离，通过仔细观察上面的三张图片，我们可以发现在二维的情况下，当max(t0,t2)>min(t1,t3)max(t0,t2)>min(t1,t3)时，射线一定和区域存在交点，即射线与每个轴区间的左端点中的最大tt值大于射线与每个轴区域间的右端点中的最小tt值。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    

|  __复制

    
    
     bool hit(const Ray &ray, float tmin, float tmax) const  
    {  
        float t0, t1, invD;  
          
        // x  
        invD = 1.0f / ray.getDirection().x;  
        t0 = (m_min.x - ray.getOrigin().x) * invD;  
        t1 = (m_max.x - ray.getOrigin().x) * invD;  
        if (invD < 0.0f)  
            std::swap(t0, t1);  
        tmin = t0 > tmin ? t0 : tmin;  
        tmax = t1 < tmax ? t1 : tmax;  
        if (tmax <= tmin) return false;  
          
        // y  
        invD = 1.0f / ray.getDirection().y;  
        t0 = (m_min.y - ray.getOrigin().y) * invD;  
        t1 = (m_max.y - ray.getOrigin().y) * invD;  
        if (invD < 0.0f)  
            std::swap(t0, t1);  
        tmin = t0 > tmin ? t0 : tmin;  
        tmax = t1 < tmax ? t1 : tmax;  
        if (tmax <= tmin) return false;  
          
        // z  
        invD = 1.0f / ray.getDirection().z;  
        t0 = (m_min.z - ray.getOrigin().z) * invD;  
        t1 = (m_max.z - ray.getOrigin().z) * invD;  
        if (invD < 0.0f)  
            std::swap(t0, t1);  
        tmin = t0 > tmin ? t0 : tmin;  
        tmax = t1 < tmax ? t1 : tmax;  
        if (tmax <= tmin) return false;  
          
        return true;  
    }  
      
  
---|---  
  
#### 2、BVH树的构建

首先我们要考虑如何构建一颗BVH树，BVH数据结构本质就是一颗二叉树。每个树节点右两个子节点，当然子节点之间不存在空间上的顺序关系。树的内部节点都不存储实际的场景物体，仅存储一个包围盒，叶子节点才存储真正的场景物体。构建BVH树的工作考虑的是如何构造一棵可以有效描述当前场景信息的二叉树。这当中的关键是如何对毫无规律地散落在场景中的众物体进行划分，即决定哪些物体该划分到左子树上，哪些物体该划分到右子树上。我们可以把这个问题抽象成一个”划分策略“——我们总会按照某种”策略“划分场景的，待会再考虑具体有哪些策略。另外，由于我们是在3D空间中工作，为了将问题简化，用分而治之的角度看，我们可以首先建立一个”原则“：即决定在哪根轴（x,y,z）上进行划分。”原则“与”策略“的不同之处在于，不管用何种”策略“，总是遵守同一种”原则“。

决定在哪根轴（x,y,z）上进行划分，取决于场景中的物体在各个轴上分布的“散度”。如果这些物体沿着某根轴分布得最为“松散”（即落在该轴上靠一侧最近的物体与另一侧最近的物体，二者距离为最大），那么就沿该轴进行划分。还有一种方式，即采用随机的方式选取划分的轴，这样当场景物体分散的很随机时，实现的效果还不错。这里我采用随机选取一个轴的方法进行划分。

确定了以哪根轴进行划分，接下来就要考虑“怎么划分”。我们目前暂时实现按终点划分的策略，顾名思义，取中点划分的意思就是在先前选取的轴上取其中点作为划分点，中点以左划分到左子树，中点以右划分到右子树。这种划分的实现方式最为简单，但往往效果不是太好：因为物体的分布往往不是均匀的。其中一种糟糕的情况（a）是，某侧子树上可能会拥挤过多的物体，而另一侧子树上却太少，这对查找效率影响很大。另外还有一种糟糕的情况（b），就是包围盒之间互相“重叠”（overlapped）的情况。如果两棵子树对应的包围盒“重叠”的越多，那么一条射线穿过该区域时同时击中两子树的概率也就越大，这就意味着两棵子树都得进行相交测试。当然我们目前实现的BVH树没有考虑那么多。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    

|  __复制

    
    
     BVHNode::BVHNode(std::vector<Hitable *> &list, int start, int end)  
    {  
        // sort it randomly depend on  
        int axis = static_cast<int>(3 * drand48());  
        if (axis == 0)  
            sort(&list[start], &list[end], boxCompareX);  
        else if (axis == 1)  
            sort(&list[start], &list[end], boxCompareY);  
        else if (axis == 2)  
            sort(&list[start], &list[end], boxCompareZ);  
        int length = end - start;  
        if (length == 1)  
            m_left = m_right = list[start];  
        else if (length == 2)  
        {  
            m_left = list[start];  
            m_right = list[start + 1];  
        }  
        else  
        {  
            m_left = new BVHNode(list, start, start + length / 2);  
            m_right = new BVHNode(list, start + length / 2, end);  
        }  
        // bounding box.  
        AABB boxLeft, boxRight;  
        if (!m_left->boundingBox(0, 0, boxLeft) || !m_right->boundingBox(0, 0, boxRight))  
            std::cerr << "no bounding box in BVHNode constructor\n";  
        m_box = AABB::surroundingBox(boxLeft, boxRight);  
    }  
      
  
---|---  
  
#### 3、BVH树的遍历

遍历BVH差不多是件直截了当的事情。在遍历的过程中，当发现射线与某个子节点相交的话，那么有无必要再检测下与另一子节点是否相交？答案是要的。因为两个节点无法保证完全“不重叠”，如下图所示，很有可能在检测另一子节点时发现了更近的交点。

![](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/5.gif)

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    

|  __复制

    
    
     bool BVHNode::hit(const Ray &ray, const float &t_min, const float &t_max, HitRecord &ret) const  
    {  
        if (m_box.hit(ray, t_min, t_max))  
        {  
            HitRecord leftRec, rightRec;  
            bool hitLeft = m_left->hit(ray, t_min, t_max, leftRec);  
            bool hitRight = m_right->hit(ray, t_min, t_max, rightRec);  
            // both hit.  
            if (hitLeft && hitRight)  
            {  
                if (leftRec.m_t < rightRec.m_t)  
                    ret = leftRec;  
                else  
                    ret = rightRec;  
                return true;  
            }  
            // only left child.  
            else if (hitLeft)  
            {  
                ret = leftRec;  
                return true;  
            }  
            else if (hitRight)  
            {  
                ret = rightRec;  
                return true;  
            }  
            else  
                return false;  
        }  
        else  
            return false;  
    }  
      
  
---|---  
  
# 六、tbb多线程渲染

到目前为止我们实现的光追渲染逻辑都是串行的，只能利用单核cpu运行我们的渲染程序。对于简单的场景来说，渲染的速度还是挺快的。但是当我们渲染复杂的模型时，单核光追的渲染速度慢到爆炸，渲染时间随着模型的面片数迅速增长，渲染时间动不动就数十小时！为此，我们迫切需要加速渲染程序。我们可以看到，每个像素着色之间是没有联系的，一个像素的着色值与其周围的像素计算无关，所以像素的着色计算是可以并行计算的。我们首先实现在cpu上利用多核加速我们的渲染程序。直接操纵原生的线程API不是非常好，因为这样的话我们必须知道当前电脑的核心数，并据此将循环做一个分割，以便充分利用每个cpu核心。Intel开发的TBB是非常有用的线程库，它屏蔽了底层的线程细节，自动根据我们给定的工作量做线程分割，充分利用电脑的全部cpu资源，而且使用起来也非常简单。这里利用多核线程的渲染速度加速比大致是当前电脑的核心数，也就是说，电脑的cpu核心越多，渲染速度越快。tbb的官方网站请看[这里](https://www.threadingbuildingblocks.org/)。

tbb的全称是Thread Building
Blocks，这里我们只用了tbb的parallel_for接口，它对一个给定的for循环做划分，然后每个划分并行计算。我采用的parallel_for接口函数如下所示：

    
    
    1  
    2  
    

|  __复制

    
    
     template<typename Range, typename Body>  
    void parallel_for( const Range& range, const Body& body, const auto_partitioner& partitioner )  
      
  
---|---  
  
可以看到出现了三个参数：range、body和partitioner。range就是我们要做并行的for循环下标范围，通常采用一维的迭代器blocked_range指定。这里我把二重循环展开成一重循环。然后body就是函数执行体，这里我通过c++11的lambda表达式指定。最后的partitioner是线程的划分方法，通常直接采用auto_partitioner。并行版的光追渲染如下所示：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    

|  __复制

    
    
     void Tracer::parallelThreadRender(Hitable *scene)  
    {  
        parallel_for(blocked_range<size_t>(0, m_config.m_height * m_config.m_width, 10000),  
            [&](blocked_range<size_t>& r)  
        {  
            for (size_t i = r.begin(); i != r.end(); ++i)  
            {  
                Vector4D color;  
                size_t col = i % m_config.m_width;  
                size_t row = i / m_config.m_width;  
                for (int x = 0; x < m_config.m_samplings; ++x)  
                {  
                    float u = static_cast<float>(col + drand48()) / static_cast<float>(m_config.m_width);  
                    float v = static_cast<float>(row + drand48()) / static_cast<float>(m_config.m_height);  
                    Ray ray = m_config.m_camera->getRay(u, v);  
                    color += deNan(tracing(ray, scene, &m_samplingList,0));  
                }  
                color /= static_cast<float>(m_config.m_samplings);  
                color.w = 1.0f;  
                // gamma correction.  
                color = Vector4D(sqrt(color.x), sqrt(color.y), sqrt(color.z), color.w);  
                if(color.x > 1.0f) color.x = 1.0f;  
                if(color.y > 1.0f) color.y = 1.0f;  
                if(color.z > 1.0f) color.z = 1.0f;  
                drawPixel(col, row, color);  
            }  
        }, auto_partitioner());  
    }  
      
  
---|---  
  
# 七、蒙特卡罗积分

蒙特卡罗积分方法（Monte Carlo
method）是数值分析中的一个重要分支，它的核心概念是使用随机性来解决确定性的问题。大数定律告诉我们，对于满足某个概率分布的随机变量，其数学期望所描述的积分可以使用这个随机变量随机抽样的样本均值来近似，因此在一定的误差范围内，我们能够使用大量的随机数来近似积分运算的结果。在计算机图形学中，
蒙特卡罗方法主要被应用于物理模拟以及光照传输中的积分运算，在离线渲染领域，
渲染方程几乎只能使用蒙特卡洛方法来进行计算。为了深入理解蒙特卡罗方法，我们首先要复习概率论相关的一些基础内容。以下的内容主要参考秦春林的那本书《全局光照技术：从离线到实时渲染》。

## 1、概率密度函数、概率分布函数

概率密度函数（probability density function,
简称PDF）用于描述连续型随机变量所服从的概率分布，对于连续随机变量XX，其概率密度函数p(x)p(x)是通过落于xx附近的区间[x,x+dx][x,x+dx]内的随机数的概率p(x)dxp(x)dx来定义的，然而这种定义方式并不直观，所以连续随机变量的概率分布一般通过更直观的称为概率分布函数或者累积分布函数（cumulative
distribution function, 简称CDF）来定义，连续随机变量XX的累积分布函数用大写字母PP表示，其定义如下：

P(y)=Pr{x≤y}=∫y−∞p(x)dx(15)(15)P(y)=Pr{x≤y}=∫−∞yp(x)dx

可以看到，概率分布函数P(y)P(y)定义的是所有随机数的值中小于或等于yy的随机变量的概率的积分，即理解成对于一个随机数xx，其小于等于yy的概率。因此，概率分布函数是一个递增函数。连续随机变量的概率密度函数p(x)p(x)具有以下的属性：

∀x:p(x)≥0(16)(16)∀x:p(x)≥0∫+∞−∞p(x)dx=1(17)(17)∫−∞+∞p(x)dx=1p(x)=dP(x)dx(18)(18)p(x)=dP(x)dx

其中，式(8)(8)说明了p(x)p(x)和P(x)P(x)的关系，前者是后者的导数。那么给定一个随机变量的区间范围[a,b][a,b]，随机变量的值xx落在这个区间的概率计算如下：

Pr{a≤x≤b}=Pr(x≤b)−Pr(x≤a)=P(b)−P(a)=∫bap(z)dz(19)(19)Pr{a≤x≤b}=Pr(x≤b)−Pr(x≤a)=P(b)−P(a)=∫abp(z)dz

注意，这里的PrPr函数是概率函数，而不是概率分布函数。直观来讲，概率密度函数p(x)p(x)给定的并不是随机变量取值xx的概率，概率密度函数与轴围成的面积才是给定的概率。如下所示，图(a)是概率分布函数，而图(b)(b)则是概率密度函数，给定区间的[a,b][a,b]的概率就是下图(b)中的面积，这也对应了公式(19)(19)中的积分形式（积分的几何意义就是面积）。

![6](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/6.png)

在这里，我们要特别关注的一个分布，那就是均匀分布！对于[a,b][a,b]区间上的均匀分，其概率密度函数为常数1b−a1b−a，它表示随机抽样结果落于区间[x,x+dx][x,x+dx]的概率在每个xx处都相同。均匀分布的随机变量是整个蒙特卡罗方法的基础，在计算机模拟中，通过都是由系统提供的random()函数生成某个区间内的均匀分布，然后通过一些方法将均匀分布的随机变量转换为具有任意概率密度分布的随机变量。

## 2、数学期望

对于离散随机变量XX，假设其值xixi对应的抽样概率为pipi，则该随机变量XX的数学期望，或称为均值，为：

E[X]=Σni=1pixi(20)(20)E[X]=Σi=1npixi

数学期望代表的是对一个随机变量XX进行抽样的平均结果。例如，对于骰子的例子，它的数学期望为：

E[Xdie]=Σ6i=1pixi=Σ6i=116xi=16(1+2+3+4+5+6)=3.5(21)(21)E[Xdie]=Σi=16pixi=Σi=1616xi=16(1+2+3+4+5+6)=3.5

相应地，对于连续随机变量XX，其期望值为随机变量值xx与其概率密度函数p(x)p(x)的乘积在全定义域上的积分：

E[X]=∫+∞−∞xp(x)dx(22)(22)E[X]=∫−∞+∞xp(x)dx

连续随机变量XX的数学期望为什么上面的公式(22)(22)形式呢？这其实可以通过离散划分连续随便变量的定义域，然后按照离散数学期望得到一个近似的公式，当划分数趋向于无穷大且划分区间趋向于无穷小时，就是公式(22)(22)的积分定义。如下所示：

E[X]≈b−anΣni=1xip(xi)n→+∞,
b−anΣni=1xip(xi)=∫baxp(x)dx=E[X]E[X]≈b−anΣi=1nxip(xi)n→+∞,
b−anΣi=1nxip(xi)=∫abxp(x)dx=E[X]

通常我们对随机变量的函数更感兴趣。考虑以随机变量XX为自变量的函数Y=g(X)Y=g(X)，我们只知道随机变量XX的概率分布，怎样求出随机变量YY的数学期望值呢？我们可以通过无意识的统计规律（law
of the unconsicious
statistician）来求随机变量函数的数学期望：设YY是随机变量XX的函数Y=g(X)Y=g(X)，且函数gg是连续函数。若XX是离散型随机变量，它的概率函数为P{X=xi}=pi,i=1,2,…P{X=xi}=pi,i=1,2,…，则有：

E[Y]=E[g(X)]=Σ∞i=1g(xi)pi(23)(23)E[Y]=E[g(X)]=Σi=1∞g(xi)pi

若XX是连续型随机变量，它的概率密度函数为p(x)p(x)，则有：

E[Y]=E[g(X)]=∫+∞−∞g(x)p(x)dx(24)(24)E[Y]=E[g(X)]=∫−∞+∞g(x)p(x)dx

该方法的重要意义在于：当求E[Y]E[Y]时，我们不必求出YY的分布律或概率密度函数，只需利用XX的分布律或概率密度即可。

## 3、大数定律

在统计学中，很多问题涉及对大量独立的随机变量抽样xixi的和进行处理，这些随机变量拥有相同的概率密度函数p(x)p(x)，这样的随机变量称为独立同分布的随机变量。当这些随机变量抽样的和被除以这些随机变量抽样的数量NN时，我们就得到该随机变量的期望值的一个估计：

E[X]≈¯¯¯¯¯X=1NΣNi=1xi(25)(25)E[X]≈X¯=1NΣi=1Nxi

随着抽象数量NN的增大，该估计的方差逐渐减小。当NN的值足够大时，该估计的值就能够充分接近实际数学期望的值，这样我们就能够将统计方法用于解决确定性问题。大数定律（law
of large numbers）告诉我们，当N→∞N→∞时，我们可以确定随机变量的统计平均值趋近于数学期望的值，即：

P{E[X]=limN→∞1NΣNi=1xi}=1(26)(26)P{E[X]=limN→∞1NΣi=1Nxi}=1

因此，随机变量的数学期望可以通过对随机变量执行大量的重复抽样来近似计算得到。

## 4、蒙特卡罗积分

假设我们要计算一个一维函数的积分，如∫baf(x)dx∫abf(x)dx，数值分析方法通常采用一些近似方法来计算积分。一种最简单的求积分的方法就是采用梯形法，它通过将被积函数沿作用域上划分成多个区域，然后计算这些区域面积的和。这种方法不适用于多维积分的计算，计算机图形学领域用的最多的还是蒙特卡罗方法。大数定律用于对数学期望的积分公式进行估计，即对积分∫+∞−∞xf(x)dx∫−∞+∞xf(x)dx进行估计。但是通常情况下我们要求的积分公式是对任意的一个函数积分，假设函数g(x)g(x)的定义域为x∈Sx∈S（可以是一个多维空间），我们希望计算如下的积分：

I=∫x∈Sg(x)dx(27)(27)I=∫x∈Sg(x)dx

现在先不管公式(27)(27)。由前面我们知道，给定任意一个关于随机变量的实数函数ff以及服从p(x)p(x)概率密度函数的随机变量xx，我们可以采用如下的公式来近似计算随机变量函数f(x)f(x)的数学期望：

E[f(x)]=∫x∈Sf(x)p(x)dx≈1NΣNi=1f(xi)(28)(28)E[f(x)]=∫x∈Sf(x)p(x)dx≈1NΣi=1Nf(xi)

现在我们令公式(27)(27)的被积函数g(x)=f(x)p(x)g(x)=f(x)p(x)，则f(x)=g(x)p(x)f(x)=g(x)p(x)，那么公式(28)(28)即可转变对公式(27)(27)的形式，如下所示：

∫x∈Sf(x)p(x)dx=∫x∈Sg(x)dx≈1NΣNi=1g(xi)p(xi)(29)(29)∫x∈Sf(x)p(x)dx=∫x∈Sg(x)dx≈1NΣi=1Ng(xi)p(xi)

可以看到通过这个变换，我们巧妙地转换成我们要求的积分公式，这就是蒙特卡洛方法求积分的核心思想。公式(29)(29)的期望值为：

E[1NΣNi=1g(xi)p(xi)]=1NΣNi=1E[g(xi)p(xi)]=1NN∫g(x)p(x)p(x)dx=∫g(x)dx(30)(30)E[1NΣi=1Ng(xi)p(xi)]=1NΣi=1NE[g(xi)p(xi)]=1NN∫g(x)p(x)p(x)dx=∫g(x)dx

而公式(29)(29)的估计方差为：

σ2=1N∫(g(x)p(x)−I)2p(x)dx(31)(31)σ2=1N∫(g(x)p(x)−I)2p(x)dx

可以看到，随着NN的增大，公式(31)(31)的方差随之降低（成反比），这就是一般蒙特卡罗方法的特点。实际上蒙特卡罗方法最大的问题就是估计逼近正确结果的速度非常慢。理论上，公式(29)(29)的p(x)p(x)函数的选择可以是任意的，这也是蒙特卡罗方法的优点，因为通常很难生成与被积函数具有一致分布的随机数。从公式(31)(31)也可以看出，通过使g(xi)g(xi)和p(xi)p(xi)的比值尽可能地小也可以减少估计误差，在实践上通常我们尽可能地使p(x)p(x)的分布接近于g(x)g(x)。综上，蒙特卡洛积分方法计算任意函数的积分步骤如下：

  * 首先对一个满足某种概率分布的随机数进行抽样；
  * 使用该抽样值计算g(xi)p(xi)g(xi)p(xi)的值，这称为该样本的贡献值；
  * 最后对所有抽样点计算的结果求平均值。

上面的步骤中，最困难的就是怎么样对一个具有任意分布函数的随机变量进行抽样。

## 5、随机抽样

首先定义什么是抽样。给定一个定于域空间Ω0Ω0及其概率密度函数p(x)p(x)，其中x∈Ω0x∈Ω0，则应有：

∫Ω0p(x)dx=1(32)(32)∫Ω0p(x)dx=1

抽样是这样的一个算法，它能够从p(x)p(x)对应的随机变量XX中产生一系列随机数X1,X2,…X1,X2,…，使得对任意的Ω∈Ω0Ω∈Ω0满足如下：

P{Xk∈Ω}=∫Ωp(x)dx≤1(33)(33)P{Xk∈Ω}=∫Ωp(x)dx≤1

在实现中我们并不能直接从p(x)p(x)产生随机数，在计算机程序中这个过程必须要求首先具有某些基础随机数的一个序列。我们通常采用均匀随机数random来产生一个均匀分布的随机数，然后用来作为抽象所需的基础随机数。目前抽象方法根据不同情况有不同的方法，这里目前只介绍逆变换算法。

逆变换算法的定义为：设XX是连续随机变量，其概率分布函数为PXPX，若随机变量YY是一个[0,1][0,1]上的均匀分布，则随机变量P−1X(Y)PX−1(Y)具有和XX一样的概率分布。即我们通过概率分布函数的反函数来获取服从p(x)p(x)概率密度函数的随机变量，注意是概率分布函数P(x)P(x)的反函数，而不是概率密度函数p(x)p(x)的反函数。有时我们不知道概率分布函数，这时我们可以通过概率密度函数来求它的概率分布函数。

逆变换算法从一个概率密度函数p(x)p(x)产生随机数XiXi的步骤如下：

  * 首先计算p(x)p(x)的概率分布函数：P(x)=∫x0p(t)dtP(x)=∫0xp(t)dt；
  * 其次计算累计分布函数的反函数：P−1(x)P−1(x)；
  * 然后从一个[0,1][0,1]上的均匀分布产生一个随机数ϕϕ；
  * 最后将随机数ϕϕ代入P−1(x)P−1(x)求出服从p(x)p(x)分布的随机数：Xi=P−1(ϕ)Xi=P−1(ϕ)。

# 八、重要性采样

重要性采样（importance
sampling）是蒙特卡罗方法中最重要的方差缩减方法，它通过选择对一个与目标概率分布具有相似形状的分布函数进行抽样来减少方差。
**重要性采样试图在被积函数中贡献较多的区域放置更多的采样点，以体现这部分区域的重要性。**
给定一个概率密度函数p(x)p(x)以及根据该概率密度函数抽样得到的NN个随机数xixi，根据蒙特卡洛方法，被积函数f(x)f(x)的积分II（即前面的公式（27），被积函数换成f(x)f(x)）可以通过以下公式来近似估计：

IN=1NΣNi=1f(xi)p(xi)(34)(34)IN=1NΣi=1Nf(xi)p(xi)

一个理想的估计的方差应该为00，即：

σ2=1N∫(f(x)p(x)−I)2p(x)dx=0(35)(35)σ2=1N∫(f(x)p(x)−I)2p(x)dx=0

注意到公式(35)(35)中，被积函数部分的p(x)>0p(x)>0，故应有(f(x)p(x)−I)2=0(f(x)p(x)−I)2=0，从而有如下的推导：

p(x)=|f(x)|I(36)(36)p(x)=|f(x)|I

若我们采用公式(36)(36)得到的概率密度函数进行采样，那么方差就会被完全消除。但是公式(36)(36)要求我们首先计算II的值，而这正是我们尝试去求解的，因而行不通。
**但是我们可以通过选取与被积函数
f(x)f(x)具有相似形状的概率密度函数来减少方差。**选择用于抽样的概率密度函数非常重要，尽管蒙特卡罗方法本身没有限制对概率密度函数的选择，但是选择不好的概率密度函数会大大增加蒙特卡罗估计的方差。

直观来讲，重要性采样就是根据被积函数f(x)f(x)的值来调整p(x)p(x)的概率分布。f(x)f(x)值大的地方，就多采样几个点；f(x)f(x)值小的地方，就少采样一些点。p(x)p(x)概率密度函数越是接近f(x)f(x)，蒙特卡罗方法估算的结果就越精确。

## 1、复合重要性采样

在实际的情景中，计算机图形学中的被积函数通常非常复杂，它们可能是不连续的，通常在少数区间拥有奇点或者一些较大的值，所以很难找到一个简单的与被积函数相似的分布来做重要性采样。例如，我们考虑渲染中最普通的直接光源的计算公式，如下所示：

Lo(p,v)=∫Ωfr(l,v)×Li(p,l)cosθidωi(37)(37)Lo(p,v)=∫Ωfr(l,v)×Li(p,l)cosθidωi

我们可以选取LiLi或者frfr来做重要性采样，但是这种方式表现效果并不佳。考虑一个接近镜面的BRDF表面被一个球形面积光照亮的例子。如下所示：

![7](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/7.png)

若将面积光源的分布LiLi作为重要性采样概率密度函数，因为物体表面几乎是镜面的，所以除了沿镜面反射光方向ωiωi，大部分光源上的采样对在最终的光照贡献都为0，因此估计的方差会非常大；而若采用BRDF分布作为重要性采样分布，那么对于小面积光源，依然会导致很大的方差。

因此，我们通常使用更复杂的采样方式，从而降低估算的方差。通常是根据被积函数的分布特征对其进行区域划分，然后在不同特征的区域上使用不同的分布函数进行采样，最后将这些结果以某种方式进行混合。复合重要性采样就是这一类的采样方法，它提供了一个策略使得可以从多个不同的分布中采样，然后对这些不同的采样结果进行加权组合。复合重要性采样可以简单地分成以下几步：

  * 首先，选取一系列的重要性分布p1,…,pnp1,…,pn，使得对于被积函数ff的每一个函数值比较大的区域ΩiΩi，在这个区域ΩiΩi，分布函数pipi近似为被积函数ff。通常一个复杂的被积函数是多个不相关的简单分布的乘积形式，所以这些重要性分布来源于这些简单分布。
  * 然后，从每个分布pipi产生nini个随机数Xi,1,…,Xi,niXi,1,…,Xi,ni；
  * 最后，将所有的分布估算结果通过加权组合起来。

复合重要性采样加权组合公式如下所示：

IN=Σni=11niΣnij=1ωi(Xi,j)f(Xi,j)pi(Xi,j)(38)(38)IN=Σi=1n1niΣj=1niωi(Xi,j)f(Xi,j)pi(Xi,j)

公式(38)(38)中的Σni=1Σi=1n表明结果是由nn个采样技术的叠加，1niΣnij=1ωi(Xi,j)f(Xi,j)pi(Xi,j)1niΣj=1niωi(Xi,j)f(Xi,j)pi(Xi,j)即表示一种特定的采样分布pipi的蒙特卡罗估算结果。可以看到，这里还乘上了一个权重系数ωi(Xi,j)ωi(Xi,j)，wi(x)wi(x)可以在每个xx处的值不一样，只要保证对于给定的xx值，满足Σni=1ωi(x)=1Σi=1nωi(x)=1即可。

## 2、平衡启发式

现在我们需要确定公式(38)(38)中的权重系数计算方法。假设我们采用两个采样分布p1(x)p1(x)和p2(x)p2(x)，两个采样分布单独的采样估算结果分别为1n1Σf(x)p1(x)1n1Σf(x)p1(x)和1n2Σf(x)p2(x)1n2Σf(x)p2(x)，它们各自的方差都很大，所以我们给它们各自乘上一个系数进行加权组合。为了尽可能地发挥每个采样分布的优势，我们往往尽可能地保证在每个区域贡献较大的采样分布拥有更大的权值系数。考虑如下的权重系数函数：

ωi(x)=cipi(x)Σnjcjpj(x)(39)(39)ωi(x)=cipi(x)Σjncjpj(x)

其中cici是每个采样分布pipi对应的采样数量占比，即ci=niNci=niN，故Σici=1Σici=1，cici在采样之前我们就可以确定得到。公式(39)(39)被称为平衡启发式，将ci=niNci=niN和公式(39)(39)代入到公式(38)(38)，可以推导出如下的标准的蒙特卡洛估算方法（做一些消去）：

IN=Σni=11niΣnij=1ωi(Xi,j)f(Xi,j)pi(Xi,j)=Σni=1Σnij=11nicipi(Xi,j)Σnjcjpj(Xi,j)f(Xi,j)pi(Xi,j)=Σni=1Σnij=11niniNpi(Xi,j)Σnjcjpj(Xi,j)f(Xi,j)pi(Xi,j)=1NΣni=1Σnij=1f(Xi,j)Σnjcjpj(Xi,j)=1NΣni=1Σnij=1f(Xi,j)¯¯¯p(Xi,j)(40)(40)IN=Σi=1n1niΣj=1niωi(Xi,j)f(Xi,j)pi(Xi,j)=Σi=1nΣj=1ni1nicipi(Xi,j)Σjncjpj(Xi,j)f(Xi,j)pi(Xi,j)=Σi=1nΣj=1ni1niniNpi(Xi,j)Σjncjpj(Xi,j)f(Xi,j)pi(Xi,j)=1NΣi=1nΣj=1nif(Xi,j)Σjncjpj(Xi,j)=1NΣi=1nΣj=1nif(Xi,j)p¯(Xi,j)

其中，¯¯¯p(x)p¯(x)又被称为联合抽样分布，其数学公式如下所示。总的采样数NN，每个分布pipi采集nini个随机数Xi,jXi,j。以上就是平衡启发式的核心思想，一种很自然地组合多种采样分布的方式。我们采用一个单一的与ii无关的分布¯¯¯p(x)p¯(x)来表述这种组合方式。

¯¯¯p(x)=Σni=1cipi(x)(41)(41)p¯(x)=Σi=1ncipi(x)

# 九、MC光线追踪

了解了相关的原理，接下来我们就实现一个MC（Monte Carlo，蒙特卡罗）光线追踪，主要的参考资料是Peter Shirley的《Ray
Tracing_ the Rest of Your
Life.pdf》。采样方法是复合重要性采样，复合的采样分布为Lambertian材质BRDF采样分布加上光源采样分布。

## 1、立体角

在球面坐标中，一个方向向量我们通常采用(θ,ϕ)(θ,ϕ)来唯一地表示，分别是天顶角和方位角。在衡量发光强度和辐射辐射度量学中，立体角有着广泛的应用。立体角描述了站在某一点的观察者观测到的物体大小的尺度，它被定义为球表面截取的面积微分与球半径平方之比，单位为球面度，写作srsr。显然，立体角是二维圆心角的三维扩展：

dω=dAr2(42)(42)dω=dAr2

更一般的情况，立体角通常转换为(θ,ϕ)(θ,ϕ)来表示，在单位球体上，dω=dAdω=dA，我们转换成用(θ,ϕ)(θ,ϕ)求微分面积dAdA。我们知道二维的弧长公式为：圆心角弧度数*半径（注意圆心角要换成弧度制）。如下所示，θθ和ϕϕ对应的弧长为：

sθ=θ∗rθsϕ=ϕ∗rϕ(43)(43)sθ=θ∗rθsϕ=ϕ∗rϕ

![8](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/8.png)

图4 求弧长

公式(43)(43)中的rθrθ其实就是球体半径，rϕrϕ与rθrθ的关系为：rϕ=rθ∗sinθrϕ=rθ∗sinθ。微分面积dAdA可以看成是一个矩形，宽和高分别为对应的弧长drϕdrϕ和drθdrθ，根据公式(43)(43)我们可知drϕdrϕ、drθdrθ计算方法如下：

dsθ=rθdθdsϕ=rϕdϕ(44)(44)dsθ=rθdθdsϕ=rϕdϕ

对于单位球体，rθ=r=1,rϕ=rθ∗sinθ=sinθrθ=r=1,rϕ=rθ∗sinθ=sinθ，从而立体角微分可转换成如下表示：

dω=dA=dsθ∗dsϕ=sinθdθdϕ(45)(45)dω=dA=dsθ∗dsϕ=sinθdθdϕ

## 2、Lambertian材质BRDF采样

对于Lambertian材质我们假定其光线的散射分布与cosθcosθ成正比，这里的θθ是光线与表面法向量的夹角，也就是说在靠近法线的方向光线散射得比较多。当光线与表面法线夹角大于90度时，不发生光线散射。我们记得光线得散射概率密度函数pdf为C∗cosθC∗cosθ，其中CC为某个常数。对于概率密度函数，我们必须保证其在全定义域上的（这里就是整个半球方向）积分为1，即有（涉及到了立体角转球面坐标表示形式和求定积分）：

∫ΩC∗cosθdω=C∫2π0dϕ∫π20cosθsinθdθ=C∗2π∫π20sinθd(sinθ)=C∗2π∗12=1→C=1π(46)(46)∫ΩC∗cosθdω=C∫02πdϕ∫0π2cosθsinθdθ=C∗2π∫0π2sinθd(sin⁡θ)=C∗2π∗12=1→C=1π

从而，Lambertian材质的光线散射概率密度函数PDF，记为pS(direction)pS(direction)，如下所示：

pS(direction)=cosθπ(47)(47)pS(direction)=cosθπ

现在我们要根据这个概率密度函数生成服从该分布的随机半球向量，根据前面随机抽样部分，我们首先要求出它的概率分布函数。根据定义，概率分布函数就是对概率密度函数积分：

P=∫Ωcosθπdω=∫2π0dϕ∫θ0cos tπsin t dt=2π∗1π∫θ0sin td(sin
t)=sin2θ=1−cos2θ(48)(48)P=∫Ωcosθπdω=∫02πdϕ∫0θcos tπsin t dt=2π∗1π∫0θsin td(sin
t)=sin2θ=1−cos2θ

根据逆变换算法，我们要取概率分布函数的反函数。这里有个小技巧，我们不需要调用反三角函数得到反函数，我们只需得到cosθcosθ即可。因为即便调用反三角函数得到θθ，后面我们将(θ,ϕ)(θ,ϕ)转换成笛卡尔坐标向量的时候还是要调用三角函数coscos，我们直接避免这个比较费时的过程。所以，任取一个[0,1][0,1]上均匀随机数r2r2：

cosθ=√1−r2(49)(49)cosθ=1−r2

公式(49)(49)只得到随机方向向量的θθ，我们还需要ϕϕ。对于Lamberatian材质，光线在方向角上是均匀分布的，故其概率密度函数为12π12π，概率分布函数为ϕ2πϕ2π。故对ϕϕ的随机采样如下，任取一个[0,1][0,1]上的均匀随机数r1r1：

ϕ2π=r1→ϕ=r1∗2π(50)(50)ϕ2π=r1→ϕ=r1∗2π

采样得方向向量的(θ,ϕ)(θ,ϕ)，我们还要将其转换到笛卡尔坐标系的形式，这个过程不难理解，仔细观察图4，不再赘述。从而，服从公式(47)(47)采样方向向量的代码如下所示：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    

|  __复制

    
    
     static Vector3D randomCosineDir()  
    {  
        float r1 = drand48();  
        float r2 = drand48();  
        float z = sqrt(1-r2);  
        float phi = 2 * M_PI * r1;  
        float x = cos(phi) * 2 * sqrt(r2);  
        float y = sin(phi) * 2 * sqrt(r2);  
        return Vector3D(x,y,z);  
    }  
      
  
---|---  
  
值得注意的是，我们的采样是以物体表面的切线和法线构成的坐标轴为参考系的，其中z轴方向是表面的法线向量。因此，通过上面的代码采样的得到方向向量还要转到该局部坐标系下。这个过程可以构建矩阵，也可以直接将方向向量三个分量与轴向量相乘，最后相加得到。我们采用了后者，首先构建一个局部坐标的正交基（Ortho-
normal Bases）：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    

|  __复制

    
    
     class ONB  
    {  
    private:  
        Vector3D m_axis[3];  
      
    public:  
        ONB() = default;  
        Vector3D u() const { return m_axis[0]; }  
        Vector3D v() const { return m_axis[1]; }  
        Vector3D w() const { return m_axis[2]; }  
      
        Vector3D operator[](int i) const { return m_axis[i]; }  
      
        Vector3D local(float a, float b, float c) const  
        { return u() * a + v() * b + w() * c; }  
      
        Vector3D local(const Vector3D &a) const  
        { return u() * a.x + v() * a.y + w() * a.z; }  
      
        void buildFromW(const Vector3D &n);  
      
    };  
      
    void ONB::buildFromW(const Vector3D &n)  
    {  
        m_axis[2] = n;  
        m_axis[2].normalize();  
      
        Vector3D a;  
        if(fabs(w().x) > 0.9f)  
            a = Vector3D(0,1,0);  
        else  
            a = Vector3D(1,0,0);  
        m_axis[1] = w().crossProduct(a);  
        m_axis[1].normalize();  
      
        m_axis[0] = w().crossProduct(v());  
        m_axis[0].normalize();  
    }  
      
  
---|---  
  
再构建一个PDF虚类，将PDF函数的函数值和采样抽线为valuevalue接口和generategenerate接口。并继承它创建CosinePDF类，可以看到CosinePDF的valuevalue是按照公式(47)(47)计算的：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    

|  __复制

    
    
     class PDF  
    {  
    public:  
        virtual float value(const Vector3D &driection) const = 0;  
        virtual Vector3D generate() const = 0;  
    };  
      
    class CosinePDF : public PDF  
    {  
    private:  
        ONB uvw;  
      
    public:  
        CosinePDF(const Vector3D &w) { uvw.buildFromW(w); }  
      
        virtual float value(const Vector3D &driection) const;  
      
        virtual Vector3D generate() const;  
      
    };  
      
    float CosinePDF::value(const Vector3D &direction) const  
    {  
        Vector3D dir = direction;  
        dir.normalize();  
        float cosine = dir.dotProduct(uvw.w());  
        if(cosine > 0.0f)  
            return cosine / M_PI;  
        else  
            return 0.0f;  
    }  
      
    Vector3D CosinePDF::generate() const  
    {  
        return uvw.local(Vector3D::randomCosineDir());  
    }  
      
  
---|---  
  
## 3、直接光源采样

显然在靠近光源的方向上，光照值对物体表面的颜色贡献更大，因此直接对光源采样对减少蒙特卡洛积分的方差有非常重要的作用。直接光源采样需要我们首先求采样分布的概率密度函数，目前我们先讨论一个最简单的光源例子，即矩形光源。假设矩形光源的面积为A，那么这个矩形光源的直接均匀采样的概率密度函数PDF为1A1A，但是通常我们采样的单位是立体角微分，如下所示，

![9](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/9.png)

图5 直接光源采样

dωdω与dAdA存在着一个对应关系，实际上我们可以通过前面提到的立体角定义（即公式(42)(42)）得到dωdω与dAdA的关系如下所示，这个公式不难理解。其中αα夹角是采样方向向量与矩形表面的法线向量的夹角，dAcosαdAcosα实际上是将矩形的微分面积dAdA投影到采样方向pqpq上，这是因为从pqpq方向看去只能看到dAcosαdAcosα这个大小的面积，然后再比上半径长度的平方||pq||2||pq||2，这是立体角的定义。

dω=dA∗cosα||pq||2(51)(51)dω=dA∗cosα||pq||2

现在对dAdA的采样概率为dAAdAA，在球体方向上对立体角dωdω采样的概率为p(direction)dωp(direction)dω，其中p(direction)p(direction)是我们假定的对光源直接采样的概率密度函数。理论上来说，dAAdAA应该等于p(direction)dωp(direction)dω，即有：

p(direction)∗dA∗cosα||pq||2=dAA→p(direction)=||pq||2Acosα(52)(52)p(direction)∗dA∗cosα||pq||2=dAA→p(direction)=||pq||2Acosα

公式(52)(52)推导出了我们要找的直接光源采样的概率密度函数。根据逆变换算法，我们还要求它的概率分布函数从而生成服从公式(52)(52)概率密度函数的随机采样方向，但是这里其实没有必要。我们直接在矩形光源上随机采样一个点，然后将这个采样点与物体表面上的点连接起来就是我们的直接光源采样方向，通过这个方法省去了比较复杂的高数推导过程。

有了以上的理论基础，我们接下来就实现矩形的直接光源采样。我这里的定义的一个矩形平面是由两个三角形组成，默认是在xz平面上的边长为2的正方形。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    

|  __复制

    
    
     Vector3D Plane::random(const Vector3D &o) const  
    {  
        Vector3D center = m_transformation.translation();  
        Vector3D leftCorner;  
        float width = m_transformation.scale().x * 2.0f;  
        float height = m_transformation.scale().z * 2.0f;  
        leftCorner.x = center.x - m_transformation.scale().x;  
        leftCorner.z = center.z - m_transformation.scale().z;  
        leftCorner.y = center.y;  
        Vector3D random_point(leftCorner.x + drand48() * width, leftCorner.y,  
                              leftCorner.z + drand48() * height);  
        return random_point - o;  
    }  
      
    float Plane::pdfValue(const Vector3D &o, const Vector3D &v) const  
    {  
          
        HitRecord rec;  
        if(this->hit(Ray(o,v), 0.001f, FLT_MAX, rec))  
        {  
            float area = m_transformation.scale().x * 2.0f * m_transformation.scale().z * 2.0f;  
            float distance_squared = v.getSquaredLength();  
            float cosine = fabs(v.dotProduct(rec.m_normal) / v.getLength());  
            float ret = distance_squared / (cosine * area);  
            return ret;  
        }  
        else  
            return 0.0f;  
    }  
      
  
---|---  
  
除了矩形区域光源，我们接下来还添加一个对球形区域光源的重要性采样。我们采取的坐标系依然是球形光源的局部坐标，而且依然是对光源区域做均匀采样。设想我们从物体表面上的一点望向一个球形区域光源，我们能够看到的区域就是我们要做均匀采样的区域，采样方法依然是围绕(θ,ϕ)(θ,ϕ)展开，其中θθ是采样方向向量与物体表面的点与球心构成的方向向量的夹角。

显然方位角ϕϕ依然是[0,2π][0,2π]的范围，不然我们不可能看到一个圆形。而θθ则需要做一些限制，它现在有个上界，如下图6所示，P是物体表面上的一点，C为球形光源的球心，R是球形光源的半径。

![10](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/10.png)

图6 球形区域光源采样

由图6可知，sin(θmax)=R||C−P||sin(θmax)=R||C−P||，相应的θmaxθmax的余弦值如下所示：

cos(θmax)=√1−R2||C−P||2(53)(53)cos(θmax)=1−R2||C−P||2

然后我们是对θθ和ϕϕ做均匀采样，ϕϕ的采样与前面Lambertian采样一样，这里不再赘述。对于θθ，因为是均匀采样，那么它的概率密度函数必然也是一个常数，我们设为CC，那么其概率分布函数计算如下：

P=∫ΩCdω=∫2π0dϕ∫θ0Csint dt=2πC(1−cosθ)(54)(54)P=∫ΩCdω=∫02πdϕ∫0θCsint
dt=2πC(1−cosθ)

根据逆变换算法，取[0,1][0,1]上的均匀随机数r2r2，并结合公式(54)(54)的反函数，可得采样的cosθcosθ如下：

cos(θ)=1−r22πC(55)(55)cos(θ)=1−r22πC

现在有个问题就是CC这个具体是多少？我们已经知道θθ的上界θmaxθmax，当θ=θmaxθ=θmax时，应该取概率分布函数值P(θmax)P(θmax)为1，也就是r2=1r2=1。故将其代入公式(55)(55)我们可以得到CC的具体表达式：

C=12π(1−cosθmax)(56)(56)C=12π(1−cosθmax)

然后再将公式(56)(56)和公式(53)(53)代入公式(55)(55)，可得：

cos(θ)=1+r2(cos(θmax)−1)=1+r2(√1−R2||C−P||2−1)(57)(57)cos(θ)=1+r2(cos(θmax)−1)=1+r2(1−R2||C−P||2−1)

公式(56)(56)j就是我们所需的概率密度函数，可以看起来不是很直观，这里我稍微解释一下。公式(56)(56)其实就是我们从物体表面上的一点观测到的球形光源所占的立体角的倒数（注意，这里的立体角是以物体表面上的一点为球心而不是球形光源的球面上的立体角）！立体角的几何意义是就是单位球体上的面积，然后做一个倒数是因为我们是做均匀随机采样。立体角的求法如下所示：

SolidAngle=∫2π0dϕ∫θmax0sinθdθ=2π(1−cos(θmax))(58)(58)SolidAngle=∫02πdϕ∫0θmaxsinθdθ=2π(1−cos(θmax))

可以看到公式(58)(58)求得的结果就是公式(56)(56)中的分母。取球形光源上的随机一点采样算法如下，就是公式(57)(57)的实现。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    

|  __复制

    
    
     static Vector3D randomToSphere(float radius, float distance_squared)  
    {  
        float r1 = drand48();  
        float r2 = drand48();  
        float z = 1 + r2 * (sqrt(1 - radius * radius/distance_squared) - 1);  
        float phi = 2 * M_PI * r1;  
        float x = cos(phi) * sqrt(1 - z * z);  
        float y = sin(phi) * sqrt(1 - z * z);  
        return Vector3D(x, y, z);  
    }  
      
  
---|---  
  
对球形光源的随机采样以及求取概率密度函数的值如下所示：

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    

|  __复制

    
    
     float Sphere::pdfValue(const Vector3D &o, const Vector3D &v) const  
    {  
        HitRecord rec;  
        if(this->hit(Ray(o,v), 0.001f, FLT_MAX, rec))  
        {  
            float cos_theta_max = sqrt(1- m_radius * m_radius/(m_center - o).getSquaredLength());  
            float solid_angle = 2 * M_PI * (1 - cos_theta_max);  
            return 1.0f / solid_angle;  
        }  
        else  
            return 0.0f;  
    }  
      
    Vector3D Sphere::random(const Vector3D &o) const  
    {  
        Vector3D dir = m_center - o;  
        float distance_squared = dir.getSquaredLength();  
        ONB uvw;  
        uvw.buildFromW(dir);  
        return uvw.local(Vector3D::randomToSphere(m_radius, distance_squared));  
    }  
      
  
---|---  
  
## 2、复合重要性采样

上面我们分别讨论了Lambertian采样和直接光源采样，然后我们要把它复合到一起。场景中通常有多个光源，所以直接光源采样应该对多个光源进行采样，我们采取均匀随机的策略，对于一束光线，它采样哪个光源由均匀的随机数决定，这样就能雨露均沾。复合的权重套用前面提到的平衡启发式，Lambertian采样和直接光源采样的权值各0.5，也就是各占一半。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    

|  __复制

    
    
     class MixturePDF : public PDF  
    {  
    private:  
        PDF* m_pdf[2];  
      
    public:  
        MixturePDF(PDF *p0, PDF *p1) { m_pdf[0] = p0;m_pdf[1] = p1; }  
      
        virtual float value(const Vector3D &direction) const  
        {  
            return 0.5f * m_pdf[0]->value(direction) + 0.5f * m_pdf[1]->value(direction);  
        }  
      
        virtual Vector3D generate() const  
        {  
            if(drand48() < 0.5f)  
                return m_pdf[0]->generate();  
            else  
                return m_pdf[1]->generate();  
        }  
    };  
      
  
---|---  
  
对于多个光源的直接采样，我们采取均匀随机的策略，那么PDF值也应该是这些直接光源采样概率密度函数的平均值。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    

|  __复制

    
    
     float HitableList::pdfValue(const Vector3D &o, const Vector3D &v) const  
    {  
        float weight = 1.0f / m_list.size();  
        float sum = 0;  
        for(int x = 0;x < m_list.size();++ x)  
            sum += m_list[x]->pdfValue(o, v);  
        return sum * weight;  
    }  
      
    Vector3D HitableList::random(const Vector3D &o) const  
    {  
        int index = static_cast<int>(drand48() * m_list.size());  
        return m_list[index]->random(o);  
    }  
      
  
---|---  
  
最后在光线追踪递归函数中加上我们的复合重要性采样。

    
    
    1  
    2  
    3  
    4  
    5  
    6  
    7  
    8  
    9  
    10  
    11  
    12  
    13  
    14  
    15  
    16  
    17  
    18  
    19  
    20  
    21  
    22  
    23  
    24  
    25  
    26  
    27  
    28  
    29  
    30  
    31  
    32  
    33  
    34  
    35  
    36  
    37  
    38  
    39  
    40  
    41  
    42  
    43  
    

|  __复制

    
    
     Vector4D Tracer::tracing(const Ray &r, Hitable *world, Hitable *light, int depth)  
    {  
        HitRecord rec;  
        if (world->hit(r, 0.001f, FLT_MAX, rec))  
        {  
            ......  
            if (depth < m_config.m_maxDepth && material->scatter(r, rec, srec))  
            {  
                if(srec.m_isSpecular)  
                {  
                    return srec.m_attenuation * tracing(srec.m_scatterRay, world, light, depth + 1);  
                }  
                else  
                {  
                    Vector3D dir;  
                    float pdf_val;  
                    if(!m_samplingList.isEmpty())  
                    {  
                        HitablePDF light_pdf(light, rec.m_position);  
                        MixturePDF mix_pdf(&light_pdf, srec.m_pdf.get());  
                        dir = mix_pdf.generate();  
                        pdf_val = mix_pdf.value(dir);  
                    }  
                    else  
                    {  
                        dir = srec.m_pdf->generate();  
                        pdf_val = srec.m_pdf->value(dir);  
                    }  
                    Ray scattered = Ray(rec.m_position, dir);  
      
                    return emitted + srec.m_attenuation * material->scattering_pdf(r, rec, scattered)  
                            * tracing(scattered, world, light, depth + 1) / pdf_val;  
                }  
            }  
            else  
                return emitted;  
        }  
        else  
        {  
            // background color.  
            ......  
        }  
    }  
      
  
---|---  
  
# 程序效果

![ret1](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret1.png)

![ret2](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret2.png)

![ret3](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret3.png)

![ret4](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret4.png)

![ret5](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret5.png)

![ret6](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret6.png)

![ret7](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.11/blog/RayTracer-Advance/ret7.png)

![ret8](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/ret8.png)

![header](https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.10/blog/RayTracer-Advance/header.png)

# 参考资料

[1[1 <http://www.thegibook.com/>

[2][2] Peter Shirley. [Ray Tracing in One Weekend](https://www.amazon.com/Ray-
Tracing-Weekend-Minibooks-Book-
ebook/dp/B01B5AODD8/ref=sr_1_1?ie=UTF8&qid=1547695669&sr=8-1&keywords=Peter+Shirley).
Amazon Digital Services LLC, January 26, 2016.

[3][3] <https://software.intel.com/en-
us/node/506045?_ga=2.114625223.1582767698.1558613799-2057498546.1558613799>

[4][4] <https://blog.csdn.net/zoufeiyy/article/details/1887579>

[5][5] <https://www.jianshu.com/p/b570b1ba92bb>

[6][6] <https://blog.csdn.net/libing_zeng/article/details/74989755>

[7][7] <https://www.qiujiawei.com/solid-angle/>

* * *

__

最后更新于 2019年5月26日

[__

Computer Graphics

](/tags/Computer-Graphics/)

[__

Ray Tracer

](/tags/Ray-Tracer/)

[ ![](https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png)
](http://connect.qq.com/widget/shareqq/index.html?url=https://yangwc.com/2019/05/23/RayTracer-
Advance/&title=光线追踪器Ray Tracer：进阶篇 | YangWC's
Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本篇文章在前面的基础上，丰富光线追踪器的各种特性。本篇内容主要包含添加纹理映射、平面光源和球形光源、三角网格模型渲染、增加天空盒背景、构建BVH树、tbb多线程渲染加速、蒙特卡罗积分方法、重要性采样，后面部分涉及的高等数学和概率论内容较多。相关的全部代码在这里。

 "QQ好友") [
![](https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png)
](https://sns.qzone.qq.com/cgi-
bin/qzshare/cgi_qzshare_onekey?url=https://yangwc.com/2019/05/23/RayTracer-
Advance/&title=光线追踪器Ray Tracer：进阶篇 | YangWC's
Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本篇文章在前面的基础上，丰富光线追踪器的各种特性。本篇内容主要包含添加纹理映射、平面光源和球形光源、三角网格模型渲染、增加天空盒背景、构建BVH树、tbb多线程渲染加速、蒙特卡罗积分方法、重要性采样，后面部分涉及的高等数学和概率论内容较多。相关的全部代码在这里。

 "QQ空间") [
![](https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png)
](http://service.weibo.com/share/share.php?url=https://yangwc.com/2019/05/23/RayTracer-
Advance/&title=光线追踪器Ray Tracer：进阶篇 | YangWC's
Blog&pics=https://cdn.jsdelivr.net/gh/ZeusYang/CDN-for-
yangwc.com@1.1.42/blog/TinySoftRenderer/renderer2.jpg&summary=本篇文章在前面的基础上，丰富光线追踪器的各种特性。本篇内容主要包含添加纹理映射、平面光源和球形光源、三角网格模型渲染、增加天空盒背景、构建BVH树、tbb多线程渲染加速、蒙特卡罗积分方法、重要性采样，后面部分涉及的高等数学和概率论内容较多。相关的全部代码在这里。

 "微博")

###### __上一页

####  [ 流体模拟Fluid Simulation：Position Based Fluid
](/2019/06/04/PositionBasedFluid/ "流体模拟Fluid Simulation：Position Based Fluid")

######  [__Computer Graphics](/tags/Computer-Graphics/) [__Fluid
Simulation](/tags/Fluid-Simulation/) [__Position Based
Dynamics](/tags/Position-Based-Dynamics/)

###### 下一页 __

####  [ 光线追踪器Ray Tracer：入门篇 ](/2019/05/08/RayTracer-Basis/ "光线追踪器Ray
Tracer：入门篇")

######  [__Computer Graphics](/tags/Computer-Graphics/) [__Ray
Tracer](/tags/Ray-Tracer/)

#### __评论

<div><i class="fas fa-exclamation-
triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div>

![](/image/avator.jpg)

## YangWC

Enjoy Computer Graphics!

[ ](mailto:1579148717@qq.com) [ ](https://github.com/ZeusYang) [
](https://blog.csdn.net/qq_31615919)

__本文目录

[__](javascript:void\(0\))

  1. 一、纹理映射
  2. 二、三角网格模型
  3. 三、添加光源
  4. 四、天空盒背景
  5. 五、构建BVH树
    1. 1、射线与包围盒相交判断
    2. 2、BVH树的构建
    3. 3、BVH树的遍历

* 六、tbb多线程渲染
* 七、蒙特卡罗积分

  1. 1、概率密度函数、概率分布函数
  2. 2、数学期望
  3. 3、大数定律
  4. 4、蒙特卡罗积分
  5. 5、随机抽样

* 八、重要性采样

  1. 1、复合重要性采样
  2. 2、平衡启发式

* 九、MC光线追踪

  1. 1、立体角
  2. 2、Lambertian材质BRDF采样
  3. 3、直接光源采样
  4. 2、复合重要性采样

* 程序效果
* 参考资料

__欢迎来到YangWC的博客

本站会记录自己的一些学习内容，如若有错或者乱码，欢迎指正，感谢!

__站内导航

  * [ __关于博主](/about/ "/about/")
  * [ __近期文章](/ "/")
  * [ __文章归档](/archives/ "/archives/")

__文章分类

[ __](/categories/ "categories/")

  * [2D Rendering(1)](/categories/2D-Rendering/ "/categories/2D-Rendering/")
  * [Computer Graphics(37)](/categories/Computer-Graphics/ "/categories/Computer-Graphics/")
  * [Fluid Simulation(10)](/categories/Fluid-Simulation/ "/categories/Fluid-Simulation/")
  * [Fluid simulation(1)](/categories/Fluid-simulation/ "/categories/Fluid-simulation/")
  * [Image processing(1)](/categories/Image-processing/ "/categories/Image-processing/")
  * [N-body(1)](/categories/N-body/ "/categories/N-body/")
  * [Physical simulation(1)](/categories/Physical-simulation/ "/categories/Physical-simulation/")
  * [Physically Based Rendering(2)](/categories/Physically-Based-Rendering/ "/categories/Physically-Based-Rendering/")
  * [Position Based Dynamics(3)](/categories/Position-Based-Dynamics/ "/categories/Position-Based-Dynamics/")
  * [Ray Tracer(10)](/categories/Ray-Tracer/ "/categories/Ray-Tracer/")
  * [Real-time Rendering(7)](/categories/Real-time-Rendering/ "/categories/Real-time-Rendering/")
  * [Soft Renderer(4)](/categories/Soft-Renderer/ "/categories/Soft-Renderer/")
  * [Voxelization(1)](/categories/Voxelization/ "/categories/Voxelization/")

__热门标签

[ __](/tags/ "tags/")

[2D Rendering](/tags/2D-Rendering/) [3D Math](/tags/3D-Math/) [3D
pipeline](/tags/3D-pipeline/) [Advection](/tags/Advection/) [Computer
Graphics](/tags/Computer-Graphics/) [Fluid Simulation](/tags/Fluid-
Simulation/) [Fluid simulation](/tags/Fluid-simulation/) [Glow
effect](/tags/Glow-effect/) [Image processing](/tags/Image-processing/)
[N-body](/tags/N-body/) [Naiver-Stokes Equations](/tags/Naiver-Stokes-
Equations/) [Physical simulation](/tags/Physical-simulation/) [Physically
Based Rendering](/tags/Physically-Based-Rendering/) [Position Based
Dynamics](/tags/Position-Based-Dynamics/)
[Rasterization](/tags/Rasterization/) [Ray Tracer](/tags/Ray-Tracer/) [Real-
time Rendering](/tags/Real-time-Rendering/) [Soft Renderer](/tags/Soft-
Renderer/) [Voxelization](/tags/Voxelization/)

[ ](mailto:1579148717@qq.com) [ ](https://github.com/ZeusYang) [
](https://blog.csdn.net/qq_31615919)

  

博客内容遵循 [署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)
协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)

本站使用 [Material X](https://xaoxuu.com/wiki/material-x/) 作为主题 ， 总访问量为 159964 次 。

本站已安全运行 1559 天 20 小时 23 分 50 秒

[](javascript:void\(0\))

****of ****

NEXT PREV


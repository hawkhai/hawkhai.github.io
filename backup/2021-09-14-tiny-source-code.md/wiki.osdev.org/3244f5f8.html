<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en" dir="ltr" class="client-js"><head>
<title>C++ - OSDev Wiki</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.18.0" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="OSDev Wiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://wiki.osdev.org/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.vector&amp;only=styles&amp;skin=vector&amp;*" />
<style type="text/css" media="all">.mw-collapsible-toggle{float:right} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}

/* cache key: wikidb:resourceloader:filter:minify-css:4:4250852ed2349a0d4d0fc6509a3e7d4c */
</style><style type="text/css" media="all">.js-messagebox{margin:1em 5%;padding:0.5em 2.5%;border:1px solid #ccc;background-color:#fcfcfc;font-size:0.8em}.js-messagebox .js-messagebox-group{margin:1px;padding:0.5em 2.5%;border-bottom:1px solid #ddd}.js-messagebox .js-messagebox-group:last-child{border-bottom:thin none transparent}

/* cache key: wikidb:resourceloader:filter:minify-css:4:8b08bdc91c52a9ffba396dccfb5b473c */
</style><meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector&amp;*" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style>
<script src="/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector&amp;*"></script><script src="/load.php?debug=false&amp;lang=en&amp;modules=jquery%2Cmediawiki&amp;only=scripts&amp;skin=vector&amp;version=20120104T052914Z"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "C++", "wgTitle": "C++", "wgCurRevisionId": 24639, "wgArticleId": 1528, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["In Progress", "Languages", "C++"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script><script type="text/javascript" src="/load.php?debug=false&amp;lang=en&amp;modules=jquery.client%7Cmediawiki.page.startup&amp;skin=vector&amp;version=20120612T011114Z&amp;*"></script>
<style type="text/css">/*&lt;![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000ff;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #666666;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es1 {color: #000099; font-weight: bold;}
.cpp.source-cpp .es2 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es3 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es4 {color: #660099; font-weight: bold;}
.cpp.source-cpp .es5 {color: #006699; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #FF0000;}
.cpp.source-cpp .nu0 {color: #0000dd;}
.cpp.source-cpp .nu6 {color: #208080;}
.cpp.source-cpp .nu8 {color: #208080;}
.cpp.source-cpp .nu12 {color: #208080;}
.cpp.source-cpp .nu16 {color:#800080;}
.cpp.source-cpp .nu17 {color:#800080;}
.cpp.source-cpp .nu18 {color:#800080;}
.cpp.source-cpp .nu19 {color:#800080;}
.cpp.source-cpp .me1 {color: #007788;}
.cpp.source-cpp .me2 {color: #007788;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]&gt;*/
</style>
<style type="text/css">/*&lt;![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
/*]]&gt;*/
</style><style type="text/css">/*&lt;![CDATA[*/
.source-asm {line-height: normal;}
.source-asm li, .source-asm pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for asm
 * CSS class: source-asm, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.asm.source-asm .de1, .asm.source-asm .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.asm.source-asm  {font-family:monospace;}
.asm.source-asm .imp {font-weight: bold; color: red;}
.asm.source-asm li, .asm.source-asm .li1 {font-weight: normal; vertical-align:top;}
.asm.source-asm .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.asm.source-asm .li2 {font-weight: bold; vertical-align:top;}
.asm.source-asm .kw1 {color: #00007f; font-weight: bold;}
.asm.source-asm .kw2 {color: #0000ff; font-weight: bold;}
.asm.source-asm .kw3 {color: #00007f;}
.asm.source-asm .kw4 {color: #000000; font-weight: bold;}
.asm.source-asm .kw5 {color: #000000; font-weight: bold;}
.asm.source-asm .co1 {color: #666666; font-style: italic;}
.asm.source-asm .co2 {color: #adadad; font-style: italic;}
.asm.source-asm .es0 {color: #000099; font-weight: bold;}
.asm.source-asm .br0 {color: #009900; font-weight: bold;}
.asm.source-asm .sy0 {color: #339933;}
.asm.source-asm .st0 {color: #7f007f;}
.asm.source-asm .nu0 {color: #0000ff;}
.asm.source-asm .ln-xtra, .asm.source-asm li.ln-xtra, .asm.source-asm div.ln-xtra {background-color: #ffc;}
.asm.source-asm span.xtra { display:block; }

/*]]&gt;*/
</style>
<style type="text/css">/*&lt;![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&amp;usemsgcache=yes&amp;action=raw&amp;ctype=text/css&amp;smaxage=18000";
/*]]&gt;*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-C action-view skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;" class="js-messagebox"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">C++</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OSDev Wiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="#mw-head">navigation</a>,
					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div lang="en" dir="ltr" class="mw-content-ltr"><dl><dd><i>For a quick tutorial on getting a bare bones C++ kernel running see <a href="/Bare_Bones" title="Bare Bones">Bare Bones</a></i>
</dd></dl>
<p>A kernel can be programmed in C++, it is very similar to making a kernel in C, except that there are a few pitfalls you must take into account (runtime support, constructors, ...). This page will not list any (dis)advantages of this approach, but rather what you need to do to get things fired up.
</p><p>A lot of features C++ offers can be used on-the-fly; they require no additional support or code to use them properly (e.g. templates, classes, inheritance, virtual functions). There are however other parts of C++ that do require runtime support, which will be discussed in this article.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle"> [<a href="#" class="internal" id="togglelink">hide</a>] </span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Introduction"><span class="tocnumber">1</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Pure_virtual_functions"><span class="tocnumber">2</span> <span class="toctext">Pure virtual functions</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Global_objects"><span class="tocnumber">3</span> <span class="toctext">Global objects</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#GCC"><span class="tocnumber">3.1</span> <span class="toctext">GCC</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Visual_C.2B.2B"><span class="tocnumber">3.2</span> <span class="toctext">Visual C++</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Local_Static_Variables_.28GCC_Only.29"><span class="tocnumber">4</span> <span class="toctext">Local Static Variables (GCC Only)</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#The_Operators_.27new.27_and_.27delete.27"><span class="tocnumber">5</span> <span class="toctext">The Operators 'new' and 'delete'</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#Placement_New"><span class="tocnumber">5.1</span> <span class="toctext">Placement New</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#RTTI_.28Run-Time_Type_Information.29"><span class="tocnumber">6</span> <span class="toctext">RTTI (Run-Time Type Information)</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Exceptions"><span class="tocnumber">7</span> <span class="toctext">Exceptions</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Standard_Library"><span class="tocnumber">8</span> <span class="toctext">Standard Library</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Full_C.2B.2B_Runtime_Support_Using_libgcc_And_libsupc.2B.2B"><span class="tocnumber">9</span> <span class="toctext">Full C++ Runtime Support Using libgcc And libsupc++</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Optimizations"><span class="tocnumber">10</span> <span class="toctext">Optimizations</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Links"><span class="tocnumber">11</span> <span class="toctext">Links</span></a>
<ul>
<li class="toclevel-2 tocsection-15"><a href="#Wiki"><span class="tocnumber">11.1</span> <span class="toctext">Wiki</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<h2> <span class="mw-headline" id="Introduction"> Introduction </span></h2>
<p>If you have created a C++ kernel as documented in the <a href="/Bare_Bones" title="Bare Bones">Bare Bones</a> article, then many C++ features are already available and work out the box. However, your kernel does not yet satisfy the ABI and you cannot be confident that the compiler will not emit problematic code, even if you stick to the intersection of C and C++. In particular, you may need to initialize further CPU state to enable the floating-point registers and instructions, as the compiler has every reason to think floating point registers and instructions are available by default.
</p><p>However, the compiler will assume that all the C++ runtime support is available by default, however you are not linking in libsupc++ into your C++ kernel, which implements the necessary run-time support. This is why you are passing -fno-rtti and -fno-exceptions to your cross-compiler to let these runtime features are unavailable. Going further, you should link in libsupc++ into your kernel, but at the moment it's known to not be readily accessible to those starting out with operating systems development and the GCC build process doesn't cross-compile it properly for the bare -elf platforms by default.
</p><p>You also need to call the global constructors as documented in <a href="/Calling_Global_Constructors" title="Calling Global Constructors">Calling Global Constructors</a> to satisfy the ABI requirement that the program initialization tasks are properly called.
</p>
<h2> <span class="mw-headline" id="Pure_virtual_functions"> Pure virtual functions </span></h2>
<p>If you want to use pure virtual functions, your compiler needs a single support function. It is only called in case a pure virtual function call cannot be made (e.g. if you have overridden the virtual function table of an object). But nonetheless your linker will complain about unresolved symbols, if you use pure virtual functions and don't provide this support routine.
</p><p>Enabling pure virtual functions in GCC is fairly straightforward. All you need to do is add the function below to one of your C++ source files (and make sure it is linked in). It is not necessary to declare this function first, the definition alone is good enough for GCC. The function itself doesn't even need to do anything (and it doesn't in most implementations), it just needs to be "there" just in case.
</p><p>Below you will find an example of an implementation in respectively GCC.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">void</span> __cxa_pure_virtual<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Do nothing or print an error message.</span>
<span class="br0">}</span></pre></div></div>
<p>Or, if you happen to use Visual Studio:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> __cdecl _purecall<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// Do nothing or print an error message.</span>
<span class="br0">}</span></pre></div></div>
<p>If, during runtime, your kernel detects that a call to a pure virtual function couldn't be made, it calls the above functions. These functions should actually never be called, because without hacks, or through undefined behaviour of your kernel, it is not possible to instantiate a class that doesn't define all pure virtual functions.
</p>
<h2> <span class="mw-headline" id="Global_objects"> Global objects </span></h2>
<center>
<table style="border: 1px solid #cfcfbf; margin-top: 25px; margin-bottom: 25px; background-color: #f0f0ff; text-align: center;">
<tbody><tr>
<td>
<p><a href="/File:Under_Construction.png" class="image" title="This page is under construction!"><img alt="This page is under construction!" src="/images/1/14/Under_Construction.png" width="50" height="50" /></a>
This page or section is a work in progress and may thus be incomplete. Its content may be changed in the near future.
</p>
</td>
<td>
</td></tr></tbody></table>
</center>
<p>TODO: Please unify this information with the newer <a href="/Calling_Global_Constructors" title="Calling Global Constructors">Calling_Global_Constructors</a> article.
</p><p>Global objects must have their constructors called before they are used. Usually, they are called by the start-up code (which you just disabled). So, in order to be able to use them, you have to write your own start-up code for them. All objects have a constructor and a destructor. When an executable is loaded into memory and the program jumps straight to the entry point, the constructors of global objects will not have been called. One solution is to do this manually. You could put this code first when your C++ entry point is called:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1">	object1.<span class="me1">object1</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	object2.<span class="me1">object2</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	object3.<span class="me1">object3</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="co1">// ...</span></pre></div></div>
<p>Global or static objects have to be constructed by the environment before they are available to C++. Care should be taken if global/static objects need <b>new</b> and <b>delete</b> in their constructors. In this case it is best to construct these objects only after your kernel heap is ready for use (and you have access to dynamic memory allocation). Not doing so can cause an object to attempt to allocate memory via the non-working <b>new</b> operator. This also simplifies the storing of the destructor functions in <b>__cxa_atexit</b>, because you don't have to use a static and fixed-size structure.
</p>
<h3> <span class="mw-headline" id="GCC"> GCC </span></h3>
<p>Note: This appears to be specific to the Itanium platform. For IA-32/x86/i386 and amd64/x86_64, please check out <a href="/Calling_Global_Constructors" title="Calling Global Constructors">Calling_Global_Constructors</a> instead.
</p><p>According to the <a rel="nofollow" class="external text" href="http://refspecs.freestandards.org/LSB_3.1.0/LSB-Core-generic/LSB-Core-generic/baselib---cxa-atexit.html">Itanium C++ Application Binary Interface</a> (which <b>g++</b> follows and VC++ does not) the function <b>__cxa_atexit</b> is used to register a destructor that should be called when a shared library needs to be unloaded. It should insert a function pointer with maximum 1 accompanying argument and the handle of the object or shared resource to be destroyed into a table.
</p><p>In the example implementation of <b>__cxa_atexit</b>, the <b>__atexit_funcs[ATEXIT_MAX_FUNCS]</b> array acts as the table. This is why the <b>__cxa_atexit</b> function is defined as:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> __cxa_atexit<span class="br0">(</span><span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>destructor<span class="br0">)</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span>, <span class="kw4">void</span> <span class="sy2">*</span>arg, <span class="kw4">void</span> <span class="sy2">*</span>__dso_handle<span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<p>So that the <b>destructor</b> function pointer is the handle for a destructor function and <b>arg</b> is the single argument it may take. Finally, <b>__dso_handle</b> is a handle for the DSO (Dynamic Shared Object).
</p><p>So summarized, you are required to define two functions and one symbol in order to use global objects in your C++ files:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> <span class="sy2">*</span>__dso_handle<span class="sy4">;</span>
 
<span class="kw4">int</span> __cxa_atexit<span class="br0">(</span><span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>destructor<span class="br0">)</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span>, <span class="kw4">void</span> <span class="sy2">*</span>arg, <span class="kw4">void</span> <span class="sy2">*</span>dso<span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> __cxa_finalize<span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>f<span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<p>After you have called the objects constructor GCC automatically calls the function
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> __cxa_atexit<span class="br0">(</span><span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>destructor<span class="br0">)</span> <span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span>, <span class="kw4">void</span> <span class="sy2">*</span>arg, <span class="kw4">void</span> <span class="sy2">*</span>dso<span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<p>This function should save all three parameters and if successful return zero, on failure non-zero. When your kernel exits you should call <b>__cxa_finalize(0)</b>. According to the ABI specification, calling this with 0 as the parameter instead of the address of a function (to be called and removed from the list) causes <i>all</i> destructors in the list to be called and removed from the list.
</p><p>Since you will be calling this function from your Assembly source right after your kernel exits, you could use the following code:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="asm source-asm"><pre class="de1"><span class="co1">; This is NASM source, mind you.</span>
<span class="kw1">sub</span> <span class="kw3">esp</span><span class="sy0">,</span> <span class="nu0">4</span>
<span class="kw1">mov</span> <span class="br0">[</span><span class="kw3">esp</span><span class="br0">]</span><span class="sy0">,</span> <span class="kw5">dword</span> <span class="nu0">0x0</span>
 
<span class="kw1">call</span> __cxa_finalize
 
<span class="kw1">add</span> <span class="kw3">esp</span><span class="sy0">,</span> <span class="nu0">4</span></pre></div></div>
<p>The following is tested, working, fully commented source that gives a more detailed explanation than the source previously found here. It also highlights what improvements can be implemented and where they can be inserted. To use it, just include <b>icxxabi.h</b> in any <b>one</b> file of your C++ kernel source (preferably the file where your kernel's main statements begin). 
</p><p><b>File: icxxabi.h</b>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#ifndef _ICXXABI_H</span>
	<span class="co2">#define _ICXXABI_H</span>
 
	<span class="co2">#define ATEXIT_MAX_FUNCS	128</span>
 
	<span class="co2">#ifdef __cplusplus</span>
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="br0">{</span>
	<span class="co2">#endif</span>
 
<span class="kw4">typedef</span> <span class="kw4">unsigned</span> uarch_t<span class="sy4">;</span>
 
<span class="kw4">struct</span> atexit_func_entry_t
<span class="br0">{</span>
	<span class="coMULTI">/*
	* Each member is at least 4 bytes large. Such that each entry is 12bytes.
	* 128 * 12 = 1.5KB exact.
	**/</span>
	<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>destructor_func<span class="br0">)</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">void</span> <span class="sy2">*</span>obj_ptr<span class="sy4">;</span>
	<span class="kw4">void</span> <span class="sy2">*</span>dso_handle<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">int</span> __cxa_atexit<span class="br0">(</span><span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>f<span class="br0">)</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span>, <span class="kw4">void</span> <span class="sy2">*</span>objptr, <span class="kw4">void</span> <span class="sy2">*</span>dso<span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> __cxa_finalize<span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>f<span class="br0">)</span><span class="sy4">;</span>
 
	<span class="co2">#ifdef __cplusplus</span>
	<span class="br0">}</span><span class="sy4">;</span>
	<span class="co2">#endif</span>
 
<span class="co2">#endif</span></pre></div></div>
<p><br />
<b>File: icxxabi.cpp</b>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include "./icxxabi.h"</span>
 
	<span class="co2">#ifdef __cplusplus</span>
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="br0">{</span>
	<span class="co2">#endif</span>
 
atexit_func_entry_t __atexit_funcs<span class="br0">[</span>ATEXIT_MAX_FUNCS<span class="br0">]</span><span class="sy4">;</span>
uarch_t __atexit_func_count <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
 
<span class="kw4">void</span> <span class="sy2">*</span>__dso_handle <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> <span class="co1">//Attention! Optimally, you should remove the '= 0' part and define this in your asm script.</span>
 
<span class="kw4">int</span> __cxa_atexit<span class="br0">(</span><span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>f<span class="br0">)</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span>, <span class="kw4">void</span> <span class="sy2">*</span>objptr, <span class="kw4">void</span> <span class="sy2">*</span>dso<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>__atexit_func_count <span class="sy1">&gt;=</span> ATEXIT_MAX_FUNCS<span class="br0">)</span> <span class="br0">{</span><span class="kw1">return</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span><span class="br0">}</span><span class="sy4">;</span>
	__atexit_funcs<span class="br0">[</span>__atexit_func_count<span class="br0">]</span>.<span class="me1">destructor_func</span> <span class="sy1">=</span> f<span class="sy4">;</span>
	__atexit_funcs<span class="br0">[</span>__atexit_func_count<span class="br0">]</span>.<span class="me1">obj_ptr</span> <span class="sy1">=</span> objptr<span class="sy4">;</span>
	__atexit_funcs<span class="br0">[</span>__atexit_func_count<span class="br0">]</span>.<span class="me1">dso_handle</span> <span class="sy1">=</span> dso<span class="sy4">;</span>
	__atexit_func_count<span class="sy2">++</span><span class="sy4">;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span> <span class="coMULTI">/*I would prefer if functions returned 1 on success, but the ABI says...*/</span>
<span class="br0">}</span><span class="sy4">;</span>
 
<span class="kw4">void</span> __cxa_finalize<span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>f<span class="br0">)</span>
<span class="br0">{</span>
	uarch_t i <span class="sy1">=</span> __atexit_func_count<span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">(</span><span class="sy3">!</span>f<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="coMULTI">/*
		* According to the Itanium C++ ABI, if __cxa_finalize is called without a
		* function ptr, then it means that we should destroy EVERYTHING MUAHAHAHA!!
		*
		* TODO:
		* Note well, however, that deleting a function from here that contains a __dso_handle
		* means that one link to a shared object file has been terminated. In other words,
		* We should monitor this list (optional, of course), since it tells us how many links to 
		* an object file exist at runtime in a particular application. This can be used to tell 
		* when a shared object is no longer in use. It is one of many methods, however.
		**/</span>
		<span class="co1">//You may insert a prinf() here to tell you whether or not the function gets called. Testing</span>
		<span class="co1">//is CRITICAL!</span>
		<span class="kw1">while</span> <span class="br0">(</span>i<span class="sy2">--</span><span class="br0">)</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span>__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">destructor_func</span><span class="br0">)</span>
			<span class="br0">{</span>
				<span class="coMULTI">/* ^^^ That if statement is a safeguard...
				* To make sure we don't call any entries that have already been called and unset at runtime.
				* Those will contain a value of 0, and calling a function with value 0
				* will cause undefined behaviour. Remember that linear address 0, 
				* in a non-virtual address space (physical) contains the IVT and BDA.
				*
				* In a virtual environment, the kernel will receive a page fault, and then probably
				* map in some trash, or a blank page, or something stupid like that.
				* This will result in the processor executing trash, and...we don't want that.
				**/</span>
				<span class="br0">(</span><span class="sy2">*</span>__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">destructor_func</span><span class="br0">)</span><span class="br0">(</span>__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">obj_ptr</span><span class="br0">)</span><span class="sy4">;</span>
			<span class="br0">}</span><span class="sy4">;</span>
		<span class="br0">}</span><span class="sy4">;</span>
		<span class="kw1">return</span><span class="sy4">;</span>
	<span class="br0">}</span><span class="sy4">;</span>
 
	<span class="kw1">while</span> <span class="br0">(</span>i<span class="sy2">--</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="coMULTI">/*
		* The ABI states that multiple calls to the __cxa_finalize(destructor_func_ptr) function
		* should not destroy objects multiple times. Only one call is needed to eliminate multiple
		* entries with the same address.
		*
		* FIXME:
		* This presents the obvious problem: all destructors must be stored in the order they
		* were placed in the list. I.e: the last initialized object's destructor must be first
		* in the list of destructors to be called. But removing a destructor from the list at runtime
		* creates holes in the table with unfilled entries.
		* Remember that the insertion algorithm in __cxa_atexit simply inserts the next destructor
		* at the end of the table. So, we have holes with our current algorithm
		* This function should be modified to move all the destructors above the one currently
		* being called and removed one place down in the list, so as to cover up the hole.
		* Otherwise, whenever a destructor is called and removed, an entire space in the table is wasted.
		**/</span>
		<span class="kw1">if</span> <span class="br0">(</span>__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">destructor_func</span> <span class="sy1">==</span> f<span class="br0">)</span>
		<span class="br0">{</span>
			<span class="coMULTI">/* 
			* Note that in the next line, not every destructor function is a class destructor.
			* It is perfectly legal to register a non class destructor function as a simple cleanup
			* function to be called on program termination, in which case, it would not NEED an
			* object This pointer. A smart programmer may even take advantage of this and register
			* a C function in the table with the address of some structure containing data about
			* what to clean up on exit.
			* In the case of a function that takes no arguments, it will simply be ignore within the
			* function itself. No worries.
			**/</span>
			<span class="br0">(</span><span class="sy2">*</span>__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">destructor_func</span><span class="br0">)</span><span class="br0">(</span>__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">obj_ptr</span><span class="br0">)</span><span class="sy4">;</span>
			__atexit_funcs<span class="br0">[</span>i<span class="br0">]</span>.<span class="me1">destructor_func</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
 
			<span class="coMULTI">/*
			* Notice that we didn't decrement __atexit_func_count: this is because this algorithm
			* requires patching to deal with the FIXME outlined above.
			**/</span>
		<span class="br0">}</span><span class="sy4">;</span>
	<span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
 
	<span class="co2">#ifdef __cplusplus</span>
	<span class="br0">}</span><span class="sy4">;</span>
	<span class="co2">#endif</span></pre></div></div>
<h3> <span class="mw-headline" id="Visual_C.2B.2B"> Visual C++ </span></h3>
<dl><dd><i>Main article:</i> <a href="/Visual_Studio" title="Visual Studio">Visual Studio</a>
</dd></dl>
<p>Running constructors and destructors is covered in MSDN help and in the C runtime library sources. See <b>#pragma init_seg</b> on MSDN for more information.
</p><p>Basically what happens is that pointers to functions are placed in <b>.CRT$XIC, $XIL, $XIU</b> based on the value of <b>init_seg</b>. The linker then merges everything together in the <b>.CRT</b> section, in the order of the letters after the <b>$</b>. The pointers between the XIA (<b>xi_a</b>) and XIZ (<b>xi_z</b>) are then called if non-zero. The <b>.CRT</b> section is merged with the <b>.data</b> section to avoid a completely separated section.
</p><p>One problem with C++ support is the horrible name-mangling that is impossible to read in the map file. A build script should be set up that runs the map file through the <b>undname.exe</b> tool, so that names like <b>??2@YAPAXI@Z</b> (operator new - I think...) and others are readable.
</p><p>Below you will find some example code. Simply call <b>runInit()</b> if you want to initialize any static objects and then call <b>runTerm()</b> if static object destructors are to be run.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>_PVFV<span class="br0">)</span><span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">typedef</span> <span class="kw4">int</span>  <span class="br0">(</span><span class="sy2">*</span>_PIFV<span class="br0">)</span><span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">typedef</span> <span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>_PVFI<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
 
<span class="co2">#pragma data_seg(".CRT$XIA")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XIA"</span><span class="br0">)</span><span class="br0">)</span> _PIFV __xi_a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XIZ")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XIZ"</span><span class="br0">)</span><span class="br0">)</span> _PIFV __xi_z<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XCA")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XCA"</span><span class="br0">)</span><span class="br0">)</span> _PVFV __xc_a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XCZ")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XCZ"</span><span class="br0">)</span><span class="br0">)</span> _PVFV __xc_z<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XPA")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XPA"</span><span class="br0">)</span><span class="br0">)</span> _PVFV __xp_a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XPZ")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XPZ"</span><span class="br0">)</span><span class="br0">)</span> _PVFV __xp_z<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XTA")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XTA"</span><span class="br0">)</span><span class="br0">)</span> _PVFV __xt_a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg(".CRT$XTZ")</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XTZ"</span><span class="br0">)</span><span class="br0">)</span> _PVFV __xt_z<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co2">#pragma data_seg()</span>
<span class="co2">#pragma comment(linker, "/merge:.CRT=.data")</span>
 
<span class="kw4">static</span> _PVFV onexitarray<span class="br0">[</span><span class="nu0">32</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">static</span> _PVFV <span class="sy2">*</span>onexitbegin, <span class="sy2">*</span>onexitend<span class="sy4">;</span>
 
<span class="kw4">int</span> __cdecl _purecall<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        <span class="co1">// print error message</span>
<span class="br0">}</span>
 
<span class="kw4">int</span> __cdecl <span class="kw3">atexit</span><span class="br0">(</span>_PVFV fn<span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span><span class="nu0">32</span><span class="sy2">*</span><span class="nu0">4</span> <span class="sy1">&lt;</span> <span class="br0">(</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>onexitend<span class="sy2">-</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span>onexitbegin<span class="br0">)</span><span class="sy2">+</span><span class="nu0">4</span><span class="br0">)</span>
                <span class="kw1">return</span> <span class="nu0">1</span><span class="sy4">;</span>
        <span class="kw1">else</span>
                <span class="sy2">*</span><span class="br0">(</span>onexitend<span class="sy2">++</span><span class="br0">)</span> <span class="sy1">=</span> fn<span class="sy4">;</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span>
 
EXTERN <span class="kw4">int</span> runInit<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        <span class="co1">// init the __xi_a to __xi_z:  __initex(__xi_a, __xi_z);</span>
        <span class="co1">// init __xc_a to __xc_z</span>
<span class="br0">}</span>
 
<span class="kw4">static</span> <span class="kw4">void</span> __init<span class="br0">(</span>_PVFV <span class="sy2">*</span>pfbegin, _PVFV <span class="sy2">*</span>pfend<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">while</span> <span class="br0">(</span>pfbegin <span class="sy1">&lt;</span> pfend<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span><span class="sy2">*</span>pfbegin <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span>
            <span class="br0">(</span><span class="sy2">**</span>pfbegin<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
        <span class="sy2">++</span>pfbegin<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw4">static</span> <span class="kw4">int</span> __initex<span class="br0">(</span>_PIFV <span class="sy2">*</span>pfbegin, _PIFV <span class="sy2">*</span>pfend<span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw4">int</span> ret <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
 
        <span class="kw1">while</span> <span class="br0">(</span>pfbegin <span class="sy1">&lt;</span> pfend <span class="sy3">&amp;&amp;</span> ret <span class="sy1">==</span> <span class="nu0">0</span><span class="br0">)</span>
        <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span><span class="sy2">*</span>pfbegin <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span>
                ret <span class="sy1">=</span> <span class="br0">(</span><span class="sy2">**</span>pfbegin<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
            <span class="sy2">++</span>pfbegin<span class="sy4">;</span>
        <span class="br0">}</span>
 
        <span class="kw1">return</span> ret<span class="sy4">;</span>
<span class="br0">}</span>
 
EXTERN <span class="kw4">void</span> runUninit<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>onexitbegin<span class="br0">)</span>
        <span class="br0">{</span>
                <span class="kw1">while</span> <span class="br0">(</span><span class="sy2">--</span>onexitend <span class="sy1">&gt;=</span> onexitbegin<span class="br0">)</span>
                        <span class="kw1">if</span> <span class="br0">(</span><span class="sy2">*</span>onexitend <span class="sy3">!</span><span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span>
                                <span class="br0">(</span><span class="sy2">**</span>onexitend<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
        __init<span class="br0">(</span>__xp_a, __xp_z<span class="br0">)</span><span class="sy4">;</span>
        __init<span class="br0">(</span>__xt_a, __xt_z<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
EXTERN <span class="kw4">int</span> onexitinit<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
        onexitend <span class="sy1">=</span> onexitbegin <span class="sy1">=</span> onexitarray<span class="sy4">;</span>
        <span class="sy2">*</span>onexitbegin <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
        <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="co2">#pragma data_seg(".CRT$XIB")      // run onexitinit automatically</span>
__declspec<span class="br0">(</span>allocate<span class="br0">(</span><span class="st0">".CRT$XIB"</span><span class="br0">)</span><span class="br0">)</span> <span class="kw4">static</span> _PIFV pinit <span class="sy1">=</span> onexitinit<span class="sy4">;</span>
<span class="co2">#pragma data_seg()</span></pre></div></div>
<h2> <span class="mw-headline" id="Local_Static_Variables_.28GCC_Only.29"> Local Static Variables (GCC Only) </span></h2>
<p>When you declare a local static variable, GCC puts a guard around the variable's constructor call. This ensures that only one thread can call the constructor at the same time to initialize it.
</p><p><i>Note that these are only stubs to get the code compiled, and you should implement them yourself. Simply add a mutex-like guard with a test-and-set primitive.</i>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw2">namespace</span> __cxxabiv1 
<span class="br0">{</span>
	<span class="coMULTI">/* guard variables */</span>
 
	<span class="coMULTI">/* The ABI requires a 64-bit type.  */</span>
	__extension__ <span class="kw4">typedef</span> <span class="kw4">int</span> __guard __attribute__<span class="br0">(</span><span class="br0">(</span>mode<span class="br0">(</span>__DI__<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
 
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">int</span> __cxa_guard_acquire <span class="br0">(</span>__guard <span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">void</span> __cxa_guard_release <span class="br0">(</span>__guard <span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">void</span> __cxa_guard_abort <span class="br0">(</span>__guard <span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
 
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">int</span> __cxa_guard_acquire <span class="br0">(</span>__guard <span class="sy2">*</span>g<span class="br0">)</span> 
	<span class="br0">{</span>
		<span class="kw1">return</span> <span class="sy3">!</span><span class="sy2">*</span><span class="br0">(</span><span class="kw4">char</span> <span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span>g<span class="br0">)</span><span class="sy4">;</span>
	<span class="br0">}</span>
 
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">void</span> __cxa_guard_release <span class="br0">(</span>__guard <span class="sy2">*</span>g<span class="br0">)</span>
	<span class="br0">{</span>
		<span class="sy2">*</span><span class="br0">(</span><span class="kw4">char</span> <span class="sy2">*</span><span class="br0">)</span>g <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
	<span class="br0">}</span>
 
	<span class="kw4">extern</span> <span class="st0">"C"</span> <span class="kw4">void</span> __cxa_guard_abort <span class="br0">(</span>__guard <span class="sy2">*</span><span class="br0">)</span>
	<span class="br0">{</span>
 
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<p>The actual code emitted by GCC to call a local static variable's constructor looks something like this:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">static</span> <span class="sy1">&lt;</span>type<span class="sy1">&gt;</span> guard<span class="sy4">;</span>
 
<span class="kw1">if</span> <span class="br0">(</span><span class="sy3">!</span>guard.<span class="me1">first_byte</span><span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span> <span class="br0">(</span>__cxa_guard_acquire <span class="br0">(</span><span class="sy3">&amp;</span>guard<span class="br0">)</span><span class="br0">)</span>
	<span class="br0">{</span>
		<span class="kw4">bool</span> flag <span class="sy1">=</span> <span class="kw2">false</span><span class="sy4">;</span>
 
		<span class="kw2">try</span>
		<span class="br0">{</span>
			<span class="co1">// Do initialization.</span>
			__cxa_guard_release <span class="br0">(</span><span class="sy3">&amp;</span>guard<span class="br0">)</span><span class="sy4">;</span>
 
			flag <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
			<span class="co1">// Register variable for destruction at end of program.</span>
		<span class="br0">}</span>
 
		<span class="kw2">catch</span>
		<span class="br0">{</span>
			<span class="kw1">if</span> <span class="br0">(</span><span class="sy3">!</span>flag<span class="br0">)</span>
			<span class="br0">{</span>
				__cxa_guard_abort <span class="br0">(</span><span class="sy3">&amp;</span>guard<span class="br0">)</span><span class="sy4">;</span>
			<span class="br0">}</span>
		<span class="br0">}</span>
	<span class="br0">}</span>
<span class="br0">}</span></pre></div></div>
<h2> <span class="mw-headline" id="The_Operators_.27new.27_and_.27delete.27"> The Operators 'new' and 'delete' </span></h2>
<p>Before you can properly use <b>new</b> and <b>delete</b>, you have to implement some sort of memory management. You also have to implement both operators (including their array counterparts). <b>new</b> and <b>delete</b> respectively allocate and delete memory (much like <b>malloc</b> and <b>free</b> in C). Take a look at the <a href="/Memory_Management" title="Memory Management" class="mw-redirect">Memory Management</a> article if you would like to know more about this subject.
</p><p>Every time you call one of the operators <b>new</b>, <b>new[]</b>, <b>delete</b>, or <b>delete[]</b>, the compiler inserts a call to them. The most simple implementation would be to map them to your kernel's <b>malloc</b> and <b>free</b>. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;stddef.h&gt;</span>
 
<span class="kw4">void</span> <span class="sy2">*</span>operator <span class="kw3">new</span><span class="br0">(</span><span class="kw4">size_t</span> size<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="kw3">malloc</span><span class="br0">(</span>size<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> <span class="sy2">*</span>operator <span class="kw3">new</span><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">size_t</span> size<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> <span class="kw3">malloc</span><span class="br0">(</span>size<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> operator <span class="kw3">delete</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>p<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw3">free</span><span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
 
<span class="kw4">void</span> operator <span class="kw3">delete</span><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>p<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw3">free</span><span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>You could also let <b>new</b> use <b>calloc</b> (allocate and zero). This way, newly allocated memory will always be zeroed (thus, not contain garbage). The standard <b>new</b> implementations do however not clear the returned memory.
</p><p>An easy malloc implementation you can port to your OS is <a rel="nofollow" class="external text" href="https://github.com/blanham/liballoc/">liballoc</a>. It only requires basic <a href="/Paging" title="Paging">Paging</a> (that is, store a list of used and free pages, and have a function to find the next free page) to work.
</p>
<h3> <span class="mw-headline" id="Placement_New"> Placement New </span></h3>
<p>In C++ (especially in OS code where structures can be found at fixed addresses) it can be useful to construct an object in memory obtained elsewhere. This is accomplished through a technique known as 'placement new'. For example, say you wanted to create an APIC object at address <b>0x09FFF0000</b>, then this snippet of code will use placement new to do the trick:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> <span class="sy2">*</span>apic_address <span class="sy1">=</span> <span class="kw2">reinterpret_cast</span><span class="sy1">&lt;</span><span class="kw4">void</span> <span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="nu12">0x09FFF0000</span><span class="br0">)</span><span class="sy4">;</span>
APIC <span class="sy2">*</span>apic <span class="sy1">=</span> <span class="kw3">new</span> <span class="br0">(</span>apic_address<span class="br0">)</span> APIC<span class="sy4">;</span></pre></div></div>
<p>In order to use placement new, you need special overloads of the new and delete operators defined in scope. Fortunately, the required definitions are simple and can be inlined in a header file (the C++ standard puts them in a header called <b>new</b>).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw2">inline</span> <span class="kw4">void</span> <span class="sy2">*</span>operator <span class="kw3">new</span><span class="br0">(</span><span class="kw4">size_t</span>, <span class="kw4">void</span> <span class="sy2">*</span>p<span class="br0">)</span>     <span class="kw1">throw</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> p<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw2">inline</span> <span class="kw4">void</span> <span class="sy2">*</span>operator <span class="kw3">new</span><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">size_t</span>, <span class="kw4">void</span> <span class="sy2">*</span>p<span class="br0">)</span>   <span class="kw1">throw</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> p<span class="sy4">;</span> <span class="br0">}</span>
<span class="kw2">inline</span> <span class="kw4">void</span>  operator <span class="kw3">delete</span>  <span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>, <span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span> <span class="kw1">throw</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw2">inline</span> <span class="kw4">void</span>  operator <span class="kw3">delete</span><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span><span class="kw4">void</span> <span class="sy2">*</span>, <span class="kw4">void</span> <span class="sy2">*</span><span class="br0">)</span> <span class="kw1">throw</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>The above implementation can potentially be unsafe for allocating memory since your kernel does not mark the memory that was allocated as being used. Placement new is hardly ever used, and if you wish to read an object from a specified address in memory, it is usually easier to create a pointer to that address.
</p><p>You never call placement delete explicitly (it's only required for certain implementation detail reasons). Instead, you simply invoke your object's destructor explicitly.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1">apic<span class="sy2">-</span><span class="sy1">&gt;</span>~APIC<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<h2> <span class="mw-headline" id="RTTI_.28Run-Time_Type_Information.29"> RTTI (Run-Time Type Information) </span></h2>
<p>RTTI is used for <b>typeid</b> and <b>dynamic_cast</b>. It requires runtime support as well. Disable it with <b>-fno-rtti</b>. A kernel has no access to run-time features, which are most likely operating system-dependent. Note that virtual functions work without RTTI.
</p>
<h2> <span class="mw-headline" id="Exceptions"> Exceptions </span></h2>
<p>Another feature that requires run-time support. Disable it with <b>-fno-exceptions</b>. Exceptions require code to unwind the stack while looking for an appropriate exception handler to handle the exception. Usually, this code is linked in with your C++ application, but in a freestanding kernel the code must be provided manually.
</p><p>See <a href="/C%2B%2B_Exception_Support" title="C++ Exception Support">C++ Exception Support</a>.
</p>
<h2> <span class="mw-headline" id="Standard_Library"> Standard Library </span></h2>
<p>Note that the C++ Standard Library (stdlib) is not the same as the C++ Standard Template Library (STL). The STL was designed in 1994 and largely influenced the C++ Standard Library, but it's not a part of the ISO C++ standard. The C++ Standard Library is part of the C++ ISO specification, however, and is what you're using when you use <i>std::vector</i>, <i>std::string</i>, etc. Be wary of misusing the term STL and, ideally, avoid it completely. Anyone using it almost certainly means the C++ stdlib.
</p><p>You cannot use stdlib functions or classes without porting a stdlib implementation. A lot of existing code depending on the stdlib is OS-dependent, so you must port an stdlib implementation to your OS if you want to use them.
</p><p>To gain access to the stdlib in your OS you can do either of the following:
</p>
<ul><li> Write your own implementation of a few of the required class templates (std::string, std::list, std::cout, ...).
</li><li> Port a stdlib implementation to your OS (e.g. <a href="/index.php?title=STLport&amp;action=edit&amp;redlink=1" class="new" title="STLport (page does not exist)">STLport</a>).
</li></ul>
<p>A lot of the stdlib classes require <b>new</b> and <b>delete</b> to be implemented in your OS. File access requires your OS to support reading and wrapping. Console functions require your OS to already have working console I/O.
</p><p>Porting the C++ stdlib (like porting the <a href="/C_Library" title="C Library">C Standard Library</a>) does not automatically make your OS able to read from and write to the disk or get data straight from the keyboard. These are simply wrappers around your OS' functions, and must be implemented by in your kernel.
</p><p>Note that it is generally not a good idea to port the entire stdlib to your kernel, although it is reasonable to port a few class templates, such as <tt>std::vector</tt> and <tt>std::string</tt> if you wish to. As for your user applications: the more the merrier! :)
</p><p>Here is a list of a the most commonly used stdlib implementations:
</p>
<ul><li> <a rel="nofollow" class="external text" href="http://incubator.apache.org/stdcxx/">STDCXX</a> (a.k.a Apache C++ Standard Library, formally Rogue Wave C++ Standard Library)
</li><li> <a rel="nofollow" class="external text" href="https://www.dinkumware.com/">Dinkumware C++ Standard Library</a>
</li><li> <a rel="nofollow" class="external text" href="http://msdn2.microsoft.com/en-us/library/cscc687y%28VS.80%29.aspx">Microsoft C++ Standard Library</a> (closed source)
</li><li> <a rel="nofollow" class="external text" href="http://gcc.gnu.org/libstdc++/">libstdc++</a> (a.k.a. GNU Standard C++ Library)
</li><li> <a rel="nofollow" class="external text" href="http://www.stlport.org/">STLport</a>
</li><li> <a rel="nofollow" class="external text" href="http://ustl.sourceforge.net/">uSTL</a>
</li><li> <a rel="nofollow" class="external text" href="http://libcxx.llvm.org/">libc++</a> (LLVM C++ Standard library)
</li></ul>
<h2> <span class="mw-headline" id="Full_C.2B.2B_Runtime_Support_Using_libgcc_And_libsupc.2B.2B"> Full C++ Runtime Support Using libgcc And libsupc++ </span></h2>
<dl><dd><i>Main article:</i> <a href="/Libsupcxx#Full_C.2B.2B_Runtime_Support_Using_libgcc_And_libsupc.2B.2B" title="Libsupcxx">Libsupcxx#Full C++ Runtime Support Using libgcc And libsupc++</a>
</dd></dl>
<p>If you want Exceptions, RTTI, new and delete altogether, you should use <a href="/Libgcc" title="Libgcc">libgcc</a> and libsupc++. libgcc contains the unwinder (for exceptions), while libsupc++ contains the C++ support.
</p><p>You may run into problems with libsupc++, but there are <a href="/GCC_and_Libc%2B%2B" title="GCC and Libc++">alternative libraries</a>.
</p>
<h2> <span class="mw-headline" id="Optimizations"> Optimizations </span></h2>
<p>There are <a href="/C#Things_you_should_know_about_optimizations" title="C">things you should know about optimizations</a> that also affect C++ because it is an extension of the <a href="/C" title="C">C</a> language. You should know about them even if you don't plan to to use the optimizer of your C++ compiler in the near future.
</p>
<h2> <span class="mw-headline" id="Links"> Links </span></h2>
<h3> <span class="mw-headline" id="Wiki"> Wiki </span></h3>
<ul><li> <a href="/Bare_Bones" title="Bare Bones">Bare Bones</a>
</li><li> <a href="/Volatile_(keyword)" title="Volatile (keyword)">Use of the volatile keyword</a>
</li><li> <a href="/C%2B%2B_to_ASM_linkage_in_GCC" title="C++ to ASM linkage in GCC">Linking C++ and Assembly (GCC-specific)</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 263/1000000
Post-expand include size: 478/2097152 bytes
Template argument size: 74/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1528-0!*!0!!en!2!* and timestamp 20221210035834 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="https://wiki.osdev.org/index.php?title=C%2B%2B&amp;oldid=24639">https://wiki.osdev.org/index.php?title=C%2B%2B&amp;oldid=24639</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks"><a href="/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/Category:In_Progress" title="Category:In Progress">In Progress</a></li><li><a href="/Category:Languages" title="Category:Languages">Languages</a></li><li><a href="/Category:C%2B%2B" title="Category:C++">C++</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="/index.php?title=Special:UserLogin&amp;returnto=C%2B%2B" title="You are encouraged to log in; however, it is not mandatory [alt-o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="/C%2B%2B" title="View the content page [alt-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk" class="new"><span><a href="/index.php?title=Talk:C%2B%2B&amp;action=edit&amp;redlink=1" title="Discussion about the content page [alt-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="/C%2B%2B">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="/index.php?title=C%2B%2B&amp;action=edit" title="This page is protected.&#10;You can view its source [alt-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="/index.php?title=C%2B%2B&amp;action=history" title="Past revisions of this page [alt-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/index.php" id="searchform">
		<input type="hidden" name="title" value="Special:Search" />
				<input type="search" name="search" title="Search OSDev Wiki [alt-f]" accesskey="f" id="searchInput" />		<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />		<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/skins/common/images/osdev.png);" href="/Main_Page" title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id="p-navigation">
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="/Main_Page" title="Visit the main page [alt-z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="/Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="/Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="/Special:Random" title="Load a random page [alt-x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id="p-about">
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="/OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="/OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="/OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="/Special:RecentChanges" title="A list of recent changes in the wiki [alt-r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="/Special:WhatLinksHere/C%2B%2B" title="A list of all wiki pages that link here [alt-j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="/Special:RecentChangesLinked/C%2B%2B" title="Recent changes in pages linked from this page [alt-k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="/Special:SpecialPages" title="A list of all special pages [alt-q]" accesskey="q">Special pages</a></li>
			<li><a href="/index.php?title=C%2B%2B&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="/index.php?title=C%2B%2B&amp;oldid=24639" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" id="p-lang">
	<h5>In other languages</h5>
	<div class="body">
		<ul>
			<li class="interwiki-de"><a href="http://www.lowlevel.eu/wiki/C%2B%2B" title="C++">Deutsch</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 28 April 2020, at 11:38.</li>
											<li id="footer-info-viewcount">This page has been accessed 234,331 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="/OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="/OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="/OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<script src="/load.php?debug=false&amp;lang=en&amp;modules=skins.vector&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax"]);
}
</script><script type="text/javascript" src="/load.php?debug=false&amp;lang=en&amp;modules=jquery.checkboxShiftClick%2Ccookie%2CmakeCollapsible%2CmessageBox%2CmwPrototypes%2Cplaceholder%7Cmediawiki.language%2Cuser%2Cutil%7Cmediawiki.legacy.ajax%2Cwikibits%7Cmediawiki.page.ready&amp;skin=vector&amp;version=20201205T093005Z&amp;*"></script>
<script src="/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=vector&amp;*"></script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: wikidb:resourceloader:filter:minify-js:4:19a4b18a9ac79a6b8c60b24af4668814 */
}
</script><!-- Served in 0.187 secs. -->
	

</body></html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>离散傅立叶变换 — OpenCV 2.3.2 documentation</title>
    
    <link rel="stylesheet" href="../../../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '2.3.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../../../../_static/insertIframe.js"></script>
    <link rel="top" title="OpenCV 2.3.2 documentation" href="../../../../index.html" />
    <link rel="up" title="core 模块. 核心功能" href="../table_of_content_core/table_of_content_core.html" />
    <link rel="next" title="输入输出XML和YAML文件" href="../file_input_output_with_xml_yml/file_input_output_with_xml_yml.html" />
    <link rel="prev" title="随机数发生器&amp;绘制文字" href="../random_generator_and_text/random_generator_and_text.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index" accesskey="I">index</a></li>
        <li class="right">
          <a href="../file_input_output_with_xml_yml/file_input_output_with_xml_yml.html" title="输入输出XML和YAML文件" accesskey="N">next</a> |</li>
        <li class="right">
          <a href="../random_generator_and_text/random_generator_and_text.html" title="随机数发生器&amp;绘制文字" accesskey="P">previous</a> |</li>
        <li><a href="../../../../index.html">OpenCV 2.3.2 documentation</a> »</li>
          <li><a href="../../tutorials.html">OpenCV 教程</a> »</li>
          <li><a href="../table_of_content_core/table_of_content_core.html" accesskey="U"><em>core</em> 模块. 核心功能</a> »</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="discretfouriertransform">
<span id="id1"></span><h1>离散傅立叶变换<a class="headerlink" href="#discretfouriertransform" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>目标<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>本文档尝试解答如下问题：</p>
<div class="enumeratevisibleitemswithsquare container">
<ul class="simple">
<li>什么是傅立叶变换及其应用?</li>
<li>如何使用OpenCV提供的傅立叶变换?</li>
<li>相关函数的使用，如： <a class="reference external" href="http://opencv.itseez.com/modules/imgproc/doc/filtering.html#copymakeborder">copyMakeBorder()</a>, <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#merge">merge()</a>, <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#dft">dft()</a>, <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#getoptimaldftsize">getOptimalDFTSize()</a>, <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#log">log()</a> 和 <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#normalize">normalize()</a> .</li>
</ul>
</div>
</div>
<div class="section" id="id3">
<h2>源码<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>你可以 <a class="reference download internal" href="../../../../_downloads/discrete_fourier_transform.cpp"><tt class="xref download docutils literal"><span class="pre">从此处下载源码</span></tt></a> 或者通过OpenCV源码库文件 <tt class="file docutils literal"><span class="pre">samples/cpp/tutorial_code/core/discrete_fourier_transform/discrete_fourier_transform.cpp</span></tt> 查看.</p>
<p>以下为函数 <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#dft">dft()</a>  使用范例:</p>
<div class="highlight-cpp"><table class="highlighttable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include "opencv2/core/core.hpp"</span>
<span class="cp">#include "opencv2/imgproc/imgproc.hpp"</span>
<span class="cp">#include "opencv2/highgui/highgui.hpp"</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">argc</span> <span class="o">&gt;=</span><span class="mi">2</span> <span class="o">?</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="s">"lena.jpg"</span><span class="p">;</span>

    <span class="n">Mat</span> <span class="n">I</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">CV_LOAD_IMAGE_GRAYSCALE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">I</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    
    <span class="n">Mat</span> <span class="n">padded</span><span class="p">;</span>                            <span class="c1">//expand input image to optimal size</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">getOptimalDFTSize</span><span class="p">(</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span> <span class="p">);</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getOptimalDFTSize</span><span class="p">(</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span> <span class="p">);</span> <span class="c1">// on the border add zero values</span>
    <span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">padded</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="n">Mat</span> <span class="n">planes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">padded</span><span class="p">),</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">CV_32F</span><span class="p">)};</span>
    <span class="n">Mat</span> <span class="n">complexI</span><span class="p">;</span>
    <span class="n">merge</span><span class="p">(</span><span class="n">planes</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">complexI</span><span class="p">);</span>         <span class="c1">// Add to the expanded another plane with zeros</span>

    <span class="n">dft</span><span class="p">(</span><span class="n">complexI</span><span class="p">,</span> <span class="n">complexI</span><span class="p">);</span>            <span class="c1">// this way the result may fit in the source matrix</span>

    <span class="c1">// compute the magnitude and switch to logarithmic scale</span>
    <span class="c1">// =&gt; log(1 + sqrt(Re(DFT(I))^2 + Im(DFT(I))^2))</span>
    <span class="n">split</span><span class="p">(</span><span class="n">complexI</span><span class="p">,</span> <span class="n">planes</span><span class="p">);</span>                   <span class="c1">// planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))</span>
    <span class="n">magnitude</span><span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="c1">// planes[0] = magnitude  </span>
    <span class="n">Mat</span> <span class="n">magI</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    
    <span class="n">magI</span> <span class="o">+=</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                    <span class="c1">// switch to logarithmic scale</span>
    <span class="n">log</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">magI</span><span class="p">);</span>

    <span class="c1">// crop the spectrum, if it has an odd number of rows or columns</span>
    <span class="n">magI</span> <span class="o">=</span> <span class="n">magI</span><span class="p">(</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">magI</span><span class="p">.</span><span class="n">cols</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">magI</span><span class="p">.</span><span class="n">rows</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">2</span><span class="p">));</span>

    <span class="c1">// rearrange the quadrants of Fourier image  so that the origin is at the image center        </span>
    <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">magI</span><span class="p">.</span><span class="n">cols</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">magI</span><span class="p">.</span><span class="n">rows</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

    <span class="n">Mat</span> <span class="n">q0</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>   <span class="c1">// Top-Left - Create a ROI per quadrant </span>
    <span class="n">Mat</span> <span class="n">q1</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>  <span class="c1">// Top-Right</span>
    <span class="n">Mat</span> <span class="n">q2</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>  <span class="c1">// Bottom-Left</span>
    <span class="n">Mat</span> <span class="n">q3</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span> <span class="c1">// Bottom-Right</span>

    <span class="n">Mat</span> <span class="n">tmp</span><span class="p">;</span>                           <span class="c1">// swap quadrants (Top-Left with Bottom-Right)</span>
    <span class="n">q0</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="n">q3</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q0</span><span class="p">);</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q3</span><span class="p">);</span>

    <span class="n">q1</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>                    <span class="c1">// swap quadrant (Top-Right with Bottom-Left)</span>
    <span class="n">q2</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q2</span><span class="p">);</span>

    <span class="n">normalize</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">magI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CV_MINMAX</span><span class="p">);</span> <span class="c1">// Transform the matrix with float values into a </span>
                                            <span class="c1">// viewable image form (float between values 0 and 1).</span>

    <span class="n">imshow</span><span class="p">(</span><span class="s">"Input Image"</span>       <span class="p">,</span> <span class="n">I</span>   <span class="p">);</span>    <span class="c1">// Show the result</span>
    <span class="n">imshow</span><span class="p">(</span><span class="s">"spectrum magnitude"</span><span class="p">,</span> <span class="n">magI</span><span class="p">);</span>    
    <span class="n">waitKey</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div>
</div>
<div class="section" id="id4">
<h2>原理<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>对一张图像使用傅立叶变换就是将它分解成正弦和余弦两部分。也就是将图像从空间域(spatial domain)转换到频域(frequency domain)。 这一转换的理论基础来自于以下事实：任一函数都可以表示成无数个正弦和余弦函数的和的形式。傅立叶变换就是一个用来将函数分解的工具。 2维图像的傅立叶变换可以用以下数学公式表达:</p>
<div class="math">
<p><img src="../../../../_images/math/01858ba01f19b01dc0e6a829755aae109a25f741.png" alt="F(k,l) = \displaystyle\sum\limits_{i=0}^{N-1}\sum\limits_{j=0}^{N-1} f(i,j)e^{-i2\pi(\frac{ki}{N}+\frac{lj}{N})}&#10;&#10;e^{ix} = \cos{x} + i\sin {x}" /></p>
</div><p>式中 f 是空间域(spatial domain)值， F 则是频域(frequency domain)值。  转换之后的频域值是复数， 因此，显示傅立叶变换之后的结果需要使用实数图像(real image) 加虚数图像(complex image), 或者幅度图像(magitude image)加相位图像(phase image)。 在实际的图像处理过程中，仅仅使用了幅度图像，因为幅度图像包含了原图像的几乎所有我们需要的几何信息。 然而，如果你想通过修改幅度图像或者相位图像的方法来间接修改原空间图像，你需要使用逆傅立叶变换得到修改后的空间图像，这样你就必须同时保留幅度图像和相位图像了。</p>
<p>在此示例中，我将展示如何计算以及显示傅立叶变换后的幅度图像。由于数字图像的离散性，像素值的取值范围也是有限的。比如在一张灰度图像中，像素灰度值一般在0到255之间。 因此，我们这里讨论的也仅仅是离散傅立叶变换(<em>DFT</em>)。 如果你需要得到图像中的几何结构信息，那你就要用到它了。请参考以下步骤(假设输入图像为单通道的灰度图像 <em>I</em>):</p>
<ol class="arabic">
<li><p class="first"><strong>将图像延扩到最佳尺寸</strong>. 离散傅立叶变换的运行速度与图片的尺寸息息相关。当图像的尺寸是2， 3，5的整数倍时，计算速度最快。 因此，为了达到快速计算的目的，经常通过添凑新的边缘像素的方法获取最佳图像尺寸。函数 <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#getoptimaldftsize">getOptimalDFTSize()</a> 返回最佳尺寸，而函数 <a class="reference external" href="http://opencv.itseez.com/modules/imgproc/doc/filtering.html#copymakeborder">copyMakeBorder()</a> 填充边缘像素:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">padded</span><span class="p">;</span>                            <span class="c1">//将输入图像延扩到最佳的尺寸</span>
<span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">getOptimalDFTSize</span><span class="p">(</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span> <span class="p">);</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">getOptimalDFTSize</span><span class="p">(</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span> <span class="p">);</span> <span class="c1">// 在边缘添加0</span>
<span class="n">copyMakeBorder</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">padded</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">I</span><span class="p">.</span><span class="n">rows</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">I</span><span class="p">.</span><span class="n">cols</span><span class="p">,</span> <span class="n">BORDER_CONSTANT</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</pre></div>
</div>
<p>添加的像素初始化为0.</p>
</li>
<li><p class="first"><strong>为傅立叶变换的结果(实部和虚部)分配存储空间</strong>. 傅立叶变换的结果是复数，这就是说对于每个原图像值，结果是两个图像值。 此外，频域值范围远远超过空间值范围， 因此至少要将频域储存在 <em>float</em> 格式中。 结果我们将输入图像转换成浮点类型，并多加一个额外通道来储存复数部分：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">Mat</span> <span class="n">planes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">Mat_</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">padded</span><span class="p">),</span> <span class="n">Mat</span><span class="o">::</span><span class="n">zeros</span><span class="p">(</span><span class="n">padded</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">CV_32F</span><span class="p">)};</span>
<span class="n">Mat</span> <span class="n">complexI</span><span class="p">;</span>
<span class="n">merge</span><span class="p">(</span><span class="n">planes</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">complexI</span><span class="p">);</span>         <span class="c1">// 为延扩后的图像增添一个初始化为0的通道</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>进行离散傅立叶变换</strong>. 支持图像原地计算 (输入输出为同一图像):</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">dft</span><span class="p">(</span><span class="n">complexI</span><span class="p">,</span> <span class="n">complexI</span><span class="p">);</span>            <span class="c1">// 变换结果很好的保存在原始矩阵中</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>将复数转换为幅度</strong>.复数包含实数部分(<em>Re</em>)和复数部分 (imaginary - <em>Im</em>)。 离散傅立叶变换的结果是复数，对应的幅度可以表示为:</p>
<div class="math">
<p><img src="../../../../_images/math/6c1cb9937a9552acbd5675c7fefc0f17da665709.png" alt="M = \sqrt[2]{ {Re(DFT(I))}^2 + {Im(DFT(I))}^2}" /></p>
</div></li>
</ol>
<blockquote>
<div><p>转化为OpenCV代码:</p>
<blockquote>
<div><div class="highlight-cpp"><div class="highlight"><pre><span class="n">split</span><span class="p">(</span><span class="n">complexI</span><span class="p">,</span> <span class="n">planes</span><span class="p">);</span>                   <span class="c1">// planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))</span>
<span class="n">magnitude</span><span class="p">(</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">planes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="c1">// planes[0] = magnitude</span>
<span class="n">Mat</span> <span class="n">magI</span> <span class="o">=</span> <span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
</div></blockquote>
</div></blockquote>
<ol class="arabic" start="5">
<li><p class="first"><strong>对数尺度(logarithmic scale)缩放</strong>. 傅立叶变换的幅度值范围大到不适合在屏幕上显示。高值在屏幕上显示为白点，而低值为黑点，高低值的变化无法有效分辨。为了在屏幕上凸显出高低变化的连续性，我们可以用对数尺度来替换线性尺度:</p>
<div class="math">
<p><img src="../../../../_images/math/e0e67facfc3d5ec66d7031823c3a2369671b82d2.png" alt="M_1 = \log{(1 + M)}" /></p>
</div><p>转化为OpenCV代码:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">magI</span> <span class="o">+=</span> <span class="n">Scalar</span><span class="o">::</span><span class="n">all</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>                    <span class="c1">// 转换到对数尺度</span>
<span class="n">log</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">magI</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>剪切和重分布幅度图象限</strong>. 还记得我们在第一步时延扩了图像吗? 那现在是时候将新添加的像素剔除了。为了方便显示，我们也可以重新分布幅度图象限位置(注：将第五步得到的幅度图从中间划开得到四张1/4子图像，将每张子图像看成幅度图的一个象限，重新分布即将四个角点重叠到图片中心)。 这样的话原点(0,0)就位移到图像中心。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">magI</span> <span class="o">=</span> <span class="n">magI</span><span class="p">(</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">magI</span><span class="p">.</span><span class="n">cols</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">magI</span><span class="p">.</span><span class="n">rows</span> <span class="o">&amp;</span> <span class="o">-</span><span class="mi">2</span><span class="p">));</span>
<span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">magI</span><span class="p">.</span><span class="n">cols</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">magI</span><span class="p">.</span><span class="n">rows</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

<span class="n">Mat</span> <span class="n">q0</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>   <span class="c1">// Top-Left - 为每一个象限创建ROI</span>
<span class="n">Mat</span> <span class="n">q1</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>  <span class="c1">// Top-Right</span>
<span class="n">Mat</span> <span class="n">q2</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span>  <span class="c1">// Bottom-Left</span>
<span class="n">Mat</span> <span class="n">q3</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">Rect</span><span class="p">(</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">));</span> <span class="c1">// Bottom-Right</span>

<span class="n">Mat</span> <span class="n">tmp</span><span class="p">;</span>                           <span class="c1">// 交换象限 (Top-Left with Bottom-Right)</span>
<span class="n">q0</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="n">q3</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q0</span><span class="p">);</span>
<span class="n">tmp</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q3</span><span class="p">);</span>

<span class="n">q1</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>                    <span class="c1">// 交换象限 (Top-Right with Bottom-Left)</span>
<span class="n">q2</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q1</span><span class="p">);</span>
<span class="n">tmp</span><span class="p">.</span><span class="n">copyTo</span><span class="p">(</span><span class="n">q2</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>归一化</strong>. 这一步的目的仍然是为了显示。 现在我们有了重分布后的幅度图，但是幅度值仍然超过可显示范围[0,1]  。我们使用 <a class="reference external" href="http://opencv.itseez.com/modules/core/doc/operations_on_arrays.html#normalize">normalize()</a> 函数将幅度归一化到可显示范围。</p>
</li>
</ol>
<blockquote>
<div><div class="highlight-cpp"><div class="highlight"><pre><span class="n">normalize</span><span class="p">(</span><span class="n">magI</span><span class="p">,</span> <span class="n">magI</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">CV_MINMAX</span><span class="p">);</span> <span class="c1">// 将float类型的矩阵转换到可显示图像范围</span>
                                        <span class="c1">// (float [0， 1]).</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id5">
<h2>结果<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>离散傅立叶变换的一个应用是决定图片中物体的几何方向.比如，在文字识别中首先要搞清楚文字是不是水平排列的? 看一些文字，你就会注意到文本行一般是水平的而字母则有些垂直分布。文本段的这两个主要方向也是可以从傅立叶变换之后的图像看出来。我们使用这个 <a class="reference download internal" href="../../../../_downloads/imageTextN.png"><tt class="xref download docutils literal"><span class="pre">水平文本图像</span></tt></a> 以及 <a class="reference download internal" href="../../../../_downloads/imageTextR.png"><tt class="xref download docutils literal"><span class="pre">旋转文本图像</span></tt></a> 来展示离散傅立叶变换的结果 。</p>
<p>水平文本图像:</p>
<img alt="In case of normal text" class="align-center" src="../../../../_images/result_normal.jpg" />
<p>旋转文本图像:</p>
<img alt="In case of rotated text" class="align-center" src="../../../../_images/result_rotated.jpg" />
<p>观察这两张幅度图你会发现频域的主要内容(幅度图中的亮点)是和空间图像中物体的几何方向相关的。 通过这点我们可以计算旋转角度并修正偏差。</p>
</div>
<div class="section" id="id6">
<h2>翻译者<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>niesu@ <a class="reference external" href="http://www.opencv.org.cn">OpenCV中文网站</a>  &lt;<a class="reference external" href="mailto:sisongasg%40hotmail.com">sisongasg<span>@</span>hotmail<span>.</span>com</a>&gt;</p>
</div>
</div>


          </div>
          <div class="feedback">
              <h2>Help and Feedback</h2>
              You did not find what you were looking for?
              <ul>
                  
                  
                  
                  <li>Ask a question in the <a href="http://tech.groups.yahoo.com/group/OpenCV/">user group/mailing list</a>.</li>
                  <li>If you think something is missing or wrong in the documentation,
                  please file a <a href="https://code.ros.org/trac/opencv/wiki">bug report</a>.</li>
              </ul>
          </div>
        </div>
      </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">离散傅立叶变换</a><ul>
<li><a class="reference internal" href="#id2">目标</a></li>
<li><a class="reference internal" href="#id3">源码</a></li>
<li><a class="reference internal" href="#id4">原理</a></li>
<li><a class="reference internal" href="#id5">结果</a></li>
<li><a class="reference internal" href="#id6">翻译者</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../random_generator_and_text/random_generator_and_text.html" title="previous chapter">随机数发生器&amp;绘制文字</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../file_input_output_with_xml_yml/file_input_output_with_xml_yml.html" title="next chapter">输入输出XML和YAML文件</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../../../_sources/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.txt" rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="">
  <h3>Quick search</h3>
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../../genindex.html" title="General Index">index</a></li>
        <li class="right">
          <a href="../file_input_output_with_xml_yml/file_input_output_with_xml_yml.html" title="输入输出XML和YAML文件">next</a> |</li>
        <li class="right">
          <a href="../random_generator_and_text/random_generator_and_text.html" title="随机数发生器&amp;绘制文字">previous</a> |</li>
        <li><a href="../../../../index.html">OpenCV 2.3.2 documentation</a> »</li>
          <li><a href="../../tutorials.html">OpenCV 教程</a> »</li>
          <li><a href="../table_of_content_core/table_of_content_core.html"><em>core</em> 模块. 核心功能</a> »</li> 
      </ul>
    </div>
    <div class="footer">
        © Copyright 2011, opencv dev team.
      Last updated on Mar 30, 2012.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  
</body></html>
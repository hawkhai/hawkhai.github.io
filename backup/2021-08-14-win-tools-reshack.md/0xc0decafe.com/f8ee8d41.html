<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en-US"><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The malware analyst&amp;#8217;s guide to PE timestamps</title>
  <meta name="description" content="From l0w to h1gh level - full stack cyber!" />
  <link rel="canonical" href="https://0xc0decafe.com/malware-analyst-guide-to-pe-timestamps" />
  <link rel="alternate" type="application/rss+xml" title="0xC0DECAFE.com Feed" href="https://0xc0decafe.com/feed.xml" />
  
  <link rel="shortcut icon" href="/images/favicon.png" type="image/png" />
  
  <!-- Styles -->
  <link href="https://fonts.googleapis.com/css?family=Lato:400,400i,700,700i%7CNoto+Serif:400,400i,700,700i&amp;display=swap" rel="stylesheet" />
  <link href="/assets/css/style.css" rel="stylesheet" />
</head>
<body>

  <div id="page" class="site">
    <div class="inner">
      <header class="site-header">
  <!--  -->
  <!-- <p class="site-title"><a class="logo-text" href="/">0xC0DECAFE.com</a></p> -->
  <!--  -->
  <img src="/images/NEON-Logo-Transparent.png" alt="0xC0DECAFE.com" />
  <nav class="site-navigation">
    <div class="site-navigation-wrap">
      <h2 class="screen-reader-text">Main navigation</h2>
      <ul class="menu">
        
        
        
        <li class="menu-item ">
          <a class="" href="/">Home</a>
        </li>
        
        
        
        <li class="menu-item ">
          <a class="" href="/about.html">About</a>
        </li>
        
      </ul><!-- .menu -->
      <button id="menu-close" class="menu-toggle"><span class="screen-reader-text">Close Menu</span><span class="icon-close" aria-hidden="true"></span></button>
    </div><!-- .site-navigation-wrap -->
  </nav><!-- .site-navigation -->
  <button id="menu-open" class="menu-toggle"><span class="screen-reader-text">Open Menu</span><span class="icon-menu" aria-hidden="true"></span></button>
</header>



      <main class="main-content fadeInDown delay_075s">

  <article class="post">
    <header class="post-header">
      <time class="post-date" datetime="2021-01-22">January 22, 2021</time>
      <h1 class="post-title">The malware analyst’s guide to PE timestamps</h1>
      <div class="post-meta">
        <!-- By <span class="post-author">Thomas Barabosch</span> -->
      </div><!-- .post-meta -->
      
      <figure class="post-thumbnail image-card width-wide">
        <img src="/wp-content/uploads/2021/01/pe_timestamps-e1610710651691.jpg" alt="The malware analyst’s guide to PE timestamps" />
      </figure><!-- .post-thumbnail -->
      
    </header><!-- .post-header -->
    <div class="post-content">
      <p>This blog post is all about time. More exactly, timestamps found in Portable Executable (PE) files that describe a (possible) compilation date. These PE timestamps may even reveal details about a threat actor. For instance, it is possible to deduce a threat actor’s working hours and use this information – hopefully together with other artifacts – for attribution purposes. But be aware: even though PE timestamps can be a valuable forensic artifact, they can be forged with ease. While the COFF header field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> is the most-known place to look for a compilation timestamp, there are more places where we can find timestamps in a PE file.</p>

<!--more-->

<p>But there are also special cases where PE timestamps are not correct due to new build features, linker bugs, or simply forging. We’ll look into these cases and see how we can still get some information about the compilation date. Afterward, we’ll learn how to read PE timestamps with a wide range of tools and how to automate this work in order to deal with larger datasets. Of course, there are several real-world applications for malware / cyber threat intelligence analysts of what we’ll learn in this blog post. Finally, I’ll give you some ideas how you can utilize PE timestamps to reveal certain behaviors or characteristics of threat actors.</p>

<p>This article assumes a basic understanding of the PE format. Good beginner write-ups are “<a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2002/february/inside-windows-win32-portable-executable-file-format-in-detail">An In-Depth Look into the Win32 Portable Executable File Format</a>” and “<a href="https://blog.kowalczyk.info/articles/pefileformat.html">Portable Executable File Format</a>“. As a follow-up, <a href="https://github.com/corkami/docs/blob/master/PE/PE.md">Ange Albertini wrote</a> a much more detailed technical article on the PE format.</p>

<p>This work wouldn’t have been possible without many great blog posts and papers published by the infosec community. I am standing on the shoulders of giants! I refer to these posts and papers in the following whenever possible.</p>

<p>The probably most cited field of the PE format that holds a compilation timestamp is the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of the <a href="https://wiki.osdev.org/COFF#Microsoft_PE.2FCOFF">COFF File Header</a>. It is a <code class=" highlighter-rouge language-plaintext">DWORD</code> (32 bit / 4 bytes) member of the struct <code class=" highlighter-rouge language-plaintext">_IMAGE_FILE_HEADER</code> / <a href="https://wiki.osdev.org/COFF#Microsoft_PE.2FCOFF">COFF File Header</a>. This struct is defined as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight language-c"><code class=" language-c">`typedef struct _IMAGE_FILE_HEADER {   `
 `WORD  Machine;   `
 `WORD  NumberOfSections;   `
` DWORD TimeDateStamp;   `
` DWORD PointerToSymbolTable;   `
` DWORD NumberOfSymbols;   `
` WORD  SizeOfOptionalHeader;   `
` WORD  Characteristics; `
`} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;`
</code></pre></div></div>

<p><code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> is in <a href="https://en.wikipedia.org/wiki/Epoch_(computing)">epoch</a>, which measures the seconds that have passed since January 1, 1970 UTC. Since it is a DWORD value, its range is quite limited. This will lead – if not fixed before – to an <a href="https://en.wikipedia.org/wiki/Year_2038_problem">integer overflow in the year 2038</a>. Furthermore, epoch <strong>should not be</strong> confused with <em>Win32 epoch</em>, which <a href="https://devblogs.microsoft.com/oldnewthing/20090306-00/?p=18913">starts in the year 1601</a>.</p>

<p>As part of the linking process of the final PE binary, the linker sets the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> in the COFF File Header. However, its purpose today is mainly supporting the module loader as Raymond Chen lays out in “<a href="https://devblogs.microsoft.com/oldnewthing/20180103-00/?p=97705">Why are the module timestamps in Windows 10 so nonsensical?</a>“:</p>

<blockquote>
  <p>Remember what the timestamp is used for: It’s used by the module loader to determine whether bound imports should be trusted. We’ve already seen cases where the timestamp is inaccurate. For example, if you rebind a DLL, then the rebound DLL has the same timestamp as the original, rather than the timestamp of the rebind, because you don’t want to break the bindings of other DLLs that bound to your DLL.</p>

  <p>So the timestamp is already unreliable.</p>

  <p>The timestamp is really a unique ID that tells the loader, “The exports of this DLL have not changed since the last time anybody bound to it.” […]</p>

  <p><cite>Raymond Chen – Why are the module timestamps in Windows 10 so nonsensical?</cite></p>
</blockquote>

<p><strong>Bottom line</strong>: even though nobody had the intention to tamper with a timestamp, it <em>may already be unreliable</em> in certain cases.</p>

<h2 id="additional-timestamps-found-in-the-pe-file-format">Additional timestamps found in the PE file format</h2>

<p>In addition to the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of the COFF File Header, there are further places where we can find possible compilation timestamps in PE files.</p>

<p>I think the most complete listing was <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">compiled by Walied Assar</a>. He lists additional places in the PE format where we can find possible compilation timestamps. I’ll refer only to the ones that can be used in order to determine the compilation time in the following sections.</p>

<p>Nevertheless, you should have a look at the other possible fields that <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">Walied Assar’s aforementioned article</a> mentions. Just for completeness, I’ll list the directories that I <strong>do not include</strong> in the following:</p>

<ul>
  <li><code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> in <strong><em><code class=" highlighter-rouge language-plaintext">_IMAGE_IMPORT_DESCRIPTOR</code></em></strong> (see <code class=" highlighter-rouge language-plaintext">_IMAGE_EXPORT_DIRECTORY</code>; used in bound imports)</li>
  <li><code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> in <code class=" highlighter-rouge language-plaintext">_IMAGE_BOUND_IMPORT_DESCRIPTOR</code> (see <code class=" highlighter-rouge language-plaintext">_IMAGE_EXPORT_DIRECTORY</code>; used in bound imports)</li>
  <li><code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> in <code class=" highlighter-rouge language-plaintext">_IMAGE_LOAD_CONFIG_DIRECTORY</code> (<a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">obsolete since Windows XP</a>)</li>
</ul>

<h3 id="_image_export_directory"><strong><em>_IMAGE_EXPORT_DIRECTORY</em></strong></h3>

<p>The <a href="https://blog.kowalczyk.info/articles/pefileformat.html">export directory</a> (<code class=" highlighter-rouge language-plaintext">_IMAGE_EXPORT_DIRECTORY</code>) of the PE format contains also a field called <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code>. Not all linkers seem to fill this field but <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">Microsoft Visual Studio linkers fill it</a> for both DLL and EXE PE files. For reference, the export directory structure <code class=" highlighter-rouge language-plaintext">_IMAGE_EXPORT_DIRECTORY</code> is defined as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight language-c"><code class=" language-c">typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
  } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;
</code></pre></div></div>

<p>The field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> is relevant for bound imports as other PE files that use <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files">bound imports</a> (see <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files">Import Binding</a>) refer to the value of this field in their own field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of <code class=" highlighter-rouge language-plaintext">IMAGE_IMPORT_DESCRIPTOR</code>. Or in other words: the linker fills the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of <code class=" highlighter-rouge language-plaintext">IMAGE_IMPORT_DESCRIPTOR</code> with the value of <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of <code class=" highlighter-rouge language-plaintext">_IMAGE_EXPORT_DIRECTORY</code> of the PE file that they bind their import to. This is the reason why the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of <code class=" highlighter-rouge language-plaintext">IMAGE_IMPORT_DESCRIPTOR</code> are unusable to determine a possible compilation date.</p>

<p>The value of this field describes the time <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files">when the export directory was created</a>. Therefore, it doesn’t have to be equal to the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> from the COFF File Header. But it is often equal <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">or very close</a> to it.</p>

<h3 id="_image_resource_directory"><strong><em>_IMAGE_RESOURCE_DIRECTORY</em></strong></h3>

<p>Another <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> field resides in the <a href="https://blog.kowalczyk.info/articles/pefileformat.html">resource directory</a> (<code class=" highlighter-rouge language-plaintext">_IMAGE_RESOURCE_DIRECTORY</code>). The corresponding structure is defined as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight language-c"><code class=" language-c">typedef struct _IMAGE_RESOURCE_DIRECTORY {
     DWORD   Characteristics;
     DWORD   TimeDateStamp;
     WORD    MajorVersion;
     WORD    MinorVersion;
     WORD    NumberOfNamedEntries;
     WORD    NumberOfIdEntries;
 } IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
</code></pre></div></div>

<p>While <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">Microsoft Visual Studio linkers seem not to set this field</a>, (old) Borland linkers set it. This is especially relevant for malware that is compiled with a Delphi version between Delphi 4 and Delphi 2006. As we later see, there is a known bug so that these versions do not correctly set the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of the COFF File Header. However, they set it – if the PE file comprises resources – in the <code class=" highlighter-rouge language-plaintext">IMAGE_RESOURCE_DIRECTORY</code> and <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">its subdirectories</a>.</p>

<h3 id="_image_debug_directory"><strong><em>_IMAGE_DEBUG_DIRECTORY</em></strong></h3>

<p>If the linker emits debug information (<a href="https://docs.microsoft.com/en-us/cpp/build/reference/debug-generate-debug-info?view=msvc-160">/DEBUG</a>), then the PE file contains an <a href="https://blog.kowalczyk.info/articles/pefileformat.html">array of debug directories</a> (<code class=" highlighter-rouge language-plaintext">_IMAGE_DEBUG_DIRECTORY</code>). The corresponding structure contains a field called <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> and is defined as follows:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight language-c"><code class=" language-c">typedef struct _IMAGE_DEBUG_DIRECTORY {
     DWORD   Characteristics;
     DWORD   TimeDateStamp;
     WORD    MajorVersion;
     WORD    MinorVersion;
     DWORD   Type;
     DWORD   SizeOfData;
     DWORD   AddressOfRawData;
     DWORD   PointerToRawData;
 } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
</code></pre></div></div>

<p>As a PE file can contain several <code class=" highlighter-rouge language-plaintext">_IMAGE_DEBUG_DIRECTORY</code>s (<a href="https://blog.kowalczyk.info/articles/pefileformat.html">stored in an array</a>), it is <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">worth to check</a> all of them, in case the timestamp of the first seems to be forged.</p>

<p>Furthermore, one type of debugging information contains a timestamp. The field <code class=" highlighter-rouge language-plaintext">Type</code> holds several constants (range <code class=" highlighter-rouge language-plaintext">0x0</code> – <code class=" highlighter-rouge language-plaintext">0x9</code>) that i<a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_debug_directory">ndicate the format </a>of the debugging information. If the field is set to <strong><em><code class=" highlighter-rouge language-plaintext">IMAGE_DEBUG_TYPE_CODEVIEW</code></em></strong> (<code class=" highlighter-rouge language-plaintext">0x2</code>), then we can follow <code class=" highlighter-rouge language-plaintext">PointerToRawData</code> of <code class=" highlighter-rouge language-plaintext">_IMAGE_DEBUG_DIRECTORY</code> and we’ll find the CodeView information.</p>

<p>The relevant structures <code class=" highlighter-rouge language-plaintext">_CV_HEADER</code> and <code class=" highlighter-rouge language-plaintext">_CV_INFO_PDB20</code> <a href="https://github.com/tishion/PdbInfo/blob/master/PdbInfo/PEHelper.h">are defined as follows</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight language-c"><code class=" language-c">#define CV_SIGNATURE_NB10 '01BN'       
#define CV_SIGNATURE_NB09 '90BN'       
                
typedef struct _CV_HEADER               
{       
 DWORD dwSignature;       
 DWORD dwOffset;       
} CV_HEADER, *PCV_HEADER;       
                
typedef struct _CV_INFO_PDB20       
{       
 CV_HEADER CvHeader;       
 DWORD dwSignature;       
 DWORD dwAge;       
 BYTE PdbFileName[];       
} CV_INFO_PDB20, *PCV_INFO_PDB20;
</code></pre></div></div>

<p>If the <code class=" highlighter-rouge language-plaintext">_CV_HEADER</code>‘s signature in <code class=" highlighter-rouge language-plaintext">dwSignature</code> equals <code class=" highlighter-rouge language-plaintext">CV_SIGNATURE_NB10</code>, then the PDB format is 2.0. In this case, the <code class=" highlighter-rouge language-plaintext">dwSignature</code> contains an epoch value describing when the debug information was created. If it is not in PDB format, then <code class=" highlighter-rouge language-plaintext">dwSignature</code> <a href="https://github.com/tishion/PdbInfo/blob/master/PdbInfo/PEHelper.h">may comprises an unique identifier</a> for each build. Note that the field <code class=" highlighter-rouge language-plaintext">dwAge</code> is not a timestamp in epoch but rather an ever-increasing value that indicates an update to the PDB information.</p>

<h2 id="special-cases">Special cases</h2>

<p>There are several noteworthy special cases where the timestamps are either not reliable or other timestamps should be preferred. The following sections will look into three of these cases and show possible ways to circumvent this limitation.</p>

<h3 id="delphi-timestamps">Delphi timestamps</h3>

<p>Do you know what happened on 1992-06-19? I googled it and found out that this was the day <a href="https://en.wikipedia.org/wiki/Batman_Returns">Batman Returns</a> was released in the USA. But that’s only relevant for Batman fans and not really related to timestamps. Something different happened, at least, if you believe the PE timestamps of likely thousands or even millions of Delphi binaries. They all were built on <code class=" highlighter-rouge language-plaintext">1992-06-19 22:22:17</code>. The timestamp value is <code class=" highlighter-rouge language-plaintext">0x2A425E19</code> (<code class=" highlighter-rouge language-plaintext">708992537</code>).</p>

<p>What sounds like a very productive programmer evening is actually a bug in many Delphi compiler versions. Delphi versions <a href="https://stackoverflow.com/questions/1781443/how-can-i-get-the-compile-date-and-time-in-delphi">before Delphi 2007</a> (likely <a href="https://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/">Delphi 4 – Delphi 2006</a>) did not set the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> at all. It seems that they just used a preconfigured value for this field. Maybe they used a PE stub that they filled out accordingly. However, there <a href="https://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/">is a way</a> to determine the real compilation timestamp of these binaries. If the sample comprises a resources directory (<strong><em><code class=" highlighter-rouge language-plaintext">_IMAGE_RESOURCE_DIRECTORY</code></em></strong>), we can read its <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> field instead. But be aware that the value is not an epoch timestamp but a <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-dosdatetimetofiletime?redirectedfrom=MSDN">MS DOS timestamp</a>.</p>

<p><strong>Bottom line</strong>: if you see a binary with a timestamp value of <code class=" highlighter-rouge language-plaintext">1992-06-19 22:22:17</code>, then you are likely dealing with a Delphi binary that was compiled with a Delphi version before Delphi 2007. If there are resources, then you may get at least a compilation estimate from the timestamp found in <strong><em><code class=" highlighter-rouge language-plaintext">_IMAGE_RESOURCE_DIRECTORY</code></em></strong>.</p>

<h3 id="windows-10-reproducible-builds-timestamps">Windows 10 reproducible builds timestamps</h3>

<p>Windows 10 timestamps <a href="https://devblogs.microsoft.com/oldnewthing/20180103-00/?p=97705">are nonsensical</a> since Microsoft moved towards reproducible builds. In a nutshell, a reproducible build means starting a build from the exact same source code yields the exact same binary code. Obviously, timestamps are one obstacle in the way to reproducible builds. Therefore, timestamps are set to the hash of the resulting binary, which preserves reproducibility.</p>

<p>Let’s have a look at a Windows 10 binary to verify this behavior. For instance, <code class=" highlighter-rouge language-plaintext">regedit.exe</code> comprises a <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> value <code class=" highlighter-rouge language-plaintext">0xBB9B6911</code> as can be seen in the following screenshot (using the tool <a href="https://www.winitor.com/">pestudio</a>). If we translate this value to UTC time, then this date would be way in the future. As expected, the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> value of Windows 10 binaries is unreliable.</p>

<p><img src="https://0xc0decafe.com/wp-content/uploads/2021/01/ts_regedit_pestudio.png" alt="" /></p>

<p>Even though I am not aware of a way to get a compilation timestamp directly from these binaries, there are two possible ways to get at least an approximation. First, if the file was scanned at VirusTotal, then it must be older than the first submission date. This may be a very inaccurate approximation but a good starting point.</p>

<p>Second, a better way to approximate the age of the binary would be to use a binary index like <a href="https://winbindex.m417z.com">Winbindex</a>. For instance, here we can check if <a href="https://winbindex.m417z.com/?file=regedit.exe">it indexes</a> the <code class=" highlighter-rouge language-plaintext">regedit.exe</code> file from the previous example. And indeed: Winbindex lists this <code class=" highlighter-rouge language-plaintext">regedit.exe</code> file with sha256 hash <code class=" highlighter-rouge language-plaintext">d5de45decfd0fa08ac12f5725dfc7e5af1e3ed0325559101990fdcf02c439441</code> and states that it is part of Windows 10 1903 and 1909. So the earliest we can get is <code class=" highlighter-rouge language-plaintext">2019-05-21</code>, which is the release date of Windows 10 1903.</p>

<h3 id="gozi2--isfb-timestamps">Gozi2 / ISFB timestamps</h3>

<p>Gozi2 / ISFB and <a href="https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/">its forks </a>are wide-spread malware strains. Malware analysts are likely to stumble upon one or more of them during their career. Even though the timestamps of a Gozi / ISFB sample may be forged, there is a “feature” of this malware family and many of its forks that is likely more reliable. As stated by Maciej Kotowicz in his <a href="https://lokalhost.pl/txt/isfb_still.live.and.licking.Botconf2016.pdf">report on ISFB</a>:</p>

<blockquote>
  <p>One of first operations of all ISFB’ variants is to decode strings that are stored in .bss section, section that is normally used to keep non-initialized global variables. The algorithm used for string encoding is quite simple, it is a rolling xor with a compilation date as a key.</p>

  <p><cite>ISFB: Still Live and Kicking by Maciej Kotowicz</cite></p>
</blockquote>

<p>Again, the old rule of thumb holds here: threat actors are often as lazy as we are. Therefore, they will not touch this “feature”. We can see this in an ISFB fork called <a href="https://www.telekom.com/en/blog/group/article/lolsnif-tracking-another-ursnif-based-targeted-campaign-600062">LOLSnif</a>. The sample that was observed in campaigns in April 2020 loaded the plaintext key “Apr 1 2020” to decrypt its strings.</p>

<p><img src="https://0xc0decafe.com/wp-content/uploads/2021/01/ts_ursnif.png" alt="ISFB fork LOLSnif loads compilation date as plaintext string for string decryption." /></p>

<p>Threat actors who compile their malicious binaries can easily tamper with any of the aforementioned timestamp values. I would say that forging timestamps is a low-hanging fruit and not doing so shows a lack of or disinterest in Operational Security (OPSEC), respectively.</p>

<p><strong>As a rule of thumb</strong>: you should never blindly trust the timestamp found in any of the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> fields as they can easily be forged! However, you can increase the confidence that you have in the correctness of this value by, for instance, correlating this with intrusion dates obtained from incident response engagements or metadata obtained from sources like <a href="https://www.virustotal.com/">VirusTotal</a> (e.g. <code class=" highlighter-rouge language-plaintext">First Submission</code>). Furthermore, you should never trust the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> value of packed binaries as this is one of the PE header fields that packers tamper with in the first place. However, the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> values of unpacked binaries are in many cases (but certainly not all!) correct as threat actors often do not care about tampering with it.</p>

<h3 id="case-study-custom-loader-dlls-used-in-sunburst-attacks">Case study: custom loader DLLs used in SUNBURST attacks</h3>

<p>For instance, the threat actor who is responsible for the sophisticated supply chain attack known as <a href="https://www.fireeye.com/blog/threat-research/2020/12/evasive-attacker-leverages-solarwinds-supply-chain-compromises-with-sunburst-backdoor.html">SUNBURST</a> forged timestamps as stated in Microsoft’s report “<a href="https://www.microsoft.com/security/blog/2021/01/20/deep-dive-into-the-solorigate-second-stage-activation-from-sunburst-to-teardrop-and-raindrop/">Deep dive into the Solorigate second-stage activation: From SUNBURST to TEARDROP and Raindrop</a>“:</p>

<blockquote>
  <p>The custom loader DLLs dropped on disk carried compile timestamps ranging from July 2020 to October 2020, while the embedded Reflective DLLs carried compile timestamps ranging from March 2016 to November 2017. The presence of 2016-2017 compile timestamps is likely due to attackers’ usage of custom <a href="https://www.cobaltstrike.com/help-malleable-c2">Malleable C2 profiles</a> with synthetic compile timestamp (<em>compile_time</em>) values. At first glance it would appear as if the actor did not timestamp the compile time of the custom loader DLLs (2020 compile timestamps). However, forensic analysis of compromised systems revealed that in a few cases, the timestamp of the custom loader DLLs’ introduction to systems predated the compile timestamps of the custom loader DLLs (i.e., the DLLs appear to have been compiled at a future date).</p>

  <p><cite>Microsoft Security – Deep dive into the Solorigate second-stage activation: From SUNBURST to TEARDROP and Raindrop</cite></p>
</blockquote>

<p>The interesting point here is that both the loader DLLs as well as the CobaltStrike Beacons have forged timestamps. The timestamps of the CobaltStrike Beacons were likely forged as part of the CobaltStrike framework and carried timestamps way in the past. However, the interesting thing here is that the outer layer – the custom loader DLLs – carried timestamps that laid in the future.</p>

<p>Even though it might be wild speculation why these timestamps predated the actual intrusion dates, one possible explanation is that the threat actor wanted the intrusion to appear to last less time than it actually lasted, in case the loader DLLs would have been found by the local network defenders.</p>

<h2 id="read-pe-timestamps">Read PE timestamps</h2>

<p>Numerous tools and (Python) modules allow us to read (and modify) several fields of the PE header that can hold (compilation) timestamps. The following sections will show how these timestamps can be read with tools that I deem important. The first tools serve for manual inspection of individual PE files. But the later sections will show how to use two well-known Python modules in order to automate the PE timestamp extraction as a means of analyzing several PE files of a campaign / a threat actor.</p>

<p>Note that there is also <a href="https://www.hexacorn.com/blog/2019/03/11/pe-compilation-timestamps-vs-forensics/">an issue with several tools</a>. While some display the TimeDateStamp as UTC time, some localize the TimeDateStamp and display incorrect information. IMHO the correct way is to display timestamps as UTC time and additionally indicate the shift that is required so that it’s in the supposedly correct time zone.</p>

<h3 id="read-pe-timestamps-with-a-pe-file-viewer">Read PE timestamps with a PE file viewer</h3>

<p>This one is a no-brainer. Every PE file viewer like, for instance, <a href="https://github.com/blackberry/pe_tree">PE Tree</a>, <a href="https://www.winitor.com/">pestudio</a>, or <a href="https://github.com/hasherezade/pe-bear-releases">PE-bear</a> displays the aforementioned <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> fields as seen in the following screenshot using PE Tree. Note how PE Tree correctly displays the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> field as UTC time.</p>

<p><img src="https://0xc0decafe.com/wp-content/uploads/2021/01/ts_pe_tree-1024x473.png" alt="Reading PE timestamps with PE viewer pe-tree" /></p>

<p>Walied Assar <a href="http://waleedassar.blogspot.com/2014/02/pe-timedatestamp-viewer.html">wrote a tiny command line program </a>called <a href="https://github.com/waleedassar/TimeDateStamp/">TimeDateStamp</a>. This command line program inspects half of a dozen timestamps that are defined in the PE format. Use the <code class=" highlighter-rouge language-plaintext">-f</code> flag with a path to a PE file as follows:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight language-bash"><code class=" language-bash">C:\Users\USER\Desktop&gt;TimeDateStamp.exe -f yara64.exe
     TimeDateStamp from _IMAGE_FILE_HEADER        ---&gt; Fri Jun 26 08:37:17 2020
     TimeDateStamp from _IMAGE_EXPORT_DIRECTORY   ---&gt; Empty
     TimeDateStamp from _IMAGE_DEBUG_DIRECTORY    ---&gt;
     TimeDateStamp from _IMAGE_LOAD_CONFIG_DIRECTORY ---&gt; Empty    
</code></pre></div></div>

<p>Another neat feature is that we can input a hex value (with or without leading <code class=" highlighter-rouge language-plaintext">0x</code>) and the tool spits out the corresponding date. For instance, if we input <code class=" highlighter-rouge language-plaintext">0x2A425E19</code> (do you still remember what that was?), then it spits out <code class=" highlighter-rouge language-plaintext">Fri Jun 19 22:22:17 1992</code> correctly:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight language-bash"><code class=" language-bash">C:\Users\USER\Desktop&gt;TimeDateStamp.exe 2A425E19
 Fri Jun 19 22:22:17 1992
</code></pre></div></div>

<h3 id="read-pe-timestamps-with-an-hex-editor">Read PE timestamps with an hex editor</h3>

<p><a href="https://twitter.com/push_pnx/status/1164900331098128385?s=20">Daniel Plohmann’s tweet </a>with a list of DWORDs with only the most significant byte set and their corresponding dates is particularly interesting. For those who work frequently with HexEditors inspecting binary formats (not necessarily the PE format), this table is very helpful. Based on the most significant byte of the timestamp DWORD, we can quickly estimate the date.</p>

<p>For instance, the Delphi timestamp <code class=" highlighter-rouge language-plaintext">0x2A425E19</code> falls in the bin <code class=" highlighter-rouge language-plaintext">0x2A000000</code> and <code class=" highlighter-rouge language-plaintext">0x2B000000</code>, or for humans <code class=" highlighter-rouge language-plaintext">1992-04-30 14:11:12</code> and <code class=" highlighter-rouge language-plaintext">1992-11-10 17:31:28</code>. Note that each bin covers more or less six months.</p>

<p>I’ve generated the bins for 2015 – 2025, which should be the most relevant as of 2021:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight language-plaintext"><code class=" language-plaintext">U -&gt; 0x55000000 - 2015-03-11T09:42:40
 V -&gt; 0x56000000 - 2015-09-21T15:02:56
 W -&gt; 0x57000000 - 2016-04-02T19:23:12
 X -&gt; 0x58000000 - 2016-10-13T23:43:28
 Y -&gt; 0x59000000 - 2017-04-26T04:03:44
 Z -&gt; 0x5a000000 - 2017-11-06T07:24:00
 [ -&gt; 0x5b000000 - 2018-05-19T12:44:16
 \ -&gt; 0x5c000000 - 2018-11-29T16:04:32
 ] -&gt; 0x5d000000 - 2019-06-11T21:24:48
 ^ -&gt; 0x5e000000 - 2019-12-23T00:45:04
 _ -&gt; 0x5f000000 - 2020-07-04T06:05:20
 ` -&gt; 0x60000000 - 2021-01-14T09:25:36
 a -&gt; 0x61000000 - 2021-07-27T14:45:52
 b -&gt; 0x62000000 - 2022-02-06T18:06:08
 c -&gt; 0x63000000 - 2022-08-19T23:26:24
 d -&gt; 0x64000000 - 2023-03-02T02:46:40
 e -&gt; 0x65000000 - 2023-09-12T08:06:56
 f -&gt; 0x66000000 - 2024-03-24T11:27:12
 g -&gt; 0x67000000 - 2024-10-04T16:47:28
 h -&gt; 0x68000000 - 2025-04-16T21:07:44
 i -&gt; 0x69000000 - 2025-10-28T00:28:00
</code></pre></div></div>

<h3 id="read-pe-timestamps-from-the-command-line">Read PE timestamps from the command line</h3>

<p>There are many command line tools that can read the PE header. One tool I like to use is <a href="https://manpages.debian.org/testing/pev/readpe.1.en.html">readpe</a> from the <a href="https://github.com/merces/pev">pev</a> toolkit. pev is open source, works on several platforms, and comes with many handy tools when dealing with PE files from the command line. Let’s just use <code class=" highlighter-rouge language-plaintext">readpe</code> to read the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> of the COFF File Header from a packed <a href="https://sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated-photoloader.html">IcedId PhotoLoader</a> sample (<a href="https://www.virustotal.com/gui/file/4e7161be03f206c1b086bb15b47470ec1c9381302eb34d0e76915496aec77193/details">4e7161be03f206c1b086bb15b47470ec1c9381302eb34d0e76915496aec77193</a>, first submission to VT: 2020-05-27 23:31:27).</p>

<p>We call <code class=" highlighter-rouge language-plaintext">readpe</code> with the <code class=" highlighter-rouge language-plaintext">-h</code> flag, which allows us to specify a header that we would like to inspect. For our purpose, this is the COFF header (<code class=" highlighter-rouge language-plaintext">coff</code>). As a result, <code class=" highlighter-rouge language-plaintext">readpe</code> dumps all fields from this header.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight language-bash"><code class=" language-bash">readpe -h coff 4e7161be03f206c1b086bb15b47470ec1c9381302eb34d0e76915496aec77193
COFF/File header
     Machine:                         0x14c IMAGE_FILE_MACHINE_I386
     Number of sections:              4
     Date/time stamp:                 1432567928 (Mon, 25 May 2015 15:32:08 UTC)
     Symbol Table offset:             0
     Number of symbols:               0
     Size of optional header:         0xe0
     Characteristics:                 0x103
     Characteristics names
                                          IMAGE_FILE_RELOCS_STRIPPED
                                          IMAGE_FILE_EXECUTABLE_IMAGE
                                          IMAGE_FILE_32BIT_MACHINE
</code></pre></div></div>

<p>However, the timestamp is forged since the first submission of this sample was in Spring 2020 but the timestamp says that the sample is from Spring 2015. Let’s unpack the sample with <a href="https://www.unpac.me/results/c5c293b9-4951-4c2a-ad5e-312e599483db#/">unpac.me</a> and we receive one unpacked child (70fe6ccca21ce51800c7b998e8fc06997eac07e086f1dcdd87765b2dcea72395):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight language-plaintext"><code class=" language-plaintext">readpe -h coff 70fe6ccca21ce51800c7b998e8fc06997eac07e086f1dcdd87765b2dcea72395
COFF/File header
     Machine:                         0x14c IMAGE_FILE_MACHINE_I386
     Number of sections:              5
     Date/time stamp:                 1586956141 (Wed, 15 Apr 2020 13:09:01 UTC)
     Symbol Table offset:             0
     Number of symbols:               0
     Size of optional header:         0xe0
     Characteristics:                 0x102
     Characteristics names
                                          IMAGE_FILE_EXECUTABLE_IMAGE
                                          IMAGE_FILE_32BIT_MACHINE
</code></pre></div></div>

<p>Now, this timestamp looks much better. It is likely to be the correct compilation timestamp of this sample due to the first submission to VT differs just one month. Furthermore, there is a <a href="https://sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated-photoloader.html">blog post</a> published at the end of April 2020 that described this new variant of IcedId’s PhotoLoader.</p>

<h3 id="read-pe-timestamps-with-pefile">Read PE timestamps with pefile</h3>

<p><a href="https://github.com/erocarrera/pefile">pefile</a> is a Python module to parse and modify PE files. The following script (based on <a href="https://bufferoverflows.net/exploring-pe-files-with-python/">this blog post</a>) shows how to read the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> from the COFF File Header and convert it to UTC time. In addition, it prints out how old the PE file is. Note that accessing other <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> fields as described in Section “Additional timestamps found in PE files” works similarly. Please refer to the <a href="https://github.com/erocarrera/pefile/blob/wiki/UsageExamples.md">usage examples of pefile</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight language-python"><code class=" language-python">import datetime
import pefile
import sys

pe = pefile.PE(sys.argv[1])
ts = int(pe.FILE_HEADER.dump_dict()['TimeDateStamp']['Value'].split()[0], 16)
utc_time = datetime.datetime.utcfromtimestamp(ts)
t_delta = (datetime.datetime.today() - utc_time).days
print(utc_time.strftime("%Y-%m-%d %H:%M:%S +00:00 (UTC)") + f" ({t_delta} days old)")
</code></pre></div></div>

<p>If we run this simple script on a Delphi sample (Wabot, <a href="https://www.virustotal.com/gui/file/ebf6d5d12f4d18cef9456a363991ba028329cd25ee3908101c6c5aa624f21265/detection">ebf6d5d12f4d18cef9456a363991ba028329cd25ee3908101c6c5aa624f21265</a>), then we get a somewhat surprising result:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight language-bash"><code class=" language-bash">python get_timestamp_pefile.py ebf6d5d12f4d18cef9456a363991ba028329cd25ee3908101c6c5aa624f21265
1992-06-19 22:40:53 +00:00 (UTC) (10436 days old)
</code></pre></div></div>

<p>The value is <code class=" highlighter-rouge language-plaintext">0x2A426275</code>, which translates to <code class=" highlighter-rouge language-plaintext">1992-06-19 22:40:53</code>. This is not the expected Delphi timestamp <code class=" highlighter-rouge language-plaintext">0x2A425E19</code>. The most significant two bytes are equal (<code class=" highlighter-rouge language-plaintext">0x2A42</code>), but the least significant two bytes / WORD is different. A possible explanation is that the timestamp was modified.</p>

<h3 id="read-pe-timestamps-with-lief">Read PE timestamps with lief</h3>

<p><a href="https://lief.quarkslab.com/doc/latest/">lief</a> is another project to parse and modify PE files. Its core is written in C++ but there is a Python module as well. In contrary to pefile, lief is can parse various executable formats such as <a href="https://lief.quarkslab.com/doc/latest/tutorials/03_elf_change_symbols.html">ELF</a> and <a href="https://lief.quarkslab.com/doc/latest/tutorials/11_macho_modification.html">MachO</a> while offering the same interface. Therefore, lief works well in projects that do not only target one platform. Furthermore, lief added several advanced features not yet implemented in pefile like working with <a href="https://lief.quarkslab.com/doc/latest/tutorials/13_pe_authenticode.html">PE Authenticode</a>.</p>

<h4 id="read-coff-file-header-timestamps">Read COFF File Header timestamps</h4>

<p>The following code snippet shows the script <code class=" highlighter-rouge language-plaintext">get_timestamp_lief.py</code> that reads the PE Header field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> (called by lief <code class=" highlighter-rouge language-plaintext">time_date_stamps</code>) and converts it to UTC time (analogous to the pefile script of the previous section). Just import the module <code class=" highlighter-rouge language-plaintext">lief</code> and open the binary with the <code class=" highlighter-rouge language-plaintext">parse</code> method. The COFF File Header is accessible via <code class=" highlighter-rouge language-plaintext">header</code> and the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> is called <code class=" highlighter-rouge language-plaintext">time_date_stamps</code> in lief.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight language-python"><code class=" language-python">import datetime
 import lief
 import sys
 binary = lief.parse(sys.argv[1])
 ts = binary.header.time_date_stamps
 utc_time = datetime.datetime.utcfromtimestamp(ts)
 t_delta = (datetime.datetime.today() - utc_time).days
 print(utc_time.strftime("%Y-%m-%d %H:%M:%S +00:00 (UTC)") + f" ({t_delta} days old)")
</code></pre></div></div>

<h4 id="read-delphi-timestamps">Read Delphi timestamps</h4>

<p>Again, Delphi binaries that were compiled with Delphi 4 – Delphi 2006 had a bug: all of them had the same <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> value in the COFF File Header. However, there is a way (as described by <a href="https://www.hexacorn.com/blog/2014/12/05/the-not-so-boring-land-of-borland-executables-part-1/">Hexacorn</a>) to get the compilation timestamp via the field <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> in the resource directory (<code class=" highlighter-rouge language-plaintext">_IMAGE_RESOURCE_DIRECTORY</code>). Be aware that in Delphi binaries this field does not hold an epoch timestamp but rather a MS DOS timestamp.</p>

<p>The following script reads the a possible compilation timestamp for Delphi binaries. It boroughs the function <code class=" highlighter-rouge language-plaintext">from_msdos</code> from the project <a href="https://github.com/digitalsleuth/time_decode">Time Decode</a> to convert the MS DOS timestamp to a readable string. First, it checks if the <code class=" highlighter-rouge language-plaintext">TimeDateStamp</code> field of the <code class=" highlighter-rouge language-plaintext">IMAGE_FILE_HEADER</code> equals the expected Delphi timestamp (seen in Delphi 4 – Delphi 2006 binaries) in lines 26 – 27. In this case, it checks if there are resources with <code class=" highlighter-rouge language-plaintext">binary.has_resources</code> in line 29 and then gets resource directory with <code class=" highlighter-rouge language-plaintext">binary.resources</code> in line 30. Finally, it gets the timestamp and converts it from MS DOS format to a readable string.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight language-python"><code class=" language-python">import datetime
 import lief
 import sys

 def from_msdos(msdos):
     """taken from https://github.com/digitalsleuth/time_decode"""
     msdos = hex(msdos)[2:]
     binary = '{0:032b}'.format(int(msdos, 16))
     stamp = [binary[:7], binary[7:11], binary[11:16], binary[16:21], binary[21:27], binary[27:32]]
     for val in stamp[:]:
         dec = int(val, 2)
         stamp.remove(val)
         stamp.append(dec)
     dos_year = stamp[0] + 1980
     dos_month = stamp[1]
     dos_day = stamp[2]
     dos_hour = stamp[3]
     dos_min = stamp[4]
     dos_sec = stamp[5] * 2
     if (dos_year in range(1970,2100)) or not (dos_month in range(1,13)) or not (dos_day in range(1,32)) or not (dos_hour in range(0,24)) or not (dos_min in range(0,60)) or not (dos_sec in range(0,60)):
         dt_obj = datetime.datetime(dos_year, dos_month, dos_day, dos_hour, dos_min, dos_sec)
         return dt_obj.strftime('%Y-%m-%d %H:%M:%S')
     return "Not a valid MS DOS timestamp"

 binary = lief.parse(sys.argv[1])
 ts = binary.header.time_date_stamps
 if ts == 0x2a425e19:
     print('Found binary compiled with Delphi 4 - Delphi 2006')
     if binary.has_resources:
         root = binary.resources
         if root.time_date_stamp != 0:
             ts = root.time_date_stamp
             dos_time = from_msdos(ts)
             print(f'_IMAGE_RESOURCE_DIRECTORY: {hex(ts)} -&gt; {dos_time}')
         else:
             print('Timestamp of _IMAGE_RESOURCE_DIRECTORY is set to zero')
     else:
         print('Binary has no resources.')
 else:
     utc_time = datetime.datetime.utcfromtimestamp(ts)
     print('Likely not a binary compiled with Delphi 4 - Delphi 2006')
     print(hex(ts) + ' -&gt; ' + utc_time.strftime("%Y-%m-%d %H:%M:%S +00:00 (UTC)"))
</code></pre></div></div>

<p>I tested it with an older Azorult (version 3.1) sample:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight language-bash"><code class=" language-bash">&gt; python lief_delphi_ts.py azor3.1_patched_fixed.pe32                                                 
Found binary compiled with Delphi 4 - Delphi 2006
 _IMAGE_RESOURCE_DIRECTORY: 0x4cbe1371 -&gt; 2018-05-30 02:27:34
</code></pre></div></div>

<p>This looks a lot better. First, it matches the Delphi timestamp in the COFF File Header as expected. Luckily, there are resources and hence a <strong><em><code class=" highlighter-rouge language-plaintext">_IMAGE_RESOURCE_DIRECTORY</code></em></strong> struct. The date <code class=" highlighter-rouge language-plaintext">2018-05-30</code> seems to be a reasonable compilation timestamp for an Azorult version 3.1 sample.</p>

<h2 id="what-can-we-do-with-pe-timestamps">What can we do with PE timestamps?</h2>

<p>Now that we know where we can find PE timestamps and how we can read them using a wide range of tools, this section answers the final question: what can we do with PE timestamps? The following sections should inspire what we can do with them but also warn you once more that relying solely on this feature alone can certainly be very misleading.</p>

<h3 id="use-case-determine-probable-intrusion-date">Use case: Determine probable intrusion date</h3>

<p>If timestamps found in PE files were always reliable, they could be used to determine probable intrusion dates, <strong>especially if you are an observer on the outside</strong>. For instance, it is <a href="https://0xc0decafe.com/never-upload-ransomware-samples-to-the-internet/">common to hunt for ransomware</a> samples on online cloud services like VirusTotal as these samples contain information that can identify the possible victim.</p>

<p>For instance, CL0P ransomware <a href="https://www.telekom.com/en/blog/group/article/inside-of-cl0p-s-ransomware-operation-615824">timestamps are reliable</a>. Firstly, <a href="https://www.telekom.com/en/blog/group/article/inside-of-cl0p-s-ransomware-operation-615824">incident response engagements</a> suggest this. Secondly, the temporal correlation between the sample timestamps, the first submission to VirusTotal, and the publication of the victim’s data <a href="https://www.telekom.com/en/blog/group/article/inside-of-cl0p-s-ransomware-operation-615824">on their leak portal</a> seem to be in line. If you combine these factors then you can likely estimate the deployment date of the ransomware from the outside.</p>

<p>Nevertheless, this is in theory not limited to ransomware deployments. PE timestamps of samples that were used in a certain intrusion (possible one in the interest of the public domain) can be utilized to estimate the intrusion dates of nation-state actors like <a href="https://malpedia.caad.fkie.fraunhofer.de/details/win.winnti">Winnti</a>. Samples of Winnti typically contain information such as a <a href="https://www.welivesecurity.com/wp-content/uploads/2019/10/ESET_Winnti.pdf">C&amp;C domain and a campaign ID</a> that can be used to guess possible victims. In addition, PE timestamps seem to be <a href="https://quointelligence.eu/2020/04/winnti-group-insights-from-the-past/">reliable to a certain degree</a> to estimate at least the year of the intrusion.</p>

<h3 id="use-case-timeline-of-threat-actors-campaigns-and-threat-actors-working-hours">Use case: Timeline of threat actor’s campaigns and threat actor’s working hours</h3>

<p>As stated by Bartholomew &amp; Guerrero-Saade in their exceptional paper “<a href="https://media.kasperskycontenthub.com/wp-content/uploads/sites/43/2017/10/20114955/Bartholomew-GuerreroSaade-VB2016.pdf">Wave your false flags!</a>“, timestamps allow for creating a timeline of a threat actor’s campaigns or deduce their working hours:</p>

<blockquote>
  <p>A great benefit of the Portable Executable file format is the inclusion of compilation times. Though these can be altered with ease, many samples include original timestamps. Beyond an obvious indication of an actor’s longevity, timestamps allow for an understanding of specific campaigns as well as the evolution of an actor’s toolkit throughout the years. With a large enough collection of related samples, it’s also possible to create a timeline of the campaign operators’ workday. Where these operate in any professional setting or with any semblance of discipline, it’s possible to match the normal peaks and troughs of a workday and pinpoint a general timezone for their operations.</p>

  <p><cite>Bartholomew &amp; Guerrero-Saade – Wave your false flags!</cite></p>
</blockquote>

<p>There are at least two commonly plot types possible based on the PE timestamps:</p>

<ul>
  <li>timeline of the malware samples/families (see Page 32 of <a href="https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/mandiant-apt1-report.pdf">Mandiant’s APT1 report</a> for a great example)</li>
  <li>heatmap by day of week and hour of day (similar to the <a href="https://blog.exploratory.io/google-analytics-visualize-sessions-by-day-hour-with-heatmap-ed767f9386a8?gi=808c905fe174">ones typically found in web traffic analysis</a>)</li>
</ul>

<p>Bartholomew &amp; Guerrero-Saade stated “<em>With a large enough collection of related samples</em>” all these cool things can be done. Honestly, I don’t have a large number of samples for this blog post at hand. Nevertheless, I’ve plotted a tiny timeline of the different SDBBot versions published (based on the PE timestamps) in Summer 2020. The samples are on <a href="https://bazaar.abuse.ch/browse.php?search=tag%3Asdbbot">MalwareBazaar</a>.</p>

<p><img src="https://0xc0decafe.com/wp-content/uploads/2021/01/ts_sdbbot_summer_2020-1-1024x928.png" alt="Timeline of PE timestamps vs versions of SDBBot" /></p>

<p>Of course, the is room for improvement, and not speaking of the horrible design. For instance, we could plot tiny red dots on the X-axis for every day the threat actor was active. In this case, this should give us a workday / weekend pattern.</p>

<h3 id="use-case-pinpoint-a-threat-actor-to-a-timezone">Use case: Pinpoint a threat actor to a timezone</h3>

<p>The previous section mentions that the timezone of a threat actor can be pinpointed based on PE timestamps. In order for this to work out, there are two requirements:</p>

<ul>
  <li>“<em>large enough collection of related samples</em>” that we can attribute to the threat actor without a doubt</li>
  <li>certain confidence that the threat actor did not tamper with the PE timestamps</li>
</ul>

<p>It is likely that the PE timestamps fall into a certain range if the threat actor works in a professional environment with regular office hours. Likely, most samples will be compiled within an 8 to 12 hours range, which maps to a 9 to 5 pattern plus/minus two hours. Furthermore, there are likely one or two days off like Saturday or Sunday. But this might depend on the cultural origin of the threat actor. For instance, <a href="https://en.wikipedia.org/wiki/996_working_hour_system">996 working hour system</a> is common in the People’s Republic of China. In addition, there could also be thirty minutes and up to two hours of lunch breaks.</p>

<p>If you can identify such a pattern, then you add/subtract the difference of hours so that this maps to the 9 AM to 5 PM range of a timezone. In case your plot does not reveal a 9 to 5 pattern, then there are still possible explanations. In case you can see two possible 9 to 5 patterns then this could indicate shift work.</p>

<p>Finally, another warning example of why you should not blindly trust PE timestamps. Imagine that you’ve dozens of samples of a threat actor. You are pretty confident that this threat actor works normal working hours from 9 AM to 5 PM (GMT+0). You could assume that this threat actor may work in the United Kingdom or in Portugal if you blindly and solely rely on these timestamps.</p>

<p>Suppose that later on, you’ve got additional information from incident response engagements. Now, it seems that the threat actor works from 12 PM to 8 PM (GMT+0). This would map from 9 AM to 5 PM (GMT+3). Possible countries would now be, for instance, Russia or Turkey. How can you really be sure that the threat actor did not manipulate the PE timestamps and subtracted three hours from each and every timestamp found in the PE files?</p>

    </div><!-- .post-content -->
    <div class="post-share">
      <span>Share:</span>
      <a target="_blank" href="https://twitter.com/intent/tweet?text=The%20malware%20analyst’s%20guide%20to%20PE%20timestamps&amp;url=https://0xc0decafe.com/malware-analyst-guide-to-pe-timestamps" rel="noopener">Twitter</a>
      <a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://0xc0decafe.com/malware-analyst-guide-to-pe-timestamps&amp;t=The%20malware%20analyst’s%20guide%20to%20PE%20timestamps" rel="noopener">Facebook</a>
    </div><!-- .share-post -->
    <div class="author-box">
      
      <div class="author-avatar" style="background-image: url('images/author.jpg')"><span class="screen-reader-text">Thomas Barabosch's Picture</span></div>
      
      <div class="author-details">
        <h2 class="author-title">About Thomas Barabosch</h2>
        <div class="author-bio"><p>Thomas holds a PhD in computer science. He is passionately engaged in malware analysis, threat actor tracking, and bug hunting. Throughout the last years he has found numerous vulnerabilities in low-level software and participated in several botnet take-downs. In his blogs he tells techies and non-techies stories about his adventures in binary code wonderland.</p>
</div>
        
        <span class="author-location">Germany</span>
        
        
        <span class="author-website"><a href="https://0xc0decafe.com/" target="_blank" rel="noopener">https://0xc0decafe.com/</a></span>
        
      </div><!-- .author-details -->
    </div><!-- .author-box -->
  </article><!-- .post -->

  

</main><!-- .main-content -->

      <footer class="site-footer">
  <div class="offsite-links">
    
      
<a href="https://twitter.com/tbarabosch" target="_blank" rel="noopener">
  <span class="fa-twitter" aria-hidden="true"></span>
  <span class="screen-reader-text">Twitter</span>
</a>

<a href="https://github.com/tbarabosch" target="_blank" rel="noopener">
  <span class="fa-github" aria-hidden="true"></span>
  <span class="screen-reader-text">GitHub</span>
</a>

    
  </div><!-- .offsite-links -->
  <div class="footer-bottom">
    <div class="site-info">
      <p>© 2022 Thomas Barabosch</p>

    </div><!-- .site-info -->
    <a href="#page" id="back-to-top" class="back-to-top"><span class="screen-reader-text">Back to the top </span>↑</a>
  </div><!-- .footer-bottom -->
</footer><!-- .site-footer -->

    </div><!-- .inner -->
  </div><!-- .site -->

  <script src="/assets/js/plugins.js"></script>
  <script src="/assets/js/custom.js"></script>



</body></html>
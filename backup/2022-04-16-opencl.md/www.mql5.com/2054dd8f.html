<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="zh" class=""><head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
  <meta http-equiv="x-dns-prefetch-control" content="on" />
  <link rel="dns-prefetch" href="https://c.mql5.com" />
      <meta name="description" content="本文要重点讲述的是一些优化能力，但至少要对 OpenCL 内核借以执行的基本硬件多少有些了解，才能启动这些能力。获取的数据远非最高值，但即便是这样，也建议充分利用现有资源（由该终端开发人员实施的 OpenCL API 不允许控制对于优化而言很重要的一些参数 - 尤其是工作组的大小），通过主机程序执行获得的增益是非常可观的。" />
        <meta property="og:url" content="https://www.mql5.com/zh/articles/407" />
      <meta property="og:title" content="OpenCL：从朴素到更具深度的编程" />
        <meta property="og:description" content="本文要重点讲述的是一些优化能力，但至少要对 OpenCL 内核借以执行的基本硬件多少有些了解，才能启动这些能力。获取的数据远非最高值，但即便是这样，也建议充分利用现有资源（由该终端开发人员实施的 OpenCL API 不允许控制对于优化而言很重要的一些参数 - 尤其是工作组的大小），通过主机程序执行获得的增益是非常可观的。" />
      <meta property="vk:image" content="https://c.mql5.com/i/og/articles/fb/zh/0000/407.jpg?date=1511519564" />
      <meta property="og:image" content="https://c.mql5.com/i/og/articles/fb/zh/0000/407.jpg?date=1511519564" />
        <meta property="og:image:width" content="1200" />
        <meta property="og:image:height" content="630" />
        <meta property="og:type" content="article" />
        <meta property="og:updated_time" content="1511519564" />
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:site" content="@mql5com" />
      <meta name="twitter:image" content="https://c.mql5.com/i/og/articles/fb/zh/0000/407.jpg?date=1511519564" />
  <meta name="theme-color" content="#4a76b8" />
  <meta name="format-detection" content="telephone=no" />
  <link rel="shortcut icon" href="https://c.mql5.com/i/favicon.ico" />
  <meta name="msapplication-config" content="none" />
  <meta name="referrer" content="no-referrer-when-downgrade" />
  <meta property="qc:admins" content="36367170677651456375" />
  <meta property="wb:webmaster" content="073d7690269bcd81" />
      <link href="https://c.mql5.com/styles/core.6b12145e357da82f6a3e3d7f3ba1b435.css" type="text/css" rel="stylesheet" media="all" />
    <link href="https://c.mql5.com/styles/all.6eab56d52d353886d9e8e90496168403.css" type="text/css" rel="stylesheet" media="all" />
    <link href="https://c.mql5.com/styles/articles.bd2fdc67d99089c7e47480289d49202c.css" type="text/css" rel="stylesheet" media="all" />
        <link href="/zh/articles/rss" rel="alternate" type="application/rss+xml" title="有关MetaTrader 5自动交易和技术指标的开发和应用程序的文章" />
      <link rel="canonical" href="https://www.mql5.com/zh/articles/407" />
        <link rel="alternate" hreflang="en" href="https://www.mql5.com/en/articles/407" />
        <link rel="alternate" hreflang="ru" href="https://www.mql5.com/ru/articles/407" />
        <link rel="alternate" hreflang="zh" href="https://www.mql5.com/zh/articles/407" />
        <link rel="alternate" hreflang="es" href="https://www.mql5.com/es/articles/407" />
        <link rel="alternate" hreflang="de" href="https://www.mql5.com/de/articles/407" />
        <link rel="alternate" hreflang="ja" href="https://www.mql5.com/ja/articles/407" />
        <link rel="alternate" hreflang="pt" href="https://www.mql5.com/pt/articles/407" />
        <link rel="alternate" hreflang="ko" href="https://www.mql5.com/ko/articles/407" />
        <link rel="alternate" hreflang="fr" href="https://www.mql5.com/fr/articles/407" />
        <link rel="alternate" hreflang="it" href="https://www.mql5.com/it/articles/407" />
        <link rel="alternate" hreflang="tr" href="https://www.mql5.com/tr/articles/407" />
  <title>OpenCL：从朴素到更具深度的编程 - MQL5文章</title>


<script type="text/javascript" async="" src="https://cdn.chatbot.com/widget/plugin.js"></script><script async="" defer="" src="/tz/core.js"></script><script type="text/javascript">
  !function(){window.mqGlobal={};var t=!1,n=!1,e=[],o=[],i=[];function d(t){var n;for(n=0;n&lt;t.length;n+=1)t[n]()}function c(){t||(t=!0,d(e),d(o),o=[],e=[])}function a(){c(),n||(n=!0,d(i),i=[])}if(mqGlobal.AddOnReady=function(n,i){t?n(document):i?e.push(n):o.push(n)},mqGlobal.AddOnLoad=function(t){n?t(document):i.push(t)},mqGlobal.AddOnActiveWindowChange=function(t){this._onvisibility||(this._onvisibility=[]),this._onvisibility[this._onvisibility.length]=t},document.addEventListener)document.addEventListener("DOMContentLoaded",c,!1),window.addEventListener("load",a,!1);else if(document.attachEvent&amp;&amp;(document.attachEvent("onreadystatechange",(function(){switch(document.readyState){case"interactive":c();break;case"complete":a()}})),window.attachEvent("onload",a),document.documentElement.doScroll&amp;&amp;window==window.top)){!function n(){if(!t&amp;&amp;document.body)try{document.documentElement.doScroll("left"),c()}catch(t){setTimeout(n,0)}}()}}();
  mqGlobal.CookieDomain = ".mql5.com";
  mqGlobal.Language = 'zh';
  mqGlobal.IsMobile = false;
  mqGlobal.ClearRteStorage = function (e) { if (window.GStorage || (window.GStorage = globalStorage()), window.GStorage.supported) try { var o = e; window.GStorage.getItem("rte_autosave_uid", function (e, t) { t == o &amp;&amp; (window.GStorage.removeItem("rte_autosave_text"), window.GStorage.removeItem("rte_autosave_date"), window.GStorage.removeItem("rte_autosave_uid")) }) } catch (e) { } };
</script>  
    <script type="text/javascript">
    
    </script>
      <script src="https://c.mql5.com/js/all.c4fc3d3d688b228c01acc063a33c77cb.js" type="text/javascript" defer="defer"></script>
    <script src="https://c.mql5.com/js/articles.49ca6700052cb4f99c8e07a089841b32.js" type="text/javascript" defer="defer"></script>

<script type="text/javascript" src="https://cdn.chatbot.com/widget/polyfill.js" async=""></script><script type="text/javascript" src="https://cdn.chatbot.com/widget/v2/plugin.js" async=""></script><style id="chatbot-stylesheet" type="text/css">html.chatbot-mobile-opened {
    height: 100vh;
}

html.chatbot-mobile-opened &gt; body {
    position: fixed;
    width: 100%;
    height: 100%;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    overflow-y: hidden;
}
</style></head>
<body>
  <div class="cover" id="cover">

    <div class="head">
      <a href="https://www.mql5.com" class="head__logo" title="MQL5 - MetaTrader 5客户端内置的交易策略语言"></a>
      <ul id="mainmenu" class="menu dropdown" style="padding-right: 25px; margin-right: 212px;">
        <li class="selected">
              <a id="mainMenuSelected" href="#">
                <span class="on">文章</span><span class="off">部分</span>
              </a>
          <ul id="mainmenuItems">
            
                    <li><a href="/zh/forum" data-fz-event="MQL5+Menu+Forum"><span>论坛</span></a></li>
                    <li><a href="/zh/market" data-fz-event="MQL5+Menu+Market"><span>市场</span></a></li>
                    <li><a href="/zh/signals" data-fz-event="MQL5+Menu+Signals"><span>信号</span></a></li>
                    <li><a href="/zh/job" data-fz-event="MQL5+Menu+Job"><span>自由职业者</span></a></li>
                    <li><a href="/zh/quotes/overview" data-fz-event="MQL5+Menu+Overview"><span>比率</span></a></li>
                    <li><a href="/zh/trading" data-fz-event="MQL5+Menu+Trading"><span>网页端</span></a></li>
                    <li><a href="/zh/economic-calendar" data-fz-event="MQL5+Menu+Economic+Calendar"><span>经济日历</span></a></li>
                    <li><a href="/zh/vps" data-fz-event="MQL5+Menu+VPS"><span>VPS</span></a></li>
                    <li class="selected"><a href="/zh/articles" data-fz-event="MQL5+Menu+Articles"><span>文章</span></a></li>
                    <li><a href="/zh/code" data-fz-event="MQL5+Menu+CodeBase"><span>代码库</span></a></li>
                    <li><a href="/zh/docs" data-fz-event="MQL5+Menu+Docs"><span>文档</span></a></li>
                    <li class="main-menu__about-link"><a href="/zh/about"><span>关于</span></a></li>
          </ul>
        </li>
        <li><input class="blurHandler" id="mainMenuBlurHandler" type="checkbox" /></li>
      </ul>
      <div class="head__toolbar" id="headerToolbar">
          <div class="container loginRegister"><ul id="loginRegisterButtons"><li><a class="login" title="请登录，支持OpenID" href="https://www.mql5.com/zh/auth_login" data-fz-event="MQL5+Menu+Siginin">登录</a></li><li><a class="registration zh" title="请注册" href="https://www.mql5.com/zh/auth_register" data-fz-event="MQL5+Menu+Register" onclick="window.fpush('MQL5+Button+Click');">创建账户</a></li></ul></div>
        <div class="container"><div class="toggle-button" id="sidebarToggleButton"><i></i><i></i><i></i></div></div>

        <div class="group-menu" id="groupMenu">

          <div class="container lang-menu-container">
            <div id="langMenuContainer" class="lang-menu">
              <input class="blurHandler" id="langmenuBlurHandler" type="checkbox" />
              <ul class="lang-menu__list" id="langmenu">
                <li class="lang-menu__list-item"><a href="/en/articles"><i class="icons-languages icons-languages_en"></i><span>English</span></a></li>
<li class="lang-menu__list-item"><a href="/ru/articles"><i class="icons-languages icons-languages_ru"></i><span>Русский</span></a></li>
<li class="lang-menu__list-item lang-menu__list-item_selected"><a href="/zh/articles"><i class="icons-languages icons-languages_zh"></i><span>中文</span></a></li>
<li class="lang-menu__list-item"><a href="/es/articles"><i class="icons-languages icons-languages_es"></i><span>Español</span></a></li>
<li class="lang-menu__list-item"><a href="/pt/articles"><i class="icons-languages icons-languages_pt"></i><span>Português</span></a></li>
<li class="lang-menu__list-item"><a href="/ja/articles"><i class="icons-languages icons-languages_ja"></i><span>日本語</span></a></li>
<li class="lang-menu__list-item"><a href="/de/articles"><i class="icons-languages icons-languages_de"></i><span>Deutsch</span></a></li>
<li class="lang-menu__list-item"><a href="/ko/articles"><i class="icons-languages icons-languages_ko"></i><span>한국어</span></a></li>
<li class="lang-menu__list-item"><a href="/fr/articles"><i class="icons-languages icons-languages_fr"></i><span>Français</span></a></li>
<li class="lang-menu__list-item"><a href="/it/articles"><i class="icons-languages icons-languages_it"></i><span>Italiano</span></a></li>
<li class="lang-menu__list-item"><a href="/tr/articles"><i class="icons-languages icons-languages_tr"></i><span>Türkçe</span></a></li>

              </ul>
            </div>
          </div>

          <div class="container search-box-container">
            <div id="searchBoxContainer" class="search-box">

<form action="https://www.mql5.com/zh/search" onsubmit="window.fpush(&quot;MQL5+Menu+Search&quot;); document.location.assign((&quot;https://www.mql5.com/zh/search&quot;) + ($(&quot;keyword&quot;).value.length&gt;0?(&quot;#!keyword=&quot;+encodeURIComponent($(&quot;keyword&quot;).value)):&quot;&quot;)); if(document.location.href.indexOf(&quot;/zh/search#&quot;)&gt;=0)setTimeout(function(){document.location.reload(true);},10);return false;" id="main_search_form" class="header-search" method="post">
<div class="header-search__box"><div class="header-search__input-wrapper"><input name="keyword" type="text" title="输入查找文本" id="keyword" autocomplete="off" /></div></div><input type="submit" value="" class="header-search__hidden-submit" /><div class="header-search__submit" id="searchSubmit"></div></form>            </div>
          </div>
        </div>
      </div>
      <div class="sub-nav__container" style="right: 212px;" id="subNavContainer">
        <div class="sub-nav__toggle" id="subNavToggle">...</div>
        <ul id="subNavList"><li><a href="/zh/code" data-fz-event="MQL5+Menu+CodeBase"><span>代码库</span></a></li><li><a href="/zh/docs" data-fz-event="MQL5+Menu+Docs"><span>文档</span></a></li></ul>
        <input class="blurHandler" id="blurHandlerSubNav" type="checkbox" />
      </div>
    </div>
<div id="bfogggabsofabcpxuzmgaibarmaxasdrj" class="rfk7n1fsaberob9fi ff"></div>    <div class="body" id="bodyContent">
      <div class="top-band">
        


      </div>
      




<div id="left-panel" class="left-panel left-panel_270">
  <div class="tree-menu tree-menu_articles">
    <ul class="tree-menu__list"><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5"><i class="icons-sidebar icons-sidebar_mt"></i>MetaTrader 5</a><ul class="tree-menu__list tree-menu__list_nested"><li class="tree-menu__item tree-menu__item_selected"><a class="tree-menu__link" href="/zh/articles/mt5/examples"><i class="icons-sidebar icons-sidebar_examples"></i>示例</a><ul class="tree-menu__list tree-menu__list_nested"><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/examples_indicators"><i class="icons-sidebar icons-sidebar_examples_indicators"></i>指标</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/examples_experts"><i class="icons-sidebar icons-sidebar_examples_experts"></i>专家</a></li></ul></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/strategy_tester"><i class="icons-sidebar icons-sidebar_strategy_tester"></i>测试者</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/trading"><i class="icons-sidebar icons-sidebar_trading"></i>交易</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/trading_systems"><i class="icons-sidebar icons-sidebar_trading_systems"></i>交易系统</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/integration"><i class="icons-sidebar icons-sidebar_integration"></i>积分</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/indicators"><i class="icons-sidebar icons-sidebar_indicator"></i>指标</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/expert_advisors"><i class="icons-sidebar icons-sidebar_expert"></i>EA交易</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/statistics"><i class="icons-sidebar icons-sidebar_statistics"></i>统计分析</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt5/interviews"><i class="icons-sidebar icons-sidebar_interviews"></i>采访</a></li></ul></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4"><i class="icons-sidebar icons-sidebar_mt"></i>MetaTrader 4</a><ul class="tree-menu__list tree-menu__list_nested"><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/examples"><i class="icons-sidebar icons-sidebar_examples"></i>示例</a><ul class="tree-menu__list tree-menu__list_nested"><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/examples_indicators"><i class="icons-sidebar icons-sidebar_examples_indicators"></i>指标</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/examples_experts"><i class="icons-sidebar icons-sidebar_examples_experts"></i>专家</a></li></ul></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/strategy_tester"><i class="icons-sidebar icons-sidebar_strategy_tester"></i>测试者</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/trading"><i class="icons-sidebar icons-sidebar_trading"></i>交易</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/trading_systems"><i class="icons-sidebar icons-sidebar_trading_systems"></i>交易系统</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/integration"><i class="icons-sidebar icons-sidebar_integration"></i>积分</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/indicators"><i class="icons-sidebar icons-sidebar_indicator"></i>指标</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/expert_advisors"><i class="icons-sidebar icons-sidebar_expert"></i>EA交易</a></li><li class="tree-menu__item"><a class="tree-menu__link" href="/zh/articles/mt4/statistics"><i class="icons-sidebar icons-sidebar_statistics"></i>统计分析</a></li></ul></li></ul>
  </div>

  

    <div class="hints-panel">
      <div class="hints-panel__item">
        <i class="icons-hints icons-hints_like"></i>
        <div class="hints-panel__content">
          您喜欢这篇文章？<br />
          分享或-<br />发布<a href="https://www.mql5.com/zh/articles/407" target="_blank">链接</a>！
        </div>
      </div>
      <div class="hints-panel__item">
        <i class="icons-hints icons-hints_mt-5"></i>
        <div class="hints-panel__content">
          使用<a href="https://download.metatrader.com/cdn/web/metaquotes.software.corp/mt5/mt5setup.exe?utm_source=www.mql5.com&amp;utm_campaign=download" data-fz-event="MetaTrader+5+Desktop+Download" rel="nofollow">MetaTrader 5</a>新的可能性
        </div>
      </div>
    </div>
<div id="vgckrufggwxdtfscpyalmenexmvhljduja" class="rgchtrbl7rr5mdcoi ff"></div>      <div class="similar-author-articles ui">
        <h4 class="similar-author-articles__title">相似文章</h4>
        <ul class="similar-author-articles__list">
            <li>
              <a href="/zh/articles/10361" data-fz-event="MQL5+Article+Similar+Article">在 MQL 应用程序中运用 CCanvas 类</a>
            </li>
            <li>
              <a href="/zh/articles/10229" data-fz-event="MQL5+Article+Similar+Article">在一张图表上的多个指标（第 01 部分）：理解概念</a>
            </li>
            <li>
              <a href="/zh/articles/10417" data-fz-event="MQL5+Article+Similar+Article">DoEasy 函数库中的图形（第九十六部分）：窗体对象中的图形和鼠标事件的处理</a>
            </li>
            <li>
              <a href="/zh/articles/10387" data-fz-event="MQL5+Article+Similar+Article">DoEasy 函数库中的图形（第九十五部分）：复合图形对象控件</a>
            </li>
            <li>
              <a href="/zh/articles/10356" data-fz-event="MQL5+Article+Similar+Article">DoEasy 函数库中的图形（第九十四部分）：移动和删除复合图形对象</a>
            </li>
        </ul>
      </div>
</div>


<div class="articles-content splashed">
  <div>
      <div class="article-tools">
           <div>
            <span class="popup framed client flags">
              <a class="dropdown" href="javascript:void(false);"><span class="icons-languages icons-languages_zh"></span><i></i></a>
              <span class="popup">
                <span class="tip"><span></span></span>
                <span class="items">
                  <a href="/en/articles/407">English</a> <a href="/ru/articles/407">Русский</a> <a href="/es/articles/407">Español</a> <a href="/de/articles/407">Deutsch</a> <a href="/ja/articles/407">日本語</a> <a href="/pt/articles/407">Português</a> <a href="/ko/articles/407">한국어</a> <a href="/fr/articles/407">Français</a> <a href="/it/articles/407">Italiano</a> <a href="/tr/articles/407">Türkçe</a>
                </span>
              </span>
            </span>
          </div>
          
        <div><span class="share shareWrapperIconed"><a class="share midIco" id="share_2_1_407" onclick="shareManager.OpenShareEditor(this,'在社交网络与好友分享','/zh/publish/2/1/407',false);return false;" title="分享社交网络" href="javascript:void(0);"></a></span></div>
          
        <div>
          <a href="#pocket" title="允许您插入一个完整的说明以及适当的注释内容。" onclick="return Pocket.Add(this,'zh',2,1,407);" class="pocket icon">到包裹</a>
        </div>
        <div><a href="/zh/articles/407?print=" target="_blank" class="print" rel="nofollow" title="打印优化版本"></a></div>

      </div>
      <div class="article-head">
        <div class="splash">
          <div></div>
        </div>
        <div class="caption">
          <div class="category">
            <a href="/zh/articles/mt5">MetaTrader 5</a>              —
              <a href="/zh/articles/mt5/examples">示例</a>
          </div>

          <h1>OpenCL：从朴素到更具深度的编程</h1>
          <div class="date">9 一月 2014, 11:43</div>
        </div>
          <div class="avatar" onmouseover="window.tooltip &amp;&amp; window.tooltip(this,$('user_link_mathemat_tooltip').cloneNode(true))">
            <img src="https://c.mql5.com/avatar/2014/9/54190607-0000.jpg" title="Sceptic Philozoff" alt="Sceptic Philozoff" loading="lazy" width="60" height="60" />
          </div>
          <div class="author">
            <a class="author" href="/zh/users/mathemat" onmouseover="window.tooltip &amp;&amp; window.tooltip(this,$('user_link_mathemat_tooltip').cloneNode(true))">Sceptic Philozoff</a><div style="display:none;"><div id="user_link_mathemat_tooltip"><a target="_blank" href="/zh/users/mathemat" class="user-tooltip">
  <div class="user-tooltip__avatar">
    <img src="https://c.mql5.com/avatar/2014/9/54190607-0000.jpg" width="60" height="60" alt="Sceptic Philozoff" title="Sceptic Philozoff" loading="lazy" />
  </div>
  <div class="user-tooltip__line user-tooltip__name">
    <span class="author">Sceptic Philozoff</span>
  </div>  <div class="user-tooltip__line"><span class="user-tooltip__counters">
14694 评论, 69 主题  </span></div>
</a>
</div></div>
          </div>
        <div class="counters">
          <div class="commentsCounter" title="评论">0<i class="icon comments"></i></div>
          <div class="viewsCounter" title="查看"><i class="icon views"></i>6 416</div>
        </div>
      </div>
    <div class="content">
      <div class="inner">
        <h3>简介<br /></h3>

<p style="text-align:justify;">第一篇文章<a target="_blank" href="/zh/articles/405">《OpenCL：连接并行世界的桥梁》</a>是对 OpenCL 主题内容的一个简要介绍。它解决了 OpenCL 中程序（尽管不太准确，但亦称为一个内核）与 MQL5 的外部（主机）程序之间交互的基本问题。有些语言的性能（比如向量数据类型的使用），都是通过 pi = 3.14159265... 的计算举例证明。 <br /></p>

<p style="text-align:justify;">某些情况下程序的性能有可观的优化空间。但是，前文所述的都是朴素优化，因为它们并未考虑到执行所有计算要用到的硬件规格。而大多数情况下，此类规格的相关知识会让我们明明白白地实现明显超越 CPU 性能的提速。<br /></p>

<p style="text-align:justify;">为论述此类优化，作者不得不求助于那个不再原始、很可能是 OpenCL 相关文献中研究最为完善的一个示例。即两个大型矩阵相乘。 <br /></p>

<p style="text-align:justify;">我们进入主题 - OpenCL 存储模型以及其在实际硬件架构上实施的独特性。</p>

<h3><br />1. 现代计算设备的存储层次<br /></h3>
<p><b>1.1. OpenCL 存储模型</b><br /></p>

<p style="text-align:justify;">一般来说，根据计算机平台，各存储系统彼此之间的差异很大。比如说，现代所有的 CPU 都支持自动数据缓存；而与之对照的 GPU 却并不总是这样。<br /></p>

<p style="text-align:justify;">为确保代码的可移植性，OpenCL 中采用了一种抽象存储模型，需要在实际硬件上实施此模型的程序员和提供商都可以遵照。理论上，OpenCL 中定义的存储如下图所示：</p>

<p style="text-align:center;"><img alt="OpenCL 存储模型" title="OpenCL 存储模型" src="https://c.mql5.com/2/4/memory_model.PNG" height="513" width="608" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 1. OpenCL 存储模型</span><br /></p>

<p style="text-align:justify;">一旦将数据从主机传输到设备，就会将其存储于全局设备内存中。按相反方向传输的任何数据，亦会存储于全局内存中（但这次是到全局主机内存中）。关键词 __global （双下划线！）是一个修饰符，表示与特定指针关联的数据已被存储于全局内存中：<br /></p>

<pre class="code">__kernel <span class="keyword">void</span> foo( __global <span class="keyword">float</span> *A ) { <span class="comment">/// kernel code }</span></pre><div class="atten"><p><i></i> 设备中的所有计算单元均可访问<i>全局内存</i>，就像主机系统中的 RAM 一样。 <br /></p></div>

<p style="text-align:justify;">而常量存储器，与其名称不同的是，并不一定存储只读数据。该存储类型专为那些每个元素都可以同时被所有 <i></i><i>工作单元</i>访问的数据而设计。带有常数值的变量当然亦归入此类。OpenCL 模型中的常量存储器，是全局内存的一部分，而传输到全局内存的存储对象，则可因此指定为 __constant。<br /></p>

<p style="text-align:justify;">本地内存是指每个设备专用的高速暂存存储器。硬件中，它通常以片上存储器的形式存在，但是对于 OpenCL 没有完全相同的特定要求。 </p>

<div class="atten"><i>本地内存</i>可供整个<i></i><i>工作组</i>访问，即它在组内的所有工作单元中共享，且其它工作组不可访问。 <br /></div>

<p style="text-align:justify;">访问此类存储会导致低得多的延迟，而存储带宽亦会因此比全局存储大得多。我们会试着充分利用其较低的延迟来优化内核性能。<br /></p>
<p>根据 OpenCL 规范，本地内存中的变量既可以在内核头中声明：<br /></p>

<pre class="code">__kernel <span class="keyword">void</span> foo( __local <span class="keyword">float</span> *sharedData ) { }</pre>亦可在其主体内声明：<br /><pre class="code">__kernel <span class="keyword">void</span> foo( __global <span class="keyword">float</span> *A )
{
   __local <span class="keyword">float</span> sharedData[ <span class="number">64</span> ];   
}</pre>注意：动态数组不能在内核主体中声明；您始终都要指定其大小。<br />

<p style="text-align:justify;"><br />在下面针对两个大型矩阵相乘的内核优化过程中，您可以看出如何处理本地数据，以及作者经历过的、其于 MetaTrader 5 中蕴含的实施特征。</p>

<div class="atten">每个工作单元都有专用的<i></i><i>私有内存</i>。它仅供该单元访问，不会与其它工作单元共享。<br /></div>


<p style="text-align:justify;">不包含指针的局部变量与内核自变量默认都是私有型（如指定为不带 __local 修饰符）。实际情况中，这些变量通常都位于寄存器中。反过来也是一样，私有数组与 <a href="https://en.wikipedia.org/wiki/Register_pressure" rel="nofollow" title="https://en.wikipedia.org/wiki/Register_pressure" target="_blank">任何溢出寄存器</a>通常都位于片外存储，即较高的延迟存储。我们引用一些维基百科的相关信息：</p>

<div class="fquote"><p>在许多编程语言中，编程人员都会有任意地配置许多变量的错误观念。但在编译时，编译器必须决定在一个较小及有限寄存器组的系统中如何分配这些变量。并非所有变量都是在同一时间使用（或“活动”），所以有些寄存器可能被分配超过一个变量。然而，两个变量若在同一时间使用，就不可能在不破坏其值的情况下分配给相同的寄存器。  <br /></p>

<p>无法被分配到相同寄存器的变量必须保留在 RAM（随机存取存储器）中，在需要读取或写入时才会被加载，这个过程被称为溢出。RAM 访问速度明显低于寄存器访问速度，这会降低编译程序的运行速度，所以一个经过优化的编译器会尽可能的将更多的变量放置在寄存器。寄存器压力这个词被使用在当硬件寄存器数量比起理想数量少的状况，高压的情况通常代表需要更多溢出及重载。</p></div>寄存器压力是 GPU 编程要面对的现实，由于要在有限的芯片区域上布设大量的核心，所以不可能再放置许多的寄存器。<br />

<p style="text-align:justify;"><br />我们所说的 OpenCL 内存模型与现代 GPU 的存储结构非常相似。下图显示了 OpenCL 内存模型与 GPU AMD Radeon HD 6970 内存模型之间的关联。<br /></p>

<p style="text-align:center;"><img alt="图 2. Radeon HD 6970 存储结构与抽象 OpenCL 内存模型的关联" title="图 2. Radeon HD 6970 存储结构与抽象 OpenCL 内存模型的关联" src="https://c.mql5.com/2/4/Radeon_HD_6970_memory.png" height="402" width="747" style="vertical-align:middle;" /><br /></p>

<p style="text-align:center;"><span class="small">图 2. Radeon HD 6970 存储结构与抽象 OpenCL 内存模型的关联</span><br /></p><p>我们继续更加详细地研究研究与具体 GPU 内存实施相关的问题。</p><p><br /></p>
<p><b>1.2. 现代独立 GPU 中的内存</b><br /></p>

<p><i><b>1.2.1. 合并内存请求</b></i></p>

<p>对于内核性能的优化，此信息亦非常重要，因为主要目标是达到高存储带宽。</p><p> 看一看下图，更好地了解一下内存寻址过程：</p>

<p style="text-align:center;"><span class="small"><img alt="图 3. 全局设备内存中的寻址数据图" title="图 3. 全局设备内存中的寻址数据图" src="https://c.mql5.com/2/4/array_pointer__2.PNG" height="361" width="721" style="vertical-align:middle;" /><br /></span></p>

<p style="text-align:center;"><span class="small">图 3. 全局设备内存中的寻址数据图</span></p>
<p>假设指向某个整型变量 int 数组的指针为地址 Х = 0x00001232。每个 int 占用 4 字节内存。假设某<i></i><i>线程</i>（是对执行内核代码的某工作单元的一种软件模拟）的地址数据位于 Х[ 0 ]： <br /></p>

<pre class="code"><span class="keyword">int</span> tmp = X[ <span class="number">0</span> ];</pre>

<p style="text-align:justify;">我们假设存储总线宽度为 32 字节（256 位）。这种总线宽度在 Radeon HD 5870 之类的强大 GPU 中很常见。而其它某些 GPU 的数据总线宽度可能有所不同，比如有些 NVidia 型号达到 384 位甚至 512 位。<br /></p>

<p style="text-align:justify;">存储总线的寻址要与其结构对应，即首要的是其宽度。换言之，内存中的数据存储于每一个 32 字节（256 位）的块中。不管我们在 0x00001220 到 0x0000123F 的范围内如何编址（此范围内都是精确的 32 字节，您可以自己看），我们都会得到地址 0x00001220 作为读取的起始地址。 <br /></p>

<p style="text-align:justify;">访问地址 0x00001232 会返回地址在 0x00001220 到 0x0000123F 范围内的所有数据，即 8 个 int 数字。因此，仅有 4 个字节（一个 int 数字）的有用数据，而其余的 28 个字节（7 个 int 数字）则无用：<br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/1_int_from_8_only.PNG" height="222" width="584" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 4. 由内存获取所需数据的方案图</span><br /></p><p>我们需要的位于之前指定地址 - 0x00001232 - 处的数字，已包含于方案图之中。 <br /></p>

<p style="text-align:justify;">为能最大化使用此总线，GPU 尝试把通过不同线程访问的内存合并成为一个单一的存储请求；存储访问越少越好。背后的原因在于，访问全局设备内存会占用我们的时间，并由此极大地影响程序运行速度。看一看内核代码的下一行：<br /></p>

<pre class="code"><span class="keyword">int</span> tmp = X[ get_global_id( <span class="number">0</span> ) ]; </pre>

<p style="text-align:justify;">假设我们的数组 Х 来自前文给出的示例。那么，前 16 个线程（内核）就会访问从 0x00001232 到 0x00001272 的地址（此范围内有 16 个 int 数字，即 64 字节）。如果每个请求都通过内核独立发送，无需提前合并到一个单一内核中，那么 16 个请求中的每一个都会包含 4 字节的有用数据以及 28 字节的无用数据，所以总共就是 64 个已用字节以及 448 个未用字节。 <br /></p>

<p>此计算基于每次访问位于同一 32 字节存储块中某个地址都会返回绝对一致数据的事实。这是关键所在。将多个请求合并到单一、一致的请求会更加准确，从而减少无用的请求。此操作于下文均称为合并，而按此合并的请求则被称为<i>相干性</i>。</p><p style="text-align:justify;"><br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/3_accesses.PNG" height="194" width="440" style="vertical-align:middle;" /></p><p style="text-align:center;"><span class="small">图 5. 获取所需数据仅需三个存储请求</span><br /></p>

<p style="text-align:justify;">上图中每个单元格均为 4 字节。本例中， 3 个请求便已足够。如果数组的开头已按地址与每个 32 字节的存储块的开头地址对齐，那么甚至 2 个请求就够了。<br /></p>

<p style="text-align:justify;">在 AMD GPU 64 中，线程是<i>波前</i>的一部分，并因此应按 SIMD 执行中的相同指令执行。按 get_global_id( 0 ) 排列的 16 个线程，刚好是波前的四分之一，都被合并为一个相干请求，有实现总线的高效使用。 <br /></p>

<p style="text-align:justify;">下图所示，是一致性请求所需存储带宽与非相干性（即“自发”请求）的对比说明。这里使用的是 Radeon HD 5870，但 NVidia 显卡亦可见类似结果。<br /><br /></p><p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/coalescenced-uncoalescenced-BW.PNG" height="294" width="635" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 6. 相干与非相干请求所需存储带宽的对比分析     </span><br /></p>

<p>可以清楚地看出，相干存储请求允许将存储带宽加大一个数量级。<br /></p>
<br /><p><i><b>1.2.2. 存储库</b></i></p>

<p style="text-align:justify;">存储器由数据实际存放的<i>库</i>构成。在现代 GPU 中，通常都是 32 位（4 字节）字。串行数据存放于相邻的存储库中。访问串行元素的线程组不会出现任何库冲突。<br /></p><p style="text-align:justify;">而库冲突的最大负面影响，则见于本地 GPU 内存当中。因此，最好是通过定位于不同存储库的相邻线程来访问本地数据。<br /></p>

<p style="text-align:justify;">在 AMD 硬件上，产生库冲突的波前直到所有本地内存操作结束之后才会停止。如此会导致<i>串行化</i>，要并行执行的代码块会借此串行执行。它对内核的性能有极其负面的影响。<br /><br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/no_conflicts_local.PNG" height="285" width="637" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 7. 不存在库冲突的存储访问方案图</span><br /></p>

<p>上图所示为不带库冲突的存储访问，因为所有线程都访问不同的数据。<br /></p><p>我们再来看一看存在库冲突的存储访问：</p><br /><p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/conflicts_local.PNG" height="286" width="328" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 8. 存在库冲突的存储访问</span><br /></p>

<p>但这一情况有例外：如果所有访问都是到一个相同的地址，则库可以执行一次<i>广播</i>以避免延迟：<br /><br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/broadcast.PNG" height="280" width="271" style="vertical-align:middle;" /></p><p style="text-align:center;"><span class="small">图 9. 所有线程均访问同一个地址</span><br /></p>

<p>访问全局内存时也会出现类似事件，但这种冲突的影响微乎其微。<br /><br /></p>

<i><b>1.2.3. GPU 内存：总结</b></i><br />
<ul>
<li>GPU 内存与 CPU 内存有所区别。利用 OpenCL 进行程序性能优化的主要目标，是确保最大化带宽，而非像在 CPU 上一样缩短延迟。</li>
<li>存储访问的本质，对于总线利用的效率影响巨大。总线使用率低即意味着运行速度低。</li>
<li>要改善代码的性能，存储访问最好是相干的。此外，最好也要避免库冲突。</li>
<li>硬件规格（总线宽度、存储库数量，以及可以合并为单一相干访问的线程数量）请见供应商提供的相关文档。</li>
</ul>
<br />
<p>以下方列出的 Radeon 5xxx 系列中的部分显卡规格为例：<br /><br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/58xx_table.PNG" height="874" width="625" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 10. 中高端 Radeon HD 58xx 显卡的技术规格 <br /></span></p>
<p>现在，我们继续编程。<br /><br />
</p><h3>2. 大型方块矩阵相乘：从串行 CPU 代码到并行 GPU 代码 <br /></h3>
<p><b>2.1. MQL5 代码</b><br /></p>

<p style="text-align:justify;">对比前一篇文章<a target="_blank" href="/zh/articles/405">《OpenCL：连接并行世界的桥梁》</a>，手头的是标准任务，即两个矩阵相乘。之所以选择它，是因为从各个不同的来源渠道，都能找到大量有关此主题的信息。它们大都是通过这样或那样的方式，提供或多或少的协调解决方案。这就是我们要走的路，一步一步地澄清模型结构的意义，同时牢记：我们面对的是实际硬件。</p>
<p>下面是一个在线性代数领域中著名的矩阵乘法公式，专门针对计算机运算进行了修改。第一个指数是矩阵行号，第二个是列号。通过顺序将第一与第二矩阵中的每一个元素连续积添加到累积和的方式，计算出每一个输出矩阵元素。最终，此累积和就是计算得出的输出矩阵元素：<br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/matrix_mul_formula.PNG" height="177" width="333" style="vertical-align:middle;" /></p><p style="text-align:center;"><span class="small">图 11. 矩阵乘法公式</span><br /></p>

<p>图示如下：</p>



<p style="text-align:center;"><img alt="图 12. 矩阵乘法算法（以某输出矩阵元素的计算为例）图解" title="图 12. 矩阵乘法算法（以某输出矩阵元素的计算为例）图解" src="https://c.mql5.com/2/4/mul_picture__2.PNG" height="176" width="746" style="vertical-align:middle;" /><br /></p>

<p style="text-align:center;"><span class="small">图 12. 矩阵乘法算法（以某输出矩阵元素的计算为例）图解</span></p>

<p style="text-align:justify;">很容易就可以看出，只要两个矩阵的维数都等于 N，则相加与相乘的次数都可以通过函数 O(N^3) 估算得出：要计算每一个输出矩阵元素，您需要获取第一矩阵中某行与第二矩阵中某列的无向积。它大约需要 2*N 次相加和相乘。所需的估算通过乘以矩阵元素数量 N^2 获取。由此，粗略的代码运行时在相当大程度上取决于 N 的次方。 <br /></p>

<p>下文出于方便目的，矩阵的行数与列数均设置为 2000；它们可以为任意数字，但不能太大。<br /><br />MQL5 中的代码并非十分复杂：</p><pre class="code"><span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//|                                                matr_mul_2dim.mq5 |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="preprocessor">#define ROWS1           <span class="number">1000</span>        <span class="comment">// rows in the first matrix</span></span>
<span class="preprocessor">#define COLSROWS        <span class="number">1000</span>        <span class="comment">// columns in the first matrix = rows in the second matrix </span></span>
<span class="preprocessor">#define COLS2           <span class="number">1000</span>        <span class="comment">// columns in the second matrix</span></span>

<span class="keyword">float</span> first[ ROWS1  ][ COLSROWS ];  <span class="comment">// first matrix</span>
<span class="keyword">float</span> second[ COLSROWS ][ COLS2 ];  <span class="comment">// second matrix</span>
<span class="keyword">float</span> third[ ROWS1 ][ COLS2 ];      <span class="comment">// product</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| Script program start function                                    |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> <span class="functions">OnStart</span>()
  {
   <span class="functions">MathSrand</span>(<span class="functions">GetTickCount</span>());

   <span class="functions">Print</span>(<span class="string">"======================================="</span>);
   <span class="functions">Print</span>(<span class="string">"ROWS1 = "</span>+i2s(ROWS1)+<span class="string">"; COLSROWS = "</span>+i2s(COLSROWS)+<span class="string">"; COLS2 = "</span>+i2s(COLS2));

   genMatrices();
   <span class="functions">ArrayInitialize</span>(third,<span class="number">0.0</span>f);

<span class="comment">//--- execution on the CPU</span>
   <span class="keyword">uint</span> st1=<span class="functions">GetTickCount</span>();
   mul();
   <span class="keyword">double</span> time1=(<span class="keyword">double</span>)(<span class="functions">GetTickCount</span>()-st1)/<span class="number">1000</span>.;
   <span class="functions">Print</span>(<span class="string">"CPU: time = "</span>+<span class="functions">DoubleToString</span>(time1,<span class="number">3</span>)+<span class="string">" s."</span>);

   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| i2s                                                              |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">string</span> i2s(<span class="keyword">int</span> arg) { <span class="keyword">return</span> <span class="functions">IntegerToString</span>(arg); }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| genMatrices                                                      |</span>
<span class="comment">//| generate initial matrices; this generation is not reflected      |</span>
<span class="comment">//| in the final runtime calculation                                 |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> genMatrices()
  {
   <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;ROWS1; r++)
      <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;COLSROWS; c++)
         first[r][c]=genVal();

   <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;COLSROWS; r++)
      <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;COLS2; c++)
         second[r][c]=genVal();

   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| genVal                                                           |</span>
<span class="comment">//| generate one value of the matrix element:                        |</span>
<span class="comment">//| uniformly distributed value lying in the range [-0.5; 0.5]       |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">float</span> genVal()
  {
   <span class="keyword">return</span>(<span class="keyword">float</span>)(( <span class="functions">MathRand</span>()-<span class="number">16383.5</span>)/<span class="number">32767</span>.);
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| mul                                                              |</span>
<span class="comment">//| Main matrix multiplication function                              |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> mul()
  {
<span class="comment">// r-cr-c: 10.530 s </span>
   <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;ROWS1; r++)
      <span class="keyword">for</span>(<span class="keyword">int</span> cr=<span class="number">0</span>; cr&lt;COLSROWS; cr++)
         <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;COLS2; c++)
            third[r][c]+=first[r][cr]*second[cr][c];
<span class="comment"></span>
   <span class="keyword">return</span>;
  }<span class="comment"></span>
</pre><p style="text-align:center;"><span class="small">列表 1. 主机上的初始顺序程序</span></p><p>采用不同参数的性能结果：</p><pre class="code"><span class="number">2012.05</span>.<span class="number">19</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">11</span>    matr_mul_2dim (EURUSD,H1)    CPU: time = <span class="number">10.530</span> s.
<span class="number">2012.05</span>.<span class="number">19</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">00</span>    matr_mul_2dim (EURUSD,H1)    ROWS1 = <span class="number">1000</span>; COLSROWS = <span class="number">1000</span>; COLS2 = <span class="number">1000</span>
<span class="number">2012.05</span>.<span class="number">19</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">00</span>    matr_mul_2dim (EURUSD,H1)    =======================================

<span class="number">2012.05</span>.<span class="number">19</span> <span class="number">09</span>:<span class="number">41</span>:<span class="number">04</span>    matr_mul_2dim (EURUSD,H1)    CPU: time = <span class="number">83.663</span> s.
<span class="number">2012.05</span>.<span class="number">19</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">40</span>    matr_mul_2dim (EURUSD,H1)    ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">19</span> <span class="number">09</span>:<span class="number">39</span>:<span class="number">40</span>    matr_mul_2dim (EURUSD,H1)    =======================================</pre>

<p style="text-align:justify;"><br />可以看出，我们对于运行时对线性矩阵尺寸依赖性的估算看起来是正确的：所有矩阵维数增加两倍，就会导致运行时增加大约 8 倍。<br /></p>

<p style="text-align:justify;">简单说说这种算法：循环顺序可以在乘法函数 mul() 中任意更改。结果表明它对运行时有相当大的影响：最慢与最快运行时变量的比率约为 1.73。 <br /></p>

<p style="text-align:justify;">本文仅阐述了最快变量；其余经过测试的变量，均见本文末尾处随附的代码（matr_mul_2dim.mq5 文件）。在这方面，《OpenCL 编程指南》 (Aaftab Munshi、Benedict R. Gaster、Timothy G. Mattson、James Fung、Dan Ginsburg) 中曾作如下陈述（第 512 页）：</p>

<div class="fquote">[这些排列] 用于更换存储访问模式，并由此再次将缓冲数据作为三个通过 CPU 进行优化的矩阵的内容使用。<br /></div><p style="text-align:justify;">显然这些并非我们可以实施的初始“非并行”代码的全部优化。有一些与硬件（(S)SSEx 指令）相关，而其它的则是纯粹的算法，比如 <a href="https://en.wikipedia.org/wiki/Strassen" rel="nofollow's_algorithm" title="http://ru.wikipedia.org/wiki/Алгоритм_Штрассена" target="_blank">施特拉森算法</a>, <a href="https://en.wikipedia.org/wiki/Coppersmith%E2%80%93Winograd_algorithm" rel="nofollow" title="http://ru.wikipedia.org/wiki/Алгоритм_Копперсмита_—_Винограда" target="_blank">铜匠维诺格拉特算法</a>等。注意：导致速度大幅度超越传统算法的施特拉森算法的相乘矩阵尺寸非常小，仅为 64х64。本文中，我们会学习线性尺寸高达几千（大约高达 5000）的快速相乘矩阵。</p>

<br />

<p><b>2.2. 该算法于 OpenCL 中的第一次实施</b><br /></p>

<p style="text-align:justify;">现在，我们将此算法移植到 OpenCL，创建 ROWS1 （行1）* COLS2 （列2）线程，即由内核中删除两个外层循环。每个线程都会执行 COLSROWS 迭代，让内部循环仍是内核的一部分。<br /></p>

<p style="text-align:justify;">由于我们必须要为 OpenCL 内核创建三个线性缓冲区，所以有必要重新调整初始算法，以使其与此内核算法尽量接近。带有线性缓冲区的“单核 CPU”上，会随同内核代码一起，提供“非并行”程序代码。带有二维数组的代码的最优性，并不意味着其仿真亦针对线性缓冲区最优：必须重复所有测试。因此，我们再一次选择 c-r-cr 作为与线性代数中矩阵乘法标准逻辑对应的初始变量。<br /></p>

<p style="text-align:justify;">也就是说，要避免矩阵/缓冲区寻址混淆，请回答主要问题：如果矩阵 Matr （M 行乘以 N 列）在 GPU 内存中排列为一个线性缓冲区，那么我们该如何计算某元素 Matr[ row ][ column ] 的线性偏移呢？<br /></p>

<p style="text-align:justify;">事实上，GPU 内存中的矩阵布局并没有什么固定顺序，因为它是由问题的逻辑单独决定的。例如：两个矩阵的元素在缓冲区排列方面可以有所不同，因为就所涉的矩阵相乘算法而言，矩阵是非对称的，即第一矩阵的行乘以第二矩阵的列。如此重新安排，可以极大地影响到每次内核迭代中，从全局 GPU 内存顺序读取矩阵元素的运算性能。 <br /></p>

<p style="text-align:justify;">该算法的第一次实施，会带有同样方式排列的矩阵 - 按行优先顺序。首先将第一行元素放入缓冲区，然后是第二行的所有元素，如此递推。下述为扁平公式，线性存储上方矩阵 Matr[ M (rows) ][ N (columns) ] 的一种二维体现：</p>

<div class="code">Matr[ row ][ column ] = buff[ row * N (Total_columns) + column ]<br /></div><p><br /></p>

<p style="text-align:center;"><img alt="图 13. 将二维索引空间转化为在 GPU 缓冲区内线性排列矩阵的算法" title="图 13. 将二维索引空间转化为在 GPU 缓冲区内线性排列矩阵的算法" src="https://c.mql5.com/2/4/matrix2buff__3.GIF" height="305" width="737" style="vertical-align:middle;" /><br /></p>

<p style="text-align:center;"><span class="small">图 13. 将二维索引空间转化为在 GPU 缓冲区内线性排列矩阵的算法</span><br /></p>
<p>上图还举例说明了在线性存储上按列优先顺序呈二维矩阵表示的方式。<br /><br />下面是一个我们在 OpenCL 设备上执行的程序首次实施的代码，经过少量删减：</p><pre class="code"><span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//|                                                matr_mul_1dim.mq5 |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="preprocessor">#property script_show_inputs</span>

<span class="preprocessor">#define ROWS1       <span class="number">2000</span>      <span class="comment">// rows in the first matrix</span></span>
<span class="preprocessor">#define COLSROWS    <span class="number">2000</span>      <span class="comment">// columns in the first matrix = rows in the second matrix </span></span>
<span class="preprocessor">#define COLS2       <span class="number">2000</span>      <span class="comment">// columns in the second matrix</span></span>
<span class="preprocessor">#define REALTYPE    float</span>

REALTYPE first[];           <span class="comment">// first linear buffer (matrix)     rows1 * colsrows</span>
REALTYPE second[];          <span class="comment">// second buffer                    colsrows * cols2</span>
REALTYPE thirdGPU[ ];       <span class="comment">// product - also a buffer          rows1 * cols2</span>
REALTYPE thirdCPU[ ];       <span class="comment">// product - also a buffer          rows1 * cols2</span>

<span class="keyword">input</span> <span class="keyword">int</span> _device=<span class="number">1</span>;           <span class="comment">// here is the device; it can be changed (now 4870)</span>

<span class="keyword">string</span> d2s(<span class="keyword">double</span> arg,<span class="keyword">int</span> dig) { <span class="keyword">return</span> <span class="functions">DoubleToString</span>(arg,dig); }
<span class="keyword">string</span> i2s(<span class="keyword">long</span> arg)           { <span class="keyword">return</span> <span class="functions">IntegerToString</span>(arg); }

<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">const</span> <span class="keyword">string</span> clSrc=
                   <span class="string">"#define COLS2     "</span>+i2s(COLS2)+<span class="string">"                                  \r\n"</span>
                   <span class="string">"#define COLSROWS  "</span>+i2s(COLSROWS)+<span class="string">"                               \r\n"</span>
                   <span class="string">"#define REALTYPE  float                                             \r\n"</span>
                   <span class="string">"                                                                    \r\n"</span>
                   <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                  \r\n"</span>
                   <span class="string">"                           __global REALTYPE *in2,                  \r\n"</span>
                   <span class="string">"                           __global REALTYPE *out  )                \r\n"</span>
                   <span class="string">"{                                                                   \r\n"</span>
                   <span class="string">"  int r = get_global_id( 0 );                                       \r\n"</span>
                   <span class="string">"  int c = get_global_id( 1 );                                       \r\n"</span>
                   <span class="string">"  for( int cr = 0; cr &lt; COLSROWS; cr ++ )                           \r\n"</span>
                   <span class="string">"     out[ r * COLS2 + c ] +=                                        \r\n"</span>
                   <span class="string">"              in1[ r * COLSROWS + cr ] * in2[ cr * COLS2 + c ];     \r\n"</span>
                   <span class="string">"}                                                                   \r\n"</span>;
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| Main matrix multiplication function;                             |</span>
<span class="comment">//| Input matrices are already generated, </span><span class="comment">                           |
</span><span class="comment">//| </span><span class="comment">the output matrix is initialized to zeros                        |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> mulCPUOneCore()
  {
<span class="comment">//--- c-r-cr: 11.544 s </span>
<span class="comment">//st = GetTickCount( );</span>
   <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;COLS2; c++)
      <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;ROWS1; r++)
         <span class="keyword">for</span>(<span class="keyword">int</span> cr=<span class="number">0</span>; cr&lt;COLSROWS; cr++)
            thirdCPU[r*COLS2+c]+=first[r*COLSROWS+cr]*second[cr*COLS2+c];
<span class="comment"></span>
   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| Script program start function                                    |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> <span class="functions">OnStart</span>()
  {
   initAllDataCPU();

<span class="comment">//--- start working with non-parallel version ("bare" CPU, single core)</span>
<span class="comment">//--- calculate the output matrix on a single core CPU</span>
   <span class="keyword">uint</span> st=<span class="functions">GetTickCount</span>();
   mulCPUOneCore();

<span class="comment">//--- output total calculation time</span>
   <span class="keyword">double</span> timeCPU=(<span class="functions">GetTickCount</span>()-st)/<span class="number">1000</span>.;
   <span class="functions">Print</span>(<span class="string">"CPUTime = "</span>+d2s(timeCPU,<span class="number">3</span>));<span class="comment"></span>

<span class="comment">//--- start working with OCL</span>
   <span class="keyword">int</span> clCtx;             <span class="comment">// context handle</span>
   <span class="keyword">int</span> clPrg;             <span class="comment">// handle to the program on the device</span>
   <span class="keyword">int</span> clKrn;             <span class="comment">// kernel handle</span>
   <span class="keyword">int</span> clMemIn1;          <span class="comment">// first (input) buffer handle</span>
   <span class="keyword">int</span> clMemIn2;          <span class="comment">// second (input) buffer handle</span>
   <span class="keyword">int</span> clMemOut;          <span class="comment">// third (output) buffer handle</span>

<span class="comment">//--- start calculating the program runtime on GPU  </span>
<span class="comment">//st = GetTickCount( );  </span>
   initAllDataGPU(clCtx,clPrg,clKrn,clMemIn1,clMemIn2,clMemOut);

<span class="comment">//--- start calculating total OCL code runtime</span>
   st=<span class="functions">GetTickCount</span>();

   executeGPU(clKrn);

<span class="comment">//--- create a buffer for reading and read the result; we will need it later</span>
   REALTYPE buf[];
   readOutBuf(clMemOut,buf);

<span class="comment">//--- stop calculating the total program runtime </span>
<span class="comment">//--- together with the time required for retrieval of data from GPU and transferring it back to RAM</span>
   <span class="keyword">double</span> timeGPUTotal=(<span class="functions">GetTickCount</span>()-st)/<span class="number">1000</span>.;
   <span class="functions">Print</span>(<span class="string">"OpenCL total: time = "</span>+d2s(timeGPUTotal,<span class="number">3</span>)+<span class="string">" sec."</span>);

   destroyOpenCL(clCtx,clPrg,clKrn,clMemIn1,clMemIn2,clMemOut);

<span class="comment">//--- calculate the time elapsed</span>
   <span class="functions">Print</span>(<span class="string">"CPUTime / GPUTotalTime = "</span>+d2s(timeCPU/timeGPUTotal,<span class="number">3</span>));

<span class="comment">//--- debugging: random checks. Multiplication accuracy is checked directly </span>
<span class="comment">//--- on the initial and output matrices using a few dozen examples</span>
   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) checkRandom(buf,ROWS1,COLS2);

   <span class="functions">Print</span>(<span class="string">"________________________"</span>);
   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| initAllDataCPU                                                   |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> initAllDataCPU()
  {
<span class="comment">//--- initialize random number generator</span>
   <span class="functions">MathSrand</span>(( <span class="keyword">int</span>) <span class="functions">TimeLocal</span>());
   <span class="functions">Print</span>(<span class="string">"======================================="</span>);
   <span class="functions">Print</span>(<span class="string">"1st OCL martices mul:  device = "</span>+i2s(_device)+<span class="string">";      ROWS1 = "</span> +i2s(ROWS1)+<span class="string">
          "; COLSROWS = "</span>+i2s(COLSROWS)+<span class="string">"; COLS2 = "</span>+i2s(COLS2));

<span class="comment">//--- set the required sizes of linear representations of the input and output matrices</span>
   <span class="functions">ArrayResize</span>(first,ROWS1*COLSROWS);
   <span class="functions">ArrayResize</span>(second,COLSROWS*COLS2);
   <span class="functions">ArrayResize</span>(thirdGPU,ROWS1*COLS2);
   <span class="functions">ArrayResize</span>(thirdCPU,ROWS1*COLS2);

<span class="comment">//--- generate both input matrices and initialize the output to zeros </span>
   genMatrices();
   <span class="functions">ArrayInitialize</span>( thirdCPU, <span class="number">0.0</span> );
   <span class="functions">ArrayInitialize</span>( thirdGPU, <span class="number">0.0</span> );

   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| initAllDataCPU                                                   |</span>
<span class="comment">//| lay out in row-major order, Matr[ M (rows) ][ N (columns) ]:     |</span>
<span class="comment">//| Matr[row][column] = buff[row * N(columns in the matrix) + column]| </span>
<span class="comment">//| generate initial matrices; this generation is not reflected      |</span>
<span class="comment">//| in the final runtime calculation                                 |</span>
<span class="comment">//| buffers are filled in row-major order!                           |</span>
<span class="comment">//+------------------------------------------------------------------+  </span>
<span class="keyword">void</span> genMatrices()
  {
   <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;ROWS1; r++)
      <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;COLSROWS; c++)
         first[r*COLSROWS+c]=genVal();

   <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;COLSROWS; r++)
      <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;COLS2; c++)
         second[r*COLS2+c]=genVal();

   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| genVal                                                           |</span>
<span class="comment">//| generate one value of the matrix element:                        |</span>
<span class="comment">//| uniformly distributed value lying in the range [-0.5; 0.5]       |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
REALTYPE genVal()
  {
   <span class="keyword">return</span>(REALTYPE)((<span class="functions">MathRand</span>()-<span class="number">16383.5</span>)/<span class="number">32767</span>.);
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| initAllDataGPU                                                   |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> initAllDataGPU(<span class="keyword">int</span> &amp;clCtx,       <span class="comment">// context</span>
                    <span class="keyword">int</span>&amp; clPrg,       <span class="comment">// program on the device</span>
                    <span class="keyword">int</span>&amp; clKrn,       <span class="comment">// kernel</span>
                    <span class="keyword">int</span>&amp; clMemIn1,    <span class="comment">// first (input) buffer</span>
                    <span class="keyword">int</span>&amp; clMemIn2,    <span class="comment">// second (input) buffer</span>
                    <span class="keyword">int</span>&amp; clMemOut)    <span class="comment">// third (output) buffer</span>
  {
<span class="comment">//--- write the kernel code to a file</span>
   WriteCLProgram();

<span class="comment">//--- create context, program and kernel</span>
   clCtx = CLContextCreate( _device );
   clPrg = CLProgramCreate( clCtx, clSrc );
   clKrn = CLKernelCreate( clPrg, <span class="string">"matricesMul"</span> );

<span class="comment">//--- create all three buffers for the three matrices</span>
<span class="comment">//--- first matrix - input</span>
   clMemIn1=CLBufferCreate(clCtx,ROWS1   *COLSROWS*<span class="functions">sizeof</span>(REALTYPE),CL_MEM_READ_WRITE);
<span class="comment">//--- second matrix - input</span>
   clMemIn2=CLBufferCreate(clCtx,COLSROWS*COLS2   *<span class="functions">sizeof</span>(REALTYPE),CL_MEM_READ_WRITE);
<span class="comment">//--- third matrix - output</span>
   clMemOut=CLBufferCreate(clCtx,ROWS1   *COLS2   *<span class="functions">sizeof</span>(REALTYPE),CL_MEM_READ_WRITE);

<span class="comment">//--- set arguments to the kernel</span>
   CLSetKernelArgMem(clKrn,<span class="number">0</span>,clMemIn1);
   CLSetKernelArgMem(clKrn,<span class="number">1</span>,clMemIn2);
   CLSetKernelArgMem(clKrn,<span class="number">2</span>,clMemOut);

<span class="comment">//--- write the generated matrices to the device buffers</span>
   CLBufferWrite(clMemIn1,first);
   CLBufferWrite(clMemIn2,second);
   CLBufferWrite(clMemOut,thirdGPU);   <span class="comment">// 0.0 everywhere</span>

   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| WriteCLProgram                                                   |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> WriteCLProgram()
  {
   <span class="keyword">int</span> h=<span class="functions">FileOpen</span>(<span class="string">"matr_mul_OCL_1st.cl"</span>,<span class="macro">FILE_WRITE</span>|<span class="macro">FILE_TXT</span>|<span class="macro">FILE_ANSI</span>);
   <span class="functions">FileWrite</span>(h,clSrc);
   <span class="functions">FileClose</span>(h);
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| executeGPU                                                       |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> executeGPU(<span class="keyword">int</span> clKrn)
  {
<span class="comment">//--- set the workspace parameters for the task and execute the OpenCL program</span>
   <span class="keyword">uint</span> offs[ <span class="number">2</span> ]  = { <span class="number">0</span>, <span class="number">0</span> };
   <span class="keyword">uint</span> works[ <span class="number">2</span> ] = { ROWS1,  COLS2 };
   <span class="keyword">bool</span> ex=CLExecute(clKrn,<span class="number">2</span>,offs,works);
   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| readOutBuf                                                       |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> readOutBuf(<span class="keyword">int</span> clMemOut,REALTYPE &amp;buf[])
  {
   <span class="functions">ArrayResize</span>(buf,COLS2*ROWS1);
<span class="comment">//--- buf - a copy of what is written to the buffer thirdGPU[]</span>
   <span class="keyword">uint</span> read=CLBufferRead(clMemOut,buf);
   <span class="functions">Print</span>(<span class="string">"read = "</span>+i2s(read)+<span class="string">" elements"</span>);
   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| destroyOpenCL                                                    |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> destroyOpenCL(<span class="keyword">int</span> clCtx,<span class="keyword">int</span> clPrg,<span class="keyword">int</span> clKrn,<span class="keyword">int</span> clMemIn1,<span class="keyword">int</span> clMemIn2,<span class="keyword">int</span> clMemOut)
  {
<span class="comment">//--- destroy all that was created for calculations on the OpenCL device in reverse order</span>
   CLBufferFree(clMemIn1);
   CLBufferFree(clMemIn2);
   CLBufferFree(clMemOut);
   CLKernelFree(clKrn);
   CLProgramFree(clPrg);
   CLContextFree(clCtx);
   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| checkRandom                                                      |</span>
<span class="comment">//| random check of calculation accuracy                             |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">void</span> checkRandom(REALTYPE &amp;buf[],<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)
  {
   <span class="keyword">int</span> r0 = genRnd( rows );
   <span class="keyword">int</span> c0 = genRnd( cols );

   REALTYPE sum=<span class="number">0.0</span>;
   <span class="keyword">for</span>(<span class="keyword">int</span> runningIdx=<span class="number">0</span>; runningIdx&lt;COLSROWS; runningIdx++)
      sum+=first[r0*COLSROWS+runningIdx]*
           second[runningIdx*COLS2+c0];
<span class="comment">//--- element of the buffer m[]</span>
   REALTYPE bufElement=buf[r0*COLS2+c0];
<span class="comment">//--- element of the matrix not calculated in OpenCL</span>
   REALTYPE CPUElement=thirdCPU[r0*COLS2+c0];
   <span class="functions">Print</span>(<span class="string">"sum( "</span>+i2s(r0)+<span class="string">","</span>+i2s(c0)+<span class="string">" ) = "</span>+d2s(sum,<span class="number">8</span>)+
         <span class="string">";    thirdCPU[ "</span>+i2s(r0)+<span class="string">","</span>+i2s(c0)+<span class="string">" ] = "</span>+d2s(CPUElement,<span class="number">8</span>)+
         <span class="string">";    buf[ "</span>+i2s(r0)+<span class="string">","</span>+i2s(c0)+<span class="string">" ] = "</span>+d2s(bufElement,<span class="number">8</span>));
   <span class="keyword">return</span>;
  }
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="comment">//| genRnd                                                           |</span>
<span class="comment">//+------------------------------------------------------------------+</span>
<span class="keyword">int</span> genRnd(<span class="keyword">int</span> max)
  {
   <span class="keyword">return</span>(<span class="keyword">int</span>)(<span class="functions">MathRand</span>()/<span class="number">32767</span>.*max);
  }
</pre><p style="text-align:center;"><span class="small">列表 2. OpenCL  中程序的首次实施 <br /></span></p><p><span class="small"></span></p>

<p style="text-align:justify;">最后两个函数会在验证计算的准确性时用到。文末附有完整代码 (matr_mul_1dim.mq5)。注意：维数不必只与方块矩阵对应。<br /></p>

<p>更深一步的变更几乎始终只关系到内核代码，因此下文只谈内核修改代码。 <br /></p>

<p style="text-align:justify;">引入 REALTYPE 类型，是为了方便将计算精确度从浮点型改为双精度。应当指出的是，REALTYPE 类型不仅在主机程序中声明，还在内核中声明。如有必要，有关此类型的任何变更，都要在两个地方同时做出——主机程序的 #define 与内核代码的 #define 。</p>

<p>代码执行结果（下文皆为浮点数据类型）<br /><br />CPU (OpenCL, _device = 0) ：<br /></p><pre class="code"><span class="number">2012.05</span>.<span class="number">20</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">57</span>    matr_mul_1dim (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">12.479</span>
<span class="number">2012.05</span>.<span class="number">20</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">57</span>    matr_mul_1dim (EURUSD,H1)    OpenCL total: time = <span class="number">9.266</span> sec.
<span class="number">2012.05</span>.<span class="number">20</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">57</span>    matr_mul_1dim (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">20</span> <span class="number">22</span>:<span class="number">14</span>:<span class="number">48</span>    matr_mul_1dim (EURUSD,H1)    CPUTime = <span class="number">115.628</span>
<span class="number">2012.05</span>.<span class="number">20</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">52</span>    matr_mul_1dim (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">20</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">52</span>    matr_mul_1dim (EURUSD,H1)    =======================================</pre><p>如在 Radeon HD 4870 (_device = 1) 上执行：<br /></p><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">50</span>    matr_mul_1dim (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">9.002</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">50</span>    matr_mul_1dim (EURUSD,H1)    OpenCL total: time = <span class="number">12.729</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">50</span>    matr_mul_1dim (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">40</span>:<span class="number">37</span>    matr_mul_1dim (EURUSD,H1)    CPUTime = <span class="number">114.583</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">38</span>:<span class="number">42</span>    matr_mul_1dim (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">38</span>:<span class="number">42</span>    matr_mul_1dim (EURUSD,H1)    =======================================</pre>


<p>可以看出，此内核在 GPU 上的执行要慢得多。但是，我们还未专门针对 GPU 进行优化。</p>
<p>几条结论：</p>
<ul>
<li>将矩阵形式从二维改为线性（对应设备上所执行程序中的形式），对于程序连续版本的总体运行时并没有显著的影响。</li>
<li>与线性代数领域矩阵相乘定义匹配的最直观的计算算法，已被选定为用于进一步优化的初始变量。某种程度上，它比最快的算法慢一些，但从 GPU 未来加速的角度来看，此因素则无关紧要。</li>
<li>只有在将缓冲区读取到 RAM （而不是在 <a target="_blank" href="/zh/docs/opencl/clexecute">CLExecute()</a> 命令）后，才计算运行时。按照 <b>MetaDriver</b> 告知作者的说法，其背后很可能包含下述原因：<div class="fquote"><b><span style="color:rgb(0, 87, 174);"> MetaDriver：</span></b>从缓冲区读取之前，<a target="_blank" href="/zh/docs/opencl/clbufferread">CLBufferRead()</a> 只是等待程序的实际完成。CLExecute() 事实上是一个异步队列函数。它会立即返回结果，远在 cl 代码运行结束之前。</div></li>
<li>GPU 计算向导并不经常计算内核运行时，而是与各种对象相关的<i></i><i>吞吐能力</i> - 存储、算术等。我们可以并将在下文重复这一步骤。 <br /></li>
</ul>

<p>我们知道，一个维数为 2000 的矩阵，其每个元素的计算大约需要 2 * 2000 次加法/乘法。通过乘以矩阵元素的数量 (2000 * 2000)，就会得出 160 亿次浮点型数据运算的总数。也就是说，CPU 上的此次执行用时 115.628 秒，对应着下述数据流速度 </p>

<div class="code">throughput_arithmetic_CPU_no_OCL = 16 000000000 / 115.628 ~ 138 MFlops。<br /></div><p><br />另一方面，要知道迄今为止矩阵维数为 2000 的“单核 CPU”的最快运算，其完成仅 83.663 秒（请参见我们第一个不带 OpenCL 的代码）。因此<br /></p>

<div class="code"><b><span style="color:rgb(0, 87, 174);">throughput_arithmetic_CPU_best_no_OCL = 16 000000000 / 83.663 ~ 191 MFlops。</span></b><br /></div><p></p><p>我们以此数据作为参照，作为我们优化的起始点。</p>与之类似，CPU 上利用 OpenCL 进行的计算会得到：<div class="code">throughput_arithmetic_CPU_OCL =  16 000000000 / 9.266 ~ 1727 MFlops = 1.727 GFlops。<br /></div>



<p><br />最后，计算 GPU 上的吞吐量：</p><div class="code">throughput_arithmetic_GPU_OCL =  16 000000000 / 12.729 ~ 1257 MFlops = 1.257 GFlops。<br /></div>
<p><br /></p>
<p><b>2.3. 消除非相干数据访问 </b></p>

<p>从该内核代码中，您很容易就会看到几个非最优项。</p><p> 查看一下内核中循环的主体：<br /></p>

<pre class="code"><span class="keyword">for</span>( <span class="keyword">int</span> cr = <span class="number">0</span>; cr &lt; COLSROWS; cr ++ )
   <span class="keyword">out</span>[ r * COLS2 + c ] += in1[ r * COLSROWS + cr ] * in2[ cr * COLS2 + c ];</pre>

<p style="text-align:justify;">很容易看出，运行循环计数器 (cr++) 时，会从第一个缓冲区 in1[] 中取连续数据。而来自第二缓冲区 in2[] 的数据，则以 COLS2 为“间隔”获取。换句话说，从第二缓冲区获取的数据的<b>主要</b>部分都没用，因为存储请求将是非相干的（参见 <b>1.2.1. 合并内存请求</b>）。要处理好这种情况，通过更改数组 in2[] 中索引的计算公式及其生成模式，修改三处代码即足够：<br /></p>- 内核代码：<br />

<pre class="code"><span class="keyword">for</span>( <span class="keyword">int</span> cr = <span class="number">0</span>; cr &lt; COLSROWS; cr ++ )
   <span class="keyword">out</span>[ r * COLS2 + c ] += in1[ r * COLSROWS + cr ] * in2[ cr + c * COLSROWS ];</pre>现在，当循环计数器 (cr++) 值变化时，两个数组的数据都会被顺序获取，不带任何“间隔”。<br /><br />- genMatrices() 中的缓冲区填充代码。现在，应按列优先顺序（而不是开头处使用的行优先顺序）将其填入：<br />

<pre class="code">   <span class="keyword">for</span>( <span class="keyword">int</span> r = <span class="number">0</span>; r &lt; COLSROWS; r ++ )
      <span class="keyword">for</span>( <span class="keyword">int</span> c = <span class="number">0</span>; c &lt; COLS2; c ++ )
         <span class="comment">/// second[ r * COLS2 + c ] = genVal( );</span>
         second[ r + c * COLSROWS ] = genVal( );</pre>- checkRandom() 函数中的验证码：<br /><pre class="code">   <span class="keyword">for</span>( <span class="keyword">int</span> runningIdx = <span class="number">0</span>; runningIdx &lt; COLSROWS; runningIdx ++  )
      <span class="comment">///sum += first[ r0 * COLSROWS + runningIdx ] * second[ runningIdx * COLS2 + c0 ];</span>
      sum += first[ r0 * COLSROWS + runningIdx ] * second[ runningIdx + c0 * COLSROWS ];</pre>CPU 上的性能结果：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">24</span> <span class="number">02</span>:<span class="number">59</span>:<span class="number">22</span>    matr_mul_1dim_coalesced (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">16.207</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">02</span>:<span class="number">59</span>:<span class="number">22</span>    matr_mul_1dim_coalesced (EURUSD,H1)    OpenCL total: time = <span class="number">5.756</span> sec.
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">02</span>:<span class="number">59</span>:<span class="number">22</span>    matr_mul_1dim_coalesced (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">02</span>:<span class="number">59</span>:<span class="number">16</span>    matr_mul_1dim_coalesced (EURUSD,H1)    CPUTime = <span class="number">93.289</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">02</span>:<span class="number">57</span>:<span class="number">43</span>    matr_mul_1dim_coalesced (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">02</span>:<span class="number">57</span>:<span class="number">43</span>    matr_mul_1dim_coalesced (EURUSD,H1)    =======================================</pre>Radeon HD 4870：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">50</span>:<span class="number">43</span>    matr_mul_1dim_coalesced (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">7.176</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">50</span>:<span class="number">43</span>    matr_mul_1dim_coalesced (EURUSD,H1)    OpenCL total: time = <span class="number">12.979</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">50</span>:<span class="number">43</span>    matr_mul_1dim_coalesced (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">50</span>:<span class="number">30</span>    matr_mul_1dim_coalesced (EURUSD,H1)    CPUTime = <span class="number">93.133</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">48</span>:<span class="number">57</span>    matr_mul_1dim_coalesced (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">48</span>:<span class="number">57</span>    matr_mul_1dim_coalesced (EURUSD,H1)    =======================================
</pre><p style="text-align:justify;">可以看出，数据的相干访问几乎对 GPU 上的运行时没有任何影响；但却明显地改进了 CPU 上的运行时。它极有可能关系到稍后优化的因素，尤其是我们要尽快摆脱掉的、访问全局变量的超高延迟。<br /></p><pre class="code">throughput_arithmetic_CPU_OCL =  <span class="number">16</span> <span class="number">000000000</span> / <span class="number">5.756</span> ~ <span class="number">2.780</span> GFlops.
throughput_arithmetic_GPU_OCL =  <span class="number">16</span> <span class="number">000000000</span> / <span class="number">12.979</span> ~ <span class="number">1.233</span> GFlops.</pre><p>该新内核代码，请见文末的 matr_mul_1dim_coalesced.mq5。<br /></p><p>内核代码列出如下：</p><pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  int c = get_global_id( 1 );                                                \r\n"</span>
      <span class="string">"  for( int cr = 0; cr &lt; COLSROWS; cr ++ )                                    \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] +=                                                 \r\n"</span>
      <span class="string">"              in1[ r * COLSROWS + cr ] * in2[ cr + c * COLSROWS ];           \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span>;</pre><p style="text-align:center;"><span class="small">列表 3. 带有已合并全局存储数据访问的内核</span><br /></p>

<p>现在，我们继续进一步优化。</p><br /><b>2.4. 移除输出矩阵中“代价高昂”的全局 GPU 存储访问</b><br /><br />

<p style="text-align:justify;">众所周知，全局 GPU 存储访问的延迟极其之高（约 600-800 个周期）。比如说，执行一次两个数的加法，就有大约 20 个周期的延迟。在 GPU 上计算时，优化的主要目标就是通过增加计算的吞吐量来隐藏延迟。在此前开发的内核循环中，我们不断地访问全局存储元素，所以浪费了大量的时间。 <br /></p>

<p style="text-align:justify;">现在，我们将局部变量和引入内核（可以实现速度提高多倍的访问，因为它是工作单元寄存器中内核的一个私有变量），并待循环结束后，<i>逐一</i>将获取的和值分配给输出数据的元素：<br /></p>

<pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  int c = get_global_id( 1 );                                                \r\n"</span>
      <span class="string">"  REALTYPE sum = 0.0;                                                        \r\n"</span>
      <span class="string">"  for( int cr = 0; cr &lt; COLSROWS; cr ++ )                                    \r\n"</span>
      <span class="string">"     sum += in1[ r * COLSROWS + cr ] * in2[ cr + c * COLSROWS ];             \r\n"</span>
      <span class="string">"  out[ r * COLS2 + c ] = sum;                                                \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre>

<p style="text-align:center;"><span class="small">列表 4. 引入私有变量以计算无向积计算循环中的累积和</span><br /></p>
<p>完整源代码文件请见文末随附的 matr_mul_sum_local.mq5。<br /><br />CPU：<br /></p>

<pre class="code"><span class="number">2012.05</span>.<span class="number">24</span> <span class="number">03</span>:<span class="number">28</span>:<span class="number">17</span>    matr_mul_sum_local (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">24.863</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">03</span>:<span class="number">28</span>:<span class="number">16</span>    matr_mul_sum_local (EURUSD,H1)    OpenCL total: time = <span class="number">3.759</span> sec.
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">03</span>:<span class="number">28</span>:<span class="number">16</span>    matr_mul_sum_local (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">03</span>:<span class="number">28</span>:<span class="number">12</span>    matr_mul_sum_local (EURUSD,H1)    CPUTime = <span class="number">93.460</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">03</span>:<span class="number">26</span>:<span class="number">39</span>    matr_mul_sum_local (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span></pre>GPU HD 4870：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">57</span>:<span class="number">30</span>    matr_mul_sum_local (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">69.541</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">57</span>:<span class="number">30</span>    matr_mul_sum_local (EURUSD,H1)    OpenCL total: time = <span class="number">1.326</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">57</span>:<span class="number">30</span>    matr_mul_sum_local (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">57</span>:<span class="number">28</span>    matr_mul_sum_local (EURUSD,H1)    CPUTime = <span class="number">92.212</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">55</span>:<span class="number">56</span>    matr_mul_sum_local (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">01</span>:<span class="number">55</span>:<span class="number">56</span>    matr_mul_sum_local (EURUSD,H1)    =======================================</pre>这是一次真正的生产率提升！ <br /><br /><pre class="code">throughput_arithmetic_CPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">3.759</span> ~ <span class="number">4.257</span> GFlops.
throughput_arithmetic_GPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">1.326</span> ~ <span class="number">12.066</span> GFlops.
</pre>

<p style="text-align:justify;">顺序优化过程中，我们努力坚持的主要原则如下：首先，您要按照可能的最完善的方式来重新安排数据结构，以使其适于给定的任务、尤其是基础硬件。然后再采用 mad() 或 fma() 之类的快速计算算法，继续精细优化。您要牢记：顺序优化并不一定会导致性能提升 - 这一点不能保证。 <br /><br /></p>

<p><b>2.5. 改进内核执行的操作</b><br /></p>

<p style="text-align:justify;">在并行编程中，重要的是按照并行运行结构最小化<i>间接成本</i>（所用时间）的组织计算。在维数为 2000 的矩阵中，一个计算某输出矩阵元素的工作单元，会执行占整体任务 1 / 4000000 的工作量。<br /></p><p style="text-align:justify;">这很明显太多了，而且与硬件上执行计算的实际单元数量相差甚远。现在，在内核的这个新版本中，我们会计算整个矩阵行，而不是一个元素。 <br /></p>

<p style="text-align:justify;">重要的是，现在的任务空间已经从二维变成了一维作为整体的维度 - 整行（而不是矩阵的单一元素）现已于内核的每个任务中进行计算。因此，任务空间转化成为矩阵的行数。<br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/mul_picture_rowcalc.PNG" height="163" width="666" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 14. 输出矩阵整行计算的方案图</span><br /></p>

<p>内核代码变得更加复杂：<br /></p>

<pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  REALTYPE sum;                                                              \r\n"</span>
      <span class="string">"  for( int c = 0; c &lt; COLS2; c ++ )                                          \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     sum = 0.0;                                                              \r\n"</span>
      <span class="string">"     for( int cr = 0; cr &lt; COLSROWS; cr ++ )                                 \r\n"</span>
      <span class="string">"        sum += in1[ r * COLSROWS + cr ] * in2[ cr + c * COLSROWS ];          \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] = sum;                                             \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre><p style="text-align:center;"><span class="small">列表 5. 用于输出矩阵整行计算的内核</span><br /></p>此外，任务维数亦已于 executeGPU( ) 函数中更改：<br /><pre class="code"><span class="keyword">void</span> executeGPU( <span class="keyword">int</span> clKrn )
{
   <span class="comment">//--- set parameters of the task workspace and execute the OpenCL program</span>
   <span class="keyword">uint</span> offs[ <span class="number">1</span> ]  = { <span class="number">0</span> };
   <span class="keyword">uint</span> works[ <span class="number">1</span> ] = { ROWS1 };  
   <span class="keyword">bool</span> ex = CLExecute( clKrn, <span class="number">1</span>, offs, works );
   <span class="keyword">return</span>;
}<span class="comment"></span></pre>

<p>性能结果（完整的源代码请见 matr_mul_row_calc.mq5）：<br /><br />CPU：<br /></p>

<pre class="code"><span class="number">2012.05</span>.<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">24</span>    matr_mul_row_calc (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">17.385</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">24</span>    matr_mul_row_calc (EURUSD,H1)    OpenCL total: time = <span class="number">5.366</span> sec.
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">24</span>    matr_mul_row_calc (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">15</span>:<span class="number">56</span>:<span class="number">19</span>    matr_mul_row_calc (EURUSD,H1)    CPUTime = <span class="number">93.288</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">45</span>    matr_mul_row_calc (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">24</span> <span class="number">15</span>:<span class="number">54</span>:<span class="number">45</span>    matr_mul_row_calc (EURUSD,H1)    =======================================</pre><p>GPU 4870：</p><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">24</span>:<span class="number">10</span>    matr_mul_row_calc (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">55.119</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">24</span>:<span class="number">10</span>    matr_mul_row_calc (EURUSD,H1)    OpenCL total: time = <span class="number">1.669</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">24</span>:<span class="number">10</span>    matr_mul_row_calc (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">24</span>:<span class="number">08</span>    matr_mul_row_calc (EURUSD,H1)    CPUTime = <span class="number">91.994</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">22</span>:<span class="number">35</span>    matr_mul_row_calc (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">22</span>:<span class="number">35</span>    matr_mul_row_calc (EURUSD,H1)    =======================================</pre>


<p>我们可以看出，CPU 上的运行时明显恶化，而且在 GPU 上也略微变差（虽然不明显）。也不是全都这么糟糕：这种局部情况暂时恶化的策略变更，只是为了进一步大幅提升其性能。 <br /></p>

<pre class="code">throughput_arithmetic_CPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">5.366</span> ~ <span class="number">2.982</span> GFlops.
throughput_arithmetic_GPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">1.669</span> ~ <span class="number">9.587</span> GFlops.</pre>

<div class="atten">利用功能齐全的 OpenCL API 进行优化时，<i>工作组大小</i>（即工作组内工作单元的数量）会显式设置。由此终端开发人员构建的当前实施中，未提供这种可能性。如能在终端的未来版本中加上它，那就好极了。<br /></div>

<br />
<p><b>2.6. 将第一数组的行迁移到私有内存</b></p>

<p style="text-align:justify;">矩阵相乘算法的主要特征，就是带有伴随结果累积的大量乘法。此算法的一种恰当、高质量的优化，则应意味着数据传输的最小化。但到目前为止，在无向积累积的主循环计算过程中，我们所有的内核修改都存储于全局内存的三个矩阵中的其中两个。 <br /></p>

<p style="text-align:justify;">这就意味着，每个无向积（实际上是每个输出矩阵元素）的所有输入数据，都通过整个存储层次（从全局到私有）以相关延迟持续优化。针对输出矩阵每一经过计算的行，通过确保每个工作单元都重复使用第一矩阵的同一行来减少流量。</p>

<p style="text-align:justify;"><br /></p><p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/row_in_private_mem.PNG" height="201" width="543" style="vertical-align:middle;" /></p>

<p style="text-align:center;"><span class="small">图 15. 将第一矩阵的行迁移到工作单元的私有内存</span><br /></p>

<p style="text-align:justify;">无需在主机程序代码中做任何修改。而且，内核中的改动也极其细微。鉴于中间一维私有数组在内核中生成的事实，GPU 试着将其置于执行此内核的单元的私有内存中。把第一矩阵所需行从全局复制到私有内存中。也就是说，值得注意的是，即便是这种复制也相对较快。其中的关键在于，由全局向私有内存复制第一数组行元素，代价最大的就是相干法；而与计算输出矩阵行的主双精确度循环的运行时相比，复制的间接成本算是相当适中了。</p>

<p>内核代码（主循环中被注释掉的代码是之前版本中已有的内容）：<br /></p>

<pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  REALTYPE rowbuf[ COLSROWS ];                                               \r\n"</span>
      <span class="string">"  for( int col = 0; col &lt; COLSROWS; col ++ )                                 \r\n"</span>
      <span class="string">"     rowbuf[ col ] = in1[ r * COLSROWS + col ];                              \r\n"</span>
      <span class="string">"  REALTYPE sum;                                                              \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  for( int c = 0; c &lt; COLS2; c ++ )                                          \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     sum = 0.0;                                                              \r\n"</span>
      <span class="string">"     for( int cr = 0; cr &lt; COLSROWS; cr ++ )                                 \r\n"</span>
      <span class="string">"        ///sum += in1[ r * COLSROWS + cr ] * in2[ cr + c * COLSROWS ];       \r\n"</span>
      <span class="string">"        sum += rowbuf[ cr ] * in2[ cr + c * COLSROWS ];                      \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] = sum;                                             \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre><p style="text-align:center;"><span class="small">列表 6. 工作单元私有内存中带有第一矩阵行的内核。</span></p>CPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">00</span>:<span class="number">51</span>:<span class="number">46</span>    matr_mul_row_in_private (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">18.587</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">00</span>:<span class="number">51</span>:<span class="number">46</span>    matr_mul_row_in_private (EURUSD,H1)    OpenCL total: time = <span class="number">4.961</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">00</span>:<span class="number">51</span>:<span class="number">46</span>    matr_mul_row_in_private (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">00</span>:<span class="number">51</span>:<span class="number">41</span>    matr_mul_row_in_private (EURUSD,H1)    CPUTime = <span class="number">92.212</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">08</span>    matr_mul_row_in_private (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">00</span>:<span class="number">50</span>:<span class="number">08</span>    matr_mul_row_in_private (EURUSD,H1)    =======================================</pre>GPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">28</span>:<span class="number">49</span>    matr_mul_row_in_private (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">69.242</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">28</span>:<span class="number">49</span>    matr_mul_row_in_private (EURUSD,H1)    OpenCL total: time = <span class="number">1.327</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">28</span>:<span class="number">49</span>    matr_mul_row_in_private (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">28</span>:<span class="number">47</span>    matr_mul_row_in_private (EURUSD,H1)    CPUTime = <span class="number">91.884</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">27</span>:<span class="number">15</span>    matr_mul_row_in_private (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">02</span>:<span class="number">27</span>:<span class="number">15</span>    matr_mul_row_in_private (EURUSD,H1)    =======================================</pre><pre class="code">throughput_arithmetic_CPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">4.961</span> ~ <span class="number">3.225</span> GFlops.
throughput_arithmetic_GPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">1.327</span> ~ <span class="number">12.057</span> GFlops.</pre>

<p style="text-align:justify;">CPU 吞吐量还保持与上一次大致相同的水平，而 GPU 吞吐量则回到曾达到过的最高水平，但处于新能力中。注意：CPU 吞吐量就像是被当场冻结了一样，只是有些微的不稳定；而 GPU 吞吐量则是大幅飙升（尽管不都是这样）。<br /></p>

<p style="text-align:justify;">我们要说明一点，实际的算术吞吐量会稍高一些，因为是将第一矩阵的行复制到私有内存中，所以现在执行的运算比以前更多。但是，它对最终吞吐量的估算影响不大。</p>

<p>源代码请见 matr_mul_row_in_private.mq5。 <br /></p>



<p style="text-align:justify;"><br /></p><p><b>2.7. 将第二数组的列迁移至本地内存</b></p><p style="text-align:justify;">现在，下一步要做什么就不难猜到了。我们已经采取了相应的步骤，隐藏与输出及第一输入矩阵关联的延迟。还剩下第二矩阵。<br /></p>

<p style="text-align:justify;">对于矩阵相乘中使用的无向积的更加细致的研究显示：在计算输出矩阵行的过程中，组内的所有工作单元均通过该设备对来自第二相乘矩阵相同列的数据进行重新优化。如下图所示：<br /><br /></p>

<p style="text-align:center;"><img alt="" title="" src="https://c.mql5.com/2/4/row_private_col_local.PNG" height="204" width="515" style="vertical-align:middle;" /></p><p style="text-align:center;"><span class="small">图 16. 将第二矩阵的列迁移到工作组的 <i></i><i>Local Data Share</i> （本地数据共享）</span></p>

<p style="text-align:justify;">如果构成工作组的工作单元在输出矩阵行开始计算<i>之前</i>，就将第二矩阵的列复制到工作组内存，那么从全局内存迁移的间接成本也会缩减。 <br /></p>

<p style="text-align:justify;">这要求对内核和主机程序做出改动。最为重要的改动，就是针对每个内核设置本地内存。它应为显式，因为 OpenCL 中不支持动态内存分配。所以，足够大小的存储对象要首先置入主机，以供于内核中进一步处理。 <br /></p>

<p>只有这样在执行内核时，工作单元才会将第二矩阵的列复制到本地内存。而这是利用工作组所有工作单元循环迭代的循环分布并行完成的。但是，所有复制都要在该工作单元开始其主运算（计算输出矩阵行）之前完成。<br /></p><p>正因如此，下述命令也要在负责复制的循环之后插入：</p>

<pre class="code">barrier(CLK_LOCAL_MEM_FENCE);</pre>

<p style="text-align:justify;">这是确保组内工作单元可以“看到”与其它单位协调、处于某特定状态的本地内存的一个“本地内存屏障”。工作组内的所有工作单元，都要先执行直至该屏障的所有命令，才可以继续进行内核的执行。换言之，此屏障是工作组内各工作单元之间的一种特殊同步机制。 <br /></p>

<p>OpenCL 中未提供工作组之间的同步机制。</p>

<p> 下图所示为活动的屏障图解：</p><p style="text-align:center;"><img alt="图 17. 活动屏障图解" title="图 17. 活动屏障图解" src="https://c.mql5.com/2/4/barrier__2.PNG" height="348" width="726" style="vertical-align:middle;" /><br /></p>

<p style="text-align:center;"><span class="small">图 17. 活动屏障图解<br /></span></p><p style="text-align:justify;">事实上，看起来似乎只是工作组内的工作单元严格同时执行了代码。这仅仅是 OpenCL 编程模型的一种抽象。 <br /></p>

<p style="text-align:justify;">到目前为止，我们在不同工作单元上执行的内核代码还都不需要同步的运算，因为它们之间没有任何将在内核中以编程方式设置的显式通信；此外，它甚至都没有需要。但是，此内核中却要求同步，因为本地数组的填充过程是在<i>工作组的所有单位之间并行分布</i>。<br /></p><p style="text-align:justify;">换句话说，每个工作单元都会将其值写入本地数据共享（此处为数组），而无需知道其它工作单元在此写入过程中还有多远。这里设置一个屏障，这样在有必要之前（即在完全生成一个本地数组之前），某特定的工作单元不会继续此内核的执行。<br /></p>

<p style="text-align:justify;">您要明白，该优化很难对 CPU 上的性能产生什么有益的影响：据 Intel 的《OpenCL 优化指南》称：在 CPU 上执行某内核时，所有的 OpenCL 内存对象均由硬件缓存，所以使用本地内存的显式缓存只是增加了不必要（但适度）的间接成本。<br /></p>

<p style="text-align:justify;">这是值得一提的另一个要点——它耗费了本文作者大量时间。它关系到一个事实：局部变量不能在内核函数头中（即编译阶段时，在该终端开发人员构建的当前实施中）传递。其背后的原因在于，为了将内存作为内核函数自变量分配给某个内存对象，我们必须首先利用 <a target="_blank" href="/zh/docs/opencl/clbuffercreate">CLBufferCreate()</a> 函数在 CPU 内存中显式创建该对象，并作为一个函数参数显式指明其大小。此函数会返回一个内存对象句柄，而该句柄则会进一步存储于全局 GPU 内存中，因为这里是它唯一的容身之处。<br /></p>



<p style="text-align:justify;">但是，本地内存是与全局内存不同的一种类型，所以创建的内存对象不能置入工作组的本地内存中。<br /></p><p style="text-align:justify;">功能齐全的 OpenCL API 允许显式分配所需大小的内存，且指针 NULL 会指向内核的自变量，即便是未如此 (<a target="_blank" href="/zh/docs/opencl/clsetkernelarg">CLSetKernelArg()</a> 函数创建内存对象）。然而，<a target="_blank" href="/zh/docs/opencl/clsetkernelargmem">CLSetKernelArgMem()</a> 函数作为全功能 API 函数的 MQL5 仿真，其语法不允许我们在未创建内存对象本身的情况下，向其传递已分配给自变量的内存大小。我们可以向 <a target="_blank" href="/zh/docs/opencl/clsetkernelargmem">CLSetKernelArgMem()</a> 函数传递的，只是<i>已于全局 CPU 中生成的</i>、以及旨在向全局 GPU 内存迁移的缓冲区句柄。这里有一个悖论。<br /></p>

<p style="text-align:justify;">幸运的是，此内核中还有一种使用局部缓冲区的同等方式。您只需利用 __local 修饰符在内核主体中声明该缓冲区即可。这种情况下，分配到此工作组的本地内存，会在运行时（而非编译阶段）期间被确定。<br /></p>

<p style="text-align:justify;">而内核中继屏障之后出现的命令（代码中的屏障线以红色标示）从本质上来讲，与之前优化过程中的相同。主机程序代码仍相同（源代码请见 matr_mul_col_local.mq5）。 <br /></p>

<p>新的内核代码如下：</p>

<pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out )                          \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  REALTYPE rowbuf[ COLSROWS ];                                               \r\n"</span>
      <span class="string">"  for( int col = 0; col &lt; COLSROWS; col ++ )                                 \r\n"</span>
      <span class="string">"     rowbuf[ col ] = in1[ r * COLSROWS + col ];                              \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"  int idlocal = get_local_id( 0 );                                           \r\n"</span>     
      <span class="string">"  int nlocal = get_local_size( 0 );                                          \r\n"</span>     
      <span class="string">"  __local  REALTYPE colbuf[ COLSROWS ] ;                                     \r\n"</span>
      <span class="string">"                                                                             \r\n"</span> 
      <span class="string">"  REALTYPE sum;                                                              \r\n"</span>
      <span class="string">"  for( int c = 0; c &lt; COLS2; c ++ )                                          \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     for( int cr = idlocal; cr &lt; COLSROWS; cr = cr + nlocal )                \r\n"</span>                 
      <span class="string">"        colbuf[ cr ] = in2[ cr + c * COLSROWS ];                             \r\n"</span>                 
      <span class="string">"     <span style="color:rgb(226, 8, 0);"><b>barrier( CLK_LOCAL_MEM_FENCE );</b></span>                                         \r\n"</span>                 
      <span class="string">"                                                                             \r\n"</span>                 
      <span class="string">"     sum = 0.0;                                                              \r\n"</span>
      <span class="string">"     for( int cr = 0; cr &lt; COLSROWS; cr ++ )                                 \r\n"</span>
      <span class="string">"        sum += rowbuf[ cr ] * colbuf[ cr ];                                  \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] = sum;                                             \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre><p style="text-align:center;"><span class="small">列表 7. 被迁移到工作组本地内存的第二数组的列</span><br /></p>CPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">31</span>:<span class="number">46</span>    matr_mul_col_local (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">17.630</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">31</span>:<span class="number">46</span>    matr_mul_col_local (EURUSD,H1)    OpenCL total: time = <span class="number">5.227</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">31</span>:<span class="number">46</span>    matr_mul_col_local (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">31</span>:<span class="number">40</span>    matr_mul_col_local (EURUSD,H1)    CPUTime = <span class="number">92.150</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">30</span>:<span class="number">08</span>    matr_mul_col_local (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">30</span>:<span class="number">08</span>    matr_mul_col_local (EURUSD,H1)    =======================================</pre>GPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">21</span>:<span class="number">36</span>    matr_mul_col_local (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">58.069</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">21</span>:<span class="number">36</span>    matr_mul_col_local (EURUSD,H1)    OpenCL total: time = <span class="number">1.592</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">21</span>:<span class="number">36</span>    matr_mul_col_local (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">21</span>:<span class="number">34</span>    matr_mul_col_local (EURUSD,H1)    CPUTime = <span class="number">92.446</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">20</span>:<span class="number">01</span>    matr_mul_col_local (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">06</span>:<span class="number">20</span>:<span class="number">01</span>    matr_mul_col_local (EURUSD,H1)    =======================================
</pre>

<p style="text-align:justify;">两种情况都显示出了性能劣化，只是不太严重。通过更改工作组的大小，来提高（而非劣化）性能是很可能的。最好将上例作为不同用途 - 说明如何使用本地内存对象。<br /></p>

<p style="text-align:justify;">关于使用本地内存时性能下降，有一种假设可以解释。大约 2 年前，habrahabr.ru 上发表了 <a href="/go?link=https://habrahabr.ru/post/96122/" rel="nofollow" title="http://habrahabr.ru/post/96122/" target="_blank">《CUDA、GLSL 及 OpenMP 同 OpenCL 的对比》</a> （俄语）一文，文中称： </p>

<div class="fquote">从物理层面上讲，AMD 卡不支持本地内存；而是本地内存区域被映射到全局内存。<br /></div>就是同一篇文章的下方，作者做出了如下论述：

<div class="fquote">经过测试的 AMD 卡实际上没有本地片上存储器，所以某些需要本地内存的算法的速度就会大幅下降。<br /></div>

<p style="text-align:justify;">换句话说，这是否意味着 2 年前发布产品的本地内存不比全局内存快呢？上文发表的时间表明：在两年之前，Radeon HD 58xx 系列显卡已经面世，但根据作者的说法，还远未完善。我很难相信这一点，尤其是在 AMD 已推出轰动一时的 Evergreen 系列的情况下。我愿意利用更新的显卡来检验一下，比如 HD 69xx 系列。 <br /></p>

<div class="atten"><p>补充：开启 GPU Caps Viewer （GPU 效能查看器），您会在 OpenCL 选项卡中看到下述内容：</p><p style="text-align:center;"><img alt="图 18. HD 4870 支持的主要 OpenCL 参数" title="图 18. HD 4870 支持的主要 OpenCL 参数" src="https://c.mql5.com/2/4/gpucaps_param_local_mem_type__1.GIF" height="540" width="356" style="vertical-align:middle;" /><br /></p><p style="text-align:center;"><span class="small">图 18. HD 4870 支持的主要 OpenCL 参数</span><br /></p></div><div class="code"><p>CL_DEVICE_LOCAL_MEM_TYPE:全局<br /></p></div>

<div class="atten"><p>语言规范中提供的此参数的阐释（表 4.3，第 41 页）如下：</p>

<div class="fquote"><p>支持的本地内存类型。可以设置为 CL_LOCAL，表明是专用的本地内存存储，比如 SRAM 或 CL_GLOBAL。<br /></p></div><p style="text-align:justify;">由此，HD 4870 本地内存确实是全局内存的一部分，而且该显卡中的任何本地内存操作都因此不再有用，而且不会导致任何快于全局内存情况的发生。<a href="/go?link=https://community.amd.com/community/devgurus[hash]1171540" rel="nofollow" title="http://devgurus.amd.com/message/1171540[hash]1171540" target="_blank">此处</a>是另一处链接，其中包括 AMD 专家针对 HD 4xxx 序列这一方面的澄清。这并不一定就是说您的显卡有多糟糕；只是告诉您硬件相关的此类信息可以在哪里找到 - 这种情况下，是在 GPU Caps Viewer 中。<br /></p></div>

<pre class="code">throughput_arithmetic_CPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">5.227</span> ~ <span class="number">3.061</span> GFlops.
throughput_arithmetic_GPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">1.592</span> ~ <span class="number">10.050</span> GFlops.
</pre>

<p style="text-align:justify;">最后，我们通过显式完成内核的向量化，来添加几画点睛之笔。于第一数组的行迁移到私有内存阶段衍生的内核 (matr_mul_row_in_private.mq5) 会充当初始内核，因为它似乎是最快的。<br /><br /><br /></p>



<p><b>2.8. 内核向量化</b></p><p style="text-align:justify;">为避免混淆，最好将此操作划分成多个阶段。在最初的修改中，我们不会更改内核外部参数的数据类型，只会向量化内部循环的计算：<br /></p>

<pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"#define REALTYPE4 float4                                                     \r\n"</span>     
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  REALTYPE rowbuf[ COLSROWS ];                                               \r\n"</span>
      <span class="string">"  for( int col = 0; col &lt; COLSROWS; col ++ )                                 \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     rowbuf[ col ] =  in1[r * COLSROWS + col ];                              \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  REALTYPE sum;                                                              \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  for( int c = 0; c &lt; COLS2; c ++ )                                          \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     sum = 0.0;                                                              \r\n"</span>
      <span class="string">"     for( int cr = 0; cr &lt; COLSROWS; cr += 4 )                               \r\n"</span>
      <span class="string">"        sum += dot( ( REALTYPE4 ) ( rowbuf[ cr ],                            \r\n"</span>
      <span class="string">"                                    rowbuf[ cr + 1 ],                        \r\n"</span>     
      <span class="string">"                                    rowbuf[ cr + 2 ],                        \r\n"</span>     
      <span class="string">"                                    rowbuf[ cr + 3 ] ),                      \r\n"</span>     
      <span class="string">"                    ( REALTYPE4 ) ( in2[c * COLSROWS + cr     ],             \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + cr + 1 ],             \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + cr + 2 ],             \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + cr + 3 ] ) );         \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] = sum;                                             \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre><p style="text-align:center;"><span class="small">列表 8. 采用 float4 的内核的部分向量化（仅内部循环）<br /></span></p>完整源代码的文件为 matr_mul_vect.mq5。当然，COLSROWS 参数应可被 4 整除。<br /><br />CPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">16</span>    matr_mul_vect (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">18.657</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">16</span>    matr_mul_vect (EURUSD,H1)    OpenCL total: time = <span class="number">4.945</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">16</span>    matr_mul_vect (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">28</span>:<span class="number">11</span>    matr_mul_vect (EURUSD,H1)    CPUTime = <span class="number">92.259</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">38</span>    matr_mul_vect (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">26</span>:<span class="number">38</span>    matr_mul_vect (EURUSD,H1)    =======================================</pre><br />GPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">21</span>:<span class="number">30</span>    matr_mul_vect (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">78.079</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">21</span>:<span class="number">30</span>    matr_mul_vect (EURUSD,H1)    OpenCL total: time = <span class="number">1.186</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">21</span>:<span class="number">30</span>    matr_mul_vect (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">21</span>:<span class="number">28</span>    matr_mul_vect (EURUSD,H1)    CPUTime = <span class="number">92.602</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">19</span>:<span class="number">55</span>    matr_mul_vect (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">21</span>:<span class="number">19</span>:<span class="number">55</span>    matr_mul_vect (EURUSD,H1)    =======================================</pre><br /><p>出人意料的是，即便是这种初步的向量化，也在 GPU 上实现了很好的结果；尽管不算太大，但增益似乎仍有 10% 左右。<br /></p><p style="text-align:justify;">继续内核中的向量化：将“代价昂贵”的 REALTYPE4 向量类型转换操作，连同显式向量分量的规格一起，传送到填写私有变量 rowbuf[] 的外层辅助循环。内核中仍无变化。<br /></p><pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"#define REALTYPE4 float4                                                     \r\n"</span>     
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  REALTYPE4 rowbuf[ COLSROWS / 4 ];                                          \r\n"</span>
      <span class="string">"  for( int col = 0; col &lt; COLSROWS / 4; col ++ )                             \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     rowbuf[ col ] =  ( REALTYPE4 ) ( in1[r * COLSROWS + 4 * col ],          \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 4 * col + 1 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 4 * col + 2 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 4 * col + 3 ] );    \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  REALTYPE sum;                                                              \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  for( int c = 0; c &lt; COLS2; c ++ )                                          \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     sum = 0.0;                                                              \r\n"</span>
      <span class="string">"     for( int cr = 0; cr &lt; COLSROWS / 4; cr ++ )                             \r\n"</span>
      <span class="string">"        sum += dot(                 rowbuf[ cr ],                            \r\n"</span>
      <span class="string">"                    ( REALTYPE4 ) ( in2[c * COLSROWS + 4 * cr     ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 4 * cr + 1 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 4 * cr + 2 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 4 * cr + 3 ] ) );     \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] = sum;                                             \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre>

<p style="text-align:center;"><span class="small">列表 9. 摆脱内核主循环中“代价高昂”的类型转换操作</span></p>

<p style="text-align:justify;">注意：内层（及辅助）循环计数器的最大计数值已经低了 4 倍，而现在第一数组要求的读取操作比之前少了 4 倍 - 读取已经明确成为了一个向量操作。<br /></p>CPU：  <br />

<pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">43</span>    matr_mul_vect_v2 (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">24.480</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">43</span>    matr_mul_vect_v2 (EURUSD,H1)    OpenCL total: time = <span class="number">3.791</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">43</span>    matr_mul_vect_v2 (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">41</span>:<span class="number">39</span>    matr_mul_vect_v2 (EURUSD,H1)    CPUTime = <span class="number">92.805</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">06</span>    matr_mul_vect_v2 (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">40</span>:<span class="number">06</span>    matr_mul_vect_v2 (EURUSD,H1)    =======================================</pre>GPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">35</span>:<span class="number">28</span>    matr_mul_vect_v2 (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">185.605</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">35</span>:<span class="number">28</span>    matr_mul_vect_v2 (EURUSD,H1)    OpenCL total: time = <span class="number">0.499</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">35</span>:<span class="number">28</span>    matr_mul_vect_v2 (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">35</span>:<span class="number">27</span>    matr_mul_vect_v2 (EURUSD,H1)    CPUTime = <span class="number">92.617</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">33</span>:<span class="number">54</span>    matr_mul_vect_v2 (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">22</span>:<span class="number">33</span>:<span class="number">54</span>    matr_mul_vect_v2 (EURUSD,H1)    =======================================</pre>算术吞吐量：<br /><pre class="code">throughput_arithmetic_CPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">3.791</span> ~ <span class="number">4.221</span> GFlops.
throughput_arithmetic_GPU_OCL = <span class="number">16</span> <span class="number">000000000</span> / <span class="number">0.499</span> ~ <span class="number">32.064</span> GFlops.</pre>

<p>可以看出，CPU 性能方面的变化相当大，而对于 GPU 而言，几乎就是革命性的变化。源代码请见 matr_mul_vect_v2.mq5。<br /></p>

<p style="text-align:justify;">我们仅利用宽度为 8 的向量来执行与内核上一变量相关的相同操作。作者的决定可以用 GPU 内存带宽为 256 位 （即 32 字节 8 个浮点型数字）来解释；因此，8 个浮点数据的同时处理（等同于 float8 的并行使用）似乎就自然而然了。 <br /></p>

<p>请牢记：这种情况下，COLSROWS 值应该可以被 8 整除。这一要求很正常，因为更精细的优化会对数据设置更具体的要求。 <br /></p>

<pre class="code"><span class="keyword">const</span> <span class="keyword">string</span> clSrc =
      <span class="string">"#define COLS2     "</span>    + i2s( COLS2 )    +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define COLSROWS  "</span>    + i2s( COLSROWS ) +  <span class="string">"                            \r\n"</span>
      <span class="string">"#define REALTYPE  float                                                      \r\n"</span>
      <span class="string">"#define REALTYPE4 float4                                                     \r\n"</span>     
      <span class="string">"#define REALTYPE8 float8                                                     \r\n"</span>     
      <span class="string">"                                                                             \r\n"</span>
      <span class="string">"inline REALTYPE dot8( REALTYPE8 a, REALTYPE8 b )                             \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  REALTYPE8  c = a * b;                                                      \r\n"</span>      
      <span class="string">"  REALTYPE4  _1 = ( REALTYPE4 ) 1.;                                          \r\n"</span>      
      <span class="string">"  return( dot( c.lo + c.hi, _1 ) );                                          \r\n"</span>     
      <span class="string">"}                                                                            \r\n"</span>           
      <span class="string">"                                                                             \r\n"</span>           
      <span class="string">"__kernel void matricesMul( __global REALTYPE *in1,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *in2,                           \r\n"</span>
      <span class="string">"                           __global REALTYPE *out  )                         \r\n"</span>
      <span class="string">"{                                                                            \r\n"</span>
      <span class="string">"  int r = get_global_id( 0 );                                                \r\n"</span>
      <span class="string">"  REALTYPE8 rowbuf[ COLSROWS / 8 ];                                          \r\n"</span>
      <span class="string">"  for( int col = 0; col &lt; COLSROWS / 8; col ++ )                             \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     rowbuf[ col ] =  ( REALTYPE8 ) ( in1[r * COLSROWS + 8 * col ],          \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 1 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 2 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 3 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 4 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 5 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 6 ],      \r\n"</span>
      <span class="string">"                                      in1[r * COLSROWS + 8 * col + 7 ] );    \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  REALTYPE sum;                                                              \r\n"</span>
      <span class="string">"                                                                             \r\n"</span>     
      <span class="string">"  for( int c = 0; c &lt; COLS2; c ++ )                                          \r\n"</span>
      <span class="string">"  {                                                                          \r\n"</span>
      <span class="string">"     sum = 0.0;                                                              \r\n"</span>
      <span class="string">"     for( int cr = 0; cr &lt; COLSROWS / 8; cr ++ )                             \r\n"</span>
      <span class="string">"        sum += dot8(                rowbuf[ cr ],                            \r\n"</span>
      <span class="string">"                    ( REALTYPE8 ) ( in2[c * COLSROWS + 8 * cr     ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 1 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 2 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 3 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 4 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 5 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 6 ],         \r\n"</span>
      <span class="string">"                                    in2[c * COLSROWS + 8 * cr + 7 ] ) );     \r\n"</span>
      <span class="string">"     out[ r * COLS2 + c ] = sum;                                             \r\n"</span>
      <span class="string">"  }                                                                          \r\n"</span>
      <span class="string">"}                                                                            \r\n"</span> ;</pre><p style="text-align:center;"><span class="small">列表 10. 使用宽度为 8 的向量执行的内核向量化</span></p><p style="text-align:justify;">我们必须在内核代码中，插入允许计算宽度为 8 向量的无向积的内联函数 dot8()。在 OpenCL 中，标准函数 dot() 仅可计算宽度不超过 4 的向量的无向积。源代码请见 matr_mul_vect_v3.mq5。<br /></p>CPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">47</span>    matr_mul_vect_v3 (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">45.226</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">47</span>    matr_mul_vect_v3 (EURUSD,H1)    OpenCL total: time = <span class="number">2.200</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">47</span>    matr_mul_vect_v3 (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">11</span>:<span class="number">45</span>    matr_mul_vect_v3 (EURUSD,H1)    CPUTime = <span class="number">99.497</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">05</span>    matr_mul_vect_v3 (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">0</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">05</span>    matr_mul_vect_v3 (EURUSD,H1)    =======================================</pre>GPU：<br /><pre class="code"><span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">05</span>    matr_mul_vect_v3 (EURUSD,H1)    CPUTime / GPUTotalTime = <span class="number">170.115</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">05</span>    matr_mul_vect_v3 (EURUSD,H1)    OpenCL total: time = <span class="number">0.546</span> sec.
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">05</span>    matr_mul_vect_v3 (EURUSD,H1)    read = <span class="number">4000000</span> elements
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">20</span>:<span class="number">04</span>    matr_mul_vect_v3 (EURUSD,H1)    CPUTime = <span class="number">92.883</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31</span>    matr_mul_vect_v3 (EURUSD,H1)    <span class="number">1</span>st OCL martices mul:  device = <span class="number">1</span>;      ROWS1 = <span class="number">2000</span>; COLSROWS = <span class="number">2000</span>; COLS2 = <span class="number">2000</span>
<span class="number">2012.05</span>.<span class="number">27</span> <span class="number">23</span>:<span class="number">18</span>:<span class="number">31</span>    matr_mul_vect_v3 (EURUSD,H1)    =======================================</pre>

<p style="text-align:justify;">结果出人意料：CPU 上的运行时几乎比之前短了两倍，而 GPU 上的运行时却稍有加长，尽管 float8 对于 HD 4870 来讲，总线宽度已经足够（等同于 256 位）。这里，我们要再一次求助于 GPU Caps Viewer。 <br /></p>
<p style="text-align:justify;">相关阐释请见图 18 参数列表的倒数第二行中： <br /></p>

<div class="code"><p>CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT: 4</p></div>

<p><br />查阅《OpenCL 规范》，您就会在第 37 页表 4.3 的最后一列看到下述有关此参数的文本：</p><div class="fquote">

<p>可以放入向量的内置标量类型的首选朴素向量宽度尺寸。向量宽度被定义为可以存储于该向量中的标度元素的数量。<br />
</p>
</div><p>由此，对于 HD 4870 而言，向量 floatN 的首选向量宽度为 float4 而非 float8。</p>
<p>我们就在这里结束内核优化周期吧。我们还能讲到更多内容，只是限于本文篇幅，就不再深入讨论了。<br /></p><br />

<h3>总结<br /></h3>

<p style="text-align:justify;">本文讲述了一些优化能力，但至少要对此内核借以执行的基本硬件多少有些了解，才能启动这些能力。</p>

<p style="text-align:justify;"> 获取的数据远非最高值，但即便是这样，也建议充分利用现有资源（由该终端开发人员实施的 OpenCL API 不允许控制对于优化而言很重要的一些参数 - 尤其是工作组的大小），通过主机程序执行获得的增益是非常可观的：GPU 上执行的增益，与 CPU （尽管未充分优化）上的顺序程序增益的比率约为 200:1。<br /></p>

<p>我真心地感激 <b>MetaDriver</b>，感谢其提供的宝贵建议，在我还没有独立 GPU 的时候给我利用它的机会。</p>
<p><br /></p>
<p><b>随附文件目录：</b></p>
<ol>
<li><span style="color:rgb(0, 87, 174);">matr_mul_2dim.mq5</span> - 带有二维数据形式的主机上的初始顺序程序；</li><li><span style="color:rgb(0, 87, 174);">matr_mul_1dim.mq5</span> - 带有线性数据形式及与 MQL5 OpenCL API 相关绑定的内核的第一次实施；</li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_1dim_coalesced</span> - 配有已合并全局内存访问的内核；</li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_sum_local</span> - 为计算无向积而引入的一个私有变量，不再访问存储于全局内存的输出数组中的某个已计算单元格；<br /></li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_row_calc</span> - 内核中整个输出矩阵行的计算；</li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_row_in_private</span> - 被迁移至私有内存的第一数组的行；</li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_col_local.mq5</span> - 被迁移至本地内存的第二数组的列；</li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_vect.mq5</span> - 内核的第一次向量化（利用 float4，仅于主循环中的内子循环）；</li>
<li><span style="color:rgb(0, 87, 174);">matr_mul_vect_v2.mq5</span> - 摆脱主循环中“代价昂贵”的数据转换操作；</li><li><span style="color:rgb(0, 87, 174);">matr_mul_vect_v3.mq5</span> - 利用宽度为 8 的向量执行向量化。</li>
</ol>
      </div>
          <p style="text-align: right;"><small>本文译自 MetaQuotes Software Corp. 撰写的俄文原文 <br />原文地址： <a href="/ru/articles/407" target="_blank">https://www.mql5.com/ru/articles/407</a></small></p>
<div id="cb_407" class="attachBlock">
  <strong>附加的文件</strong> |
  <div class="grouped-attachments-help">
    <a title="下载单独ZIP中的所有附件" href="/zh/articles/download/407.zip">
      <i class="attach-icon attach-icon_zip"></i>下载ZIP
    </a>
  </div>
    <div class="attachItem">
      <a title="下载 opencl_optimization_mql5.zip" href="/zh/articles/download/407/opencl_optimization_mql5.zip"><i class="attach-icon attach-icon_zip"></i>opencl_optimization_mql5.zip</a>
      <span class="attachSize">(35 KB)</span>
    </div>
</div>
    </div>
      <div class="copyright">
        <span style="color: #f00; font-weight: bold;">注意:</span> MetaQuotes Ltd.将保留所有关于这些材料的权利。全部或部分复制或者转载这些材料将被禁止。
      </div>
  </div>

      <div class="relap-container">
          
      </div>
<div class="other-author-articles ui">
  <h4 class="other-author-articles__title">该作者的其他文章</h4>
  <ul class="other-author-articles__list">
      <li>
        <a href="/zh/articles/405" data-fz-event="MQL5+Article+From+Author+Article">OpenCL：并行世界的桥梁</a>
      </li>
      <li>
        <a href="/zh/articles/39" data-fz-event="MQL5+Article+From+Author+Article">MQL5 中的事件处理：快速更改 MA 周期</a>
      </li>
      <li>
        <a href="/zh/articles/1530" data-fz-event="MQL5+Article+From+Author+Article">谬误，第 2 部分统计学是一门伪科学，亦或是一部记录艰难生计的编年史</a>
      </li>
      <li>
        <a href="/zh/articles/1526" data-fz-event="MQL5+Article+From+Author+Article">谬误，第 1 部分：资金管理排第二位，并不是很重要</a>
      </li>
  </ul>
</div>
  <div id="articleAdditional">
      <div class="article__last-comments">
        

<div class="comments-preview">
    <div class="title">
<span></span><b> <a href="/zh/forum/17252">前往讨论</a>
</b>    </div>
    <div>
        
    </div>
</div>

      </div>
  <div>
        <div class="articles-bottom-list">
            <div class="articles-bottom-list__row">
              <div class="articles-bottom-list__column">
                  <div class="articles-bottom-list__item">
                    <img alt="作为创建自动化交易系统新方法的自动机编程" src="https://c.mql5.com/2/0/11__3.png" loading="lazy" width="60" height="60" class="articles-bottom-list__avatar" />
                    <a href="/zh/articles/446" data-fz-event="MQL5+Article+Next+Article" class="articles-bottom-list__title">作为创建自动化交易系统新方法的自动机编程</a>
                    <div class="articles-bottom-list__desc">本文会让我们以一种全新的视角，来进行 MQL4 与 MQL5 中 EA、指标及脚本的开发。将来，此编程范式会逐渐变成 EA 实施领域所有交易者的基本标准。利用这种自动机编程范式，MQL5 和 MetaTrader 5 开发人员也就具备了某种程度上创建新语言 - MQL6 - 和新平台 - MetaTrader 6 的能力。</div>
                  </div>
              </div>
              <div class="articles-bottom-list__column">
                  <div class="articles-bottom-list__item">
                    <img alt="OpenCL：并行世界的桥梁" src="https://c.mql5.com/2/0/OpenCL_Logo.png" loading="lazy" width="60" height="60" class="articles-bottom-list__avatar" />
                    <a href="/zh/articles/405" data-fz-event="MQL5+Article+Next+Article" class="articles-bottom-list__title">OpenCL：并行世界的桥梁</a>
                    <div class="articles-bottom-list__desc">2012 年 1 月末，从事 MetaTrader 5 开发业务的软件开发公司宣布 MQL5 可向 OpenCL 提供原生支持。本文通过一个示例说明了 MQL5 环境下 OpenCL 的编程基础知识，并列举了几个示例，讲述了为提高运行速度所做的朴素优化。</div>
                  </div>
              </div>
            </div>
            <div class="articles-bottom-list__row">
              <div class="articles-bottom-list__column">
                  <div class="articles-bottom-list__item">
                    <img alt="MQL5.community 最活跃成员获颁 iPhones 大奖！" src="https://c.mql5.com/2/0/win_iPhone.png" loading="lazy" width="60" height="60" class="articles-bottom-list__avatar" />
                    <a href="/zh/articles/451" data-fz-event="MQL5+Article+Next+Article" class="articles-bottom-list__title">MQL5.community 最活跃成员获颁 iPhones 大奖！</a>
                    <div class="articles-bottom-list__desc">继我们决定奖励最为出色的 MQL5.com 参与者后，我们已经选出了确定每一位参与者对本社区发展所做贡献的关键准则。结果我们选出了下述优胜者，他们在网站上发布的文章数量最多 - investeo （11 篇）和 victorg （10 篇）；以及将其代码提交到代码库的 &amp;ndash; GODZILLA （340 个程序）、Integer （61 个程序）和 abolk （21 个程序）。</div>
                  </div>
              </div>
              <div class="articles-bottom-list__column">
                  <div class="articles-bottom-list__item">
                    <img alt="为什么说 MQL5 应用商店是销售交易策略与技术指标的最佳去处" src="https://c.mql5.com/2/0/mql5-market.png" loading="lazy" width="60" height="60" class="articles-bottom-list__avatar" />
                    <a href="/zh/articles/401" data-fz-event="MQL5+Article+Next+Article" class="articles-bottom-list__title">为什么说 MQL5 应用商店是销售交易策略与技术指标的最佳去处</a>
                    <div class="articles-bottom-list__desc">MQL5.community 应用商店为 EA 交易开发人员提供了一个由成千上万潜在客户构成的、已经成型的市场。这里是销售交易机器人和技术指标的最佳去处！</div>
                  </div>
              </div>
            </div>
        </div>
  </div>
  </div>
  <div class="clear-fix"></div>


<div id="wdausxxqrpvhekbwjrjlhqjghyhesrqqau" class="rwz5ulp96y41ztlt8 rwz5ulp96y41ztlt8_articles-view ff"></div></div>


<script type="application/ld+json">
{"@context":"https://schema.org","@type":"TechArticle","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.mql5.com/zh/articles/407"},"headline":"OpenCL：从朴素到更具深度的编程","image":["https://c.mql5.com/2/4/memory_model.PNG","https://c.mql5.com/2/4/Radeon_HD_6970_memory.png","https://c.mql5.com/2/4/array_pointer__2.PNG","https://c.mql5.com/2/4/1_int_from_8_only.PNG","https://c.mql5.com/2/4/3_accesses.PNG","https://c.mql5.com/2/4/coalescenced-uncoalescenced-BW.PNG","https://c.mql5.com/2/4/no_conflicts_local.PNG","https://c.mql5.com/2/4/conflicts_local.PNG","https://c.mql5.com/2/4/broadcast.PNG","https://c.mql5.com/2/4/58xx_table.PNG","https://c.mql5.com/2/4/matrix_mul_formula.PNG","https://c.mql5.com/2/4/mul_picture__2.PNG","https://c.mql5.com/2/4/matrix2buff__3.GIF","https://c.mql5.com/2/4/mul_picture_rowcalc.PNG","https://c.mql5.com/2/4/row_in_private_mem.PNG","https://c.mql5.com/2/4/row_private_col_local.PNG","https://c.mql5.com/2/4/barrier__2.PNG","https://c.mql5.com/2/4/gpucaps_param_local_mem_type__1.GIF"],"datePublished":"2014-01-09T11:43:36","dateModified":"2014-01-09T11:42:59","author":{"@type":"Person","name":"Sceptic Philozoff","url":"https://www.mql5.com/zh/users/mathemat"},"publisher":{"@type":"Organization","name":"MQL5.Community","url":"https://www.mql5.com","logo":{"@type":"ImageObject","url":"https://c.mql5.com/i/community/logo_mql5-2.png"}},"description":"本文要重点讲述的是一些优化能力，但至少要对 OpenCL 内核借以执行的基本硬件多少有些了解，才能启动这些能力。获取的数据远非最高值，但即便是这样，也建议充分利用现有资源（由该终端开发人员实施的 OpenCL API 不允许控制对于优化而言很重要的一些参数 - 尤其是工作组的大小），通过主机程序执行获得的增益是非常可观的。"}
</script>


    


<div class="hidden" id="popupRegisterLogin">
  <div class="register-login-popup">
    <div class="register-login-popup__header">
      <img src="https://c.mql5.com/i/registerlandings/logo-2.png" srcset="https://c.mql5.com/i/registerlandings/logo-2_2x.png 2x" alt="MQL5 - MetaTrader 5客户端内置的交易策略语言" loading="lazy" width="74" height="24" />
    </div>
    <div class="register-login-popup__content">
      <div class="register-login-popup__desc">
        <div class="register-login-popup__title">您错过了交易机会：</div>
        <ul>
<li>免费交易应用程序</li>
<li>免费24小时外汇VPS</li>
<li>8,000+信号可供复制</li>
<li>探索金融市场的经济新闻</li>
</ul>
      </div>
      <div class="register-login-popup__forms ui">
        <div class="register-login-popup__tabs" id="registerLoginPopupTabs">
          <span data-id="register" id="registerLoginPopupTab_register" class="register-login-popup__tab register-login-popup__tab_active">注册</span>
          <span data-id="login" id="registerLoginPopupTab_login" class="register-login-popup__tab">登录</span>
        </div>
        <div id="registerLoginPopupTabContent_register">
          <div class="ui auth-form__content">
    
  <script type="text/javascript">/*&lt;![CDATA[*/ if (!window.V) var V = []; /*]]&gt;*/</script>
<script type="text/javascript">/*&lt;![CDATA[*/ if(! window.V) var V=[]; /*]]&gt;*/</script>
<form method="POST" action="/zh/auth_register_short" id="PopupRegisterquickRegisterForm" onsubmit="PopupRegisterquickRegistration.OnSubmit(this,'zh');if(Validate(this)) Ajax.form(this,{onready:PopupRegisterquickRegistration.OnSuccessPopup,onerror:PopupRegisterquickRegistration.OnError,onbeginrequest:PopupRegisterquickRegistration.DisableInputs,onendrequest:PopupRegisterquickRegistration.EnableInputs});return(false);" enctype="multipart/form-data"><input type="hidden" name="__signature" value="2a4afa0dd284c62a19959d37271fc952" />
    <div class="auth-form__inputs">
      <input type="hidden" value="0" name="IsValidate" id="PopupRegisterIsValidate" />

      <!--[if lt IE 10]><div class="note">登录名:</div><![endif]-->
      <div class="auth-form__box-input">
        <input type="text" id="PopupRegisterusername" name="username" class="input" maxlength="32" onchange="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.CheckUserName();}" onkeyup="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.ValidateUserName(this, '请输入有效登录名');}" placeholder="登录名" title="可以包括字母，数字，点，破折号和下划线字符，不能以点开始或结束。允许长度为3至32个字符。" onfocus="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.OnFocus(this,'');}" onblur="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.OnBlur(this);}" />
        <script type="text/javascript" id="validate_PopupRegisterusername">/*&lt;![CDATA[*/ mqGlobal.AddOnReady(function() {V.push(['PopupRegisterusername',10,'您可以使用拉丁字符、数字、下划线和句号。',validate_username]);}); /*]]&gt;*/</script>

        <label class="label" for="PopupRegisterusername">拉丁字符（不带空格）</label>
      </div>
      <!--[if lt IE 10]><div class="note">您的电子邮箱:</div><![endif]-->
      <div class="auth-form__box-input">
        <input class="input" type="email" id="PopupRegisteremail" name="email" placeholder="您的电子邮箱" title="请输入电子邮箱地址(不能超过 256 个字符)。例如：john@example.com" onchange="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.OnChange(this);}" onfocus="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.OnFocus(this,'');}" onblur="if(window.PopupRegisterquickRegistration){PopupRegisterquickRegistration.OnBlur(this);}" />
        <script type="text/javascript" id="validate_PopupRegisteremail">/*&lt;![CDATA[*/ mqGlobal.AddOnReady(function() {V.push(['PopupRegisteremail',10,'请输入有效email',validate_email]);}); /*]]&gt;*/</script>

        <label class="label" for="PopupRegisteremail">密码将被发送至该邮箱</label>
      </div>
      <input name="PrefixId" type="hidden" value="Popup+Register" />
    </div>
    <span id="PopupRegisterquickRegisterSubmit">
      <input type="submit" value="注册" id="PopupRegisterquickRegisterButton" title="注册并接收包含密码的邮件" class="button" />
    </span>
    <span id="PopupRegisterquickRegisterErrorMessage" class="quick-register-error-message field-validation-error" style="text-align: center; margin-top: 16px; display: none;">
      发生错误
    </span>
</form>
    
</div>
<div class="auth-social">
  <ul class="auth-social-list" id="socialList">
    <li><a onclick="window.fpush({name: 'MQL5+Popup+Register+Facebook', unit: 'section', value: 'Articles'}); " href="https://www.mql5.com/zh/auth_oauth2?provider=Facebook&amp;amp;return=popup&amp;amp;reg=1" class="auth-soc-button qa-fb-button auth-soc-button_fb" rel="nofollow">使用 Facebook 登录</a></li>
    <li><a onclick="window.fpush({name: 'MQL5+Popup+Register+Google', unit: 'section', value: 'Articles'}); " href="https://www.mql5.com/zh/auth_oauth2?provider=Google&amp;amp;return=popup&amp;amp;reg=1" class="auth-soc-button qa-google-button auth-soc-button_google" rel="nofollow">使用 Google 登录</a></li>
  </ul>
</div>
<div class="auth-block-agree">
  <p>
    您同意<a target="_blank" href="/zh/about/privacy">网站政策</a>和<a target="_blank" href="/zh/about/terms">使用条款</a>
  </p>
</div>


        </div>
        <div id="registerLoginPopupTabContent_login" class="hidden">
            <div class="auth-form__text">
    如果您没有帐号，请<a href="https://www.mql5.com/zh/auth_register" rel="nofollow" style="vertical-align: top">注册</a>
  </div>
<div class="ui auth-form__content auth-form__content_login" id="loginFormWrapper">
    
  <div id="needCookies" class="need-cookies hidden">
    <div class="danger-box">
      <p>可以使用cookies登录MQL5.com网站。</p>
<p>请在您的浏览器中启用必要的设置，否则您将无法登录。</p>
    </div>
  </div>
<script type="text/javascript">/*&lt;![CDATA[*/ if(! window.V) var V=[]; /*]]&gt;*/</script>
<form method="POST" action="/zh/auth_login" id="loginForm" onsubmit="if(window.quickLogin){return window.quickLogin.onSubmit(this);}var result = Validate(this); if(result) { preventDoubleSubmit(this); } return result;"><input id="RedirectAfterLoginUrl" name="RedirectAfterLoginUrl" type="hidden" value="" /><input id="RegistrationUrl" name="RegistrationUrl" type="hidden" value="" /><input data-val="true" data-val-required="The ShowOpenId field is required." id="ShowOpenId" name="ShowOpenId" type="hidden" value="True" /><input id="TrackingSection" name="TrackingSection" type="hidden" value="Articles" />    <input name="ViewType" type="hidden" value="5" />
      <input name="PrefixId" type="hidden" value="Popup+Login" />
    <!--[if lt IE 10]><div class="note">您的登录名:</div><![endif]-->
    <div class="auth-form__box-input">
      <input class="input qa-login" id="Login" name="Login" onchange="if(window.quickLogin){window.quickLogin.onChange(this);}" placeholder="登录名或电子邮箱" title="您的登录名" type="text" value="" />
      <script type="text/javascript" id="validate_Login">/*&lt;![CDATA[*/ mqGlobal.AddOnReady(function() {V.push(['Login',1,'输入注册时使用的登录名']);});mqGlobal.AddOnReady(function() {V.push(['Login',10,'电子邮箱无法使用。请输入您的登录名',validateLogin]);}); /*]]&gt;*/</script>
    </div>
    <!--[if lt IE 10]><div class="note">密码:</div><![endif]-->
    <div class="auth-form__box-input">
      <div class="input-with-show">
        <input autocomplete="off" class="input qa-password" id="Password" name="Password" onchange="if(window.quickLogin){window.quickLogin.onChange(this);}" placeholder="密码" title="请输入密码" type="password" />
        <span class="input-with-show__icon" title="显示密码" onclick="if(window.quickLogin){window.quickLogin.showPass(this, '显示密码', '隐藏密码');}"></span>
      </div>
      <script type="text/javascript" id="validate_Password">/*&lt;![CDATA[*/ mqGlobal.AddOnReady(function() {V.push(['Password',1,'请输入密码']);}); /*]]&gt;*/</script>
    </div>
    <script type="text/javascript">
    function validateLogin(input) {
      return true;
    }
    </script>
    <div class="forgot" id="loginForgotBlock"><a id="loginForgotLink" href="https://www.mql5.com/zh/auth_forgotten?return=popup">忘记您的登录名/密码？</a></div>
    <input type="submit" class="button button_yellow qa-submit" id="loginSubmit" value="登录" title="输入" />
</form></div>

  <div class="auth-social" id="authSocialBlock">
    <ul class="auth-social-list" id="socialList">
      <li><a onclick="window.fpush({name: 'MQL5+Popup+Login+Facebook', unit: 'section', value: 'Articles'}); " href="https://www.mql5.com/zh/auth_oauth2?provider=Facebook&amp;amp;return=popup" class="auth-soc-button qa-fb-button auth-soc-button_fb" rel="nofollow">使用 Facebook 登录</a></li>
      <li><a onclick="window.fpush({name: 'MQL5+Popup+Login+Google', unit: 'section', value: 'Articles'}); " href="https://www.mql5.com/zh/auth_oauth2?provider=Google&amp;amp;return=popup" class="auth-soc-button qa-google-button auth-soc-button_google" rel="nofollow">使用 Google 登录</a></li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </div>
</div>
<script id="popupSection" type="application/json">{"section": "Articles"}</script>
<script id="popupTranslate" data-type="translate" type="application/json">
{
  "popup":
  {
  "EmailTitle" : "密码已经发送到{0}",
  "EmailDescription" : "使用收到的密码和注册时指定的登录名进行登录",
  "SubmitButtonText" : "激活账户",
  "RegistrationTip" : "如果您没有收到密码邮件，请检查垃圾箱文件夹或&amp;lt;a href={0}&amp;gt;重新注册&amp;lt;/a&amp;gt;"
  }
}
</script>

    
 
    </div>


<div class="footer  desktop" id="footer">
  <ul class="links  links_desktop">
      <li id="navFooterCommunity">
        <b>MQL5.community</b>
        <ul>
          <li><a href="/zh/trading" data-fz-event="MQL5+Footer+Trading">在线交易 / WebTerminal</a></li>
          <li><a href="/zh/code" data-fz-event="MQL5+Footer+CodeBase">免费技术指标和自动交易</a></li>
          <li><a href="/zh/articles" data-fz-event="MQL5+Footer+Articles">关于编程和交易的文章</a></li>
          <li><a href="/zh/job" data-fz-event="MQL5+Footer+Job">订购自由职业者的自动交易</a></li>
          <li><a href="/zh/market" data-fz-event="MQL5+Footer+Market">EA交易和应用程序市场</a></li>
          <li><a href="/zh/signals" data-fz-event="MQL5+Footer+Signals">跟随外汇信号</a></li>
          <li><a href="/zh/vps" data-fz-event="MQL5+Footer+VPS">低延迟外汇VPS</a></li>
          <li><a href="/zh/forum" data-fz-event="MQL5+Footer+Forum">交易者论坛</a></li>
          <li><a href="/zh/blogs" data-fz-event="MQL5+Footer+Blogs">交易博客</a></li>
          <li><a href="/zh/charts" data-fz-event="MQL5+Footer+Charts">图表</a></li>
        </ul>
      </li>
      <li id="navFooterMt5">
        <b>MetaTrader 5</b>
        <ul>
          <li><a href="https://www.metatrader5.com" data-fz-event="MQL5+Footer+MetaTrader+5"><span class="nobr">MetaTrader 5</span> 交易平台</a></li>
          <li><a href="https://www.metatrader5.com/zh/releasenotes" data-fz-event="MQL5+Footer+MetaTrader+5"><span class="nobr">MetaTrader 5</span>最新更新</a></li>
          <li><a href="https://www.metatrader5.com/zh/news" data-fz-event="MQL5+Footer+MetaTrader+5">新闻，执行和技术</a></li>
          <li><a href="https://www.metatrader5.com/zh/terminal/help" data-fz-event="MQL5+Footer+MetaTrader+5"><span class="nobr">MetaTrader 5</span> 用户手册</a></li>
          <li><a href="/zh/docs" data-fz-event="MQL5+Footer+Docs">交易策略的MQL5语言</a></li>
          <li><a href="https://cloud.mql5.com" data-fz-event="MQL5+Footer+Cloud">MQL5 Cloud Network</a></li>
          <li><a href="https://www.finteza.com/?utm_source=www.mql5.com&amp;utm_medium=cpc&amp;utm_term=cross-link&amp;utm_content=visit.finteza.com&amp;utm_campaign=0791.finteza.cross-link" data-fz-event="MQL5+Footer+Finteza" target="_blank">端到端分析</a></li>
            <li><a href="https://download.metatrader.com/cdn/web/metaquotes.software.corp/mt5/mt5setup.exe?utm_source=www.mql5.com&amp;utm_campaign=download" data-fz-event="MetaTrader+5+Desktop+Download">下载 <span class="nobr">MetaTrader 5</span></a></li>
            <li><a href="https://www.metatrader5.com/zh/terminal/help/start_advanced/installation" data-fz-event="MQL5+Footer+MetaTrader+5">安装平台</a></li>
            <li><a href="https://www.metatrader5.com/zh/terminal/help/start_advanced/deinstallation" data-fz-event="MQL5+Footer+MetaTrader+5">卸载平台</a></li>
        </ul>

      </li>
    <li id="navFooterWebsite">
        <b>网址</b>
        <ul>
          <li><a href="/zh/about" data-fz-event="MQL5+Footer+About">关于</a></li>
            <li><a href="/zh/wall" data-fz-event="MQL5+Footer+Wall">时间轴</a></li>
          <li><a href="/zh/about/terms" data-fz-event="MQL5+Footer+About">条款和条件</a></li>
          <li><a href="/zh/about/autopayments" data-fz-event="MQL5+Footer+About">定期付款协议</a></li>
          <li><a href="/zh/about/agencyagreement" data-fz-event="MQL5+Footer+About">代理协议 – 报价</a></li>
          <li><a href="/zh/about/privacy" data-fz-event="MQL5+Footer+About">隐私和数据保护政策</a></li>
          <li><a href="/zh/about/cookies" data-fz-event="MQL5+Footer+About">Cookies政策</a></li>
          <li>
<a id="chatBotBtn" href="#" class="chatbot-button" onclick="window.fpush('MQL5+Contacts+Chat');"><i class=""></i><img src="https://c.mql5.com/i/loading.gif" loading="lazy" width="16" height="16" alt="" />联系和请求</a><script type="text/javascript">mqGlobal.AddOnReady(function () {chatBot.init('chatBotBtn', 'zh');}); var chatBotUserLang = 'zh'; </script>          </li>
        </ul>
    </li>
      <li id="navFooterDownload">
        <b>加入我们 - 下载 <span class="nobr">MetaTrader 5！</span></b>
        <ul>
            <li class="icon windows"><a href="https://download.metatrader.com/cdn/web/metaquotes.software.corp/mt5/mt5setup.exe?utm_source=www.mql5.com&amp;utm_campaign=download" data-fz-event="MetaTrader+5+Desktop+Download" title="免费下载MetaTrader 5 Windows版">Windows</a></li>
            <li class="icon ios"><a href="https://download.metatrader.com/cdn/mobile/mt5/ios?utm_source=www.mql5.com&amp;utm_campaign=install.metaquotes" data-fz-event="MetaTrader+5+iOS+Download" target="_blank" rel="nofollow noopener" title="免费下载MetaTrader 5 iPhone版">iPhone/iPad</a></li>
            <li class="icon macos"><a href="https://download.metatrader.com/cdn/web/metaquotes.software.corp/mt5/MetaTrader5.dmg?utm_source=www.mql5.com&amp;utm_campaign=download" data-fz-event="MetaTrader+5+Desktop+Download" title="免费下载MetaTrader 5 Mac OS版">Mac OS</a></li>
            <li class="icon android"><a href="https://download.metatrader.com/cdn/mobile/mt5/android?utm_source=www.mql5.com&amp;utm_campaign=install.metaquotes" data-fz-event="MetaTrader+5+Android+Download" target="_blank" rel="nofollow noopener" title="从Google play免费下载MetaTrader 5安卓版"><span>Android</span></a></li>
            <li class="icon huawei"><a href="https://download.metatrader.com/cdn/mobile/mt5/android/app-gallery?utm_source=www.mql5.com&amp;utm_campaign=install.metaquotes" data-fz-event="MetaTrader+5+Android+Download" target="_blank" rel="nofollow noopener" title="MetaTrader 5 Android (Huawei AppGallery)"><span>Huawei</span></a></li>
            <li class="icon linux"><a href="/zh/articles/625" data-fz-event="MetaTrader+5+Desktop+Download" target="_blank" title="Linux 上的 MetaTrader 5"><span>Linux</span></a></li>
          <li class="icon tradays"><a href="https://www.tradays.com/zh/download?utm_source=www.mql5.com&amp;utm_campaign=download" data-fz-event="MQL5+Footer+Download+Tradays" target="_blank" title="Tradays经济日历"><span>Tradays经济日历</span></a></li>
        </ul>

        <div class="footer__other">
          <div class="footer__not-a-broker">不是交易商，不提供真实交易账户</div>
          <div class="copyright">13 Anastasi Sioukri, 3105, Limassol, Cyprus</div>
          <div class="copyright">Copyright 2000-2022, <span class="nobr">MetaQuotes Ltd</span></div>
        </div>
      </li>
  </ul>
</div>


    <div class="shadow-layer" id="layer"></div>
        
  </div>
  <script type="text/javascript">
  (function(a,e,f,g,b,c,d){a[b]||(a.FintezaCoreObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=!0,c.defer=!0,c.src=g,d&amp;&amp;d.parentNode&amp;&amp;d.parentNode.insertBefore(c,d))})
    (window,document,"script","/tz/core.js","fz");
  window.fz("register", "website", {
    id: "sqjxkxkswybhifrohpyooonwgbvsfzmayq",
    trackLinks: true
  });
  </script>
  <script type="text/javascript">
window.fz("show","vgckrufggwxdtfscpyalmenexmvhljduja");mqGlobal.AddOnReady(function () {
              if (!window.shareManager) {
                window.shareManager = new Share();
              }
            });mqGlobal.AddOnReady(function () {
              if (!window.Pocket) {
                window.Pocket = new PocketManager();
              }
            });if (window.relap) window.relap.ar('Jdolzg7OMYR-ogAA');mqGlobal.AddOnReady(function () {
            if (!window.translateManager) {
              window.translateManager = new Translate();
            }
            if (document.querySelectorAll) {
              var translateElements = document.querySelectorAll(".translateMenu");
              if (translateElements) {
                var i = 0, count = translateElements.length;
                for (i; i &lt; count; i++) {
                  (function (i) {
                    var contentid = dataset(translateElements[i], "contentid"),
                      sourcelang = dataset(translateElements[i], "sourcelang"),
                      targetlang = dataset(translateElements[i], "targetlang"),
                      moduleid = parseInt(dataset(translateElements[i], "moduleid")),
                      typeid = parseInt(dataset(translateElements[i], "typeid")),
                      entityid = parseInt(dataset(translateElements[i], "entityid"));
                    Core.AddHandler(translateElements[i], "mouseover", function () {
                      return translateManager.SetMenu(this, contentid, sourcelang, targetlang, moduleid, typeid, entityid);
                    });
                  })(i);
                }
              }
            }
          });window.fz("show","wdausxxqrpvhekbwjrjlhqjghyhesrqqau");window.mqGlobal.AddOnLoad(function () {
        window.fpush('MQL5+Article+Open');
        Articles.CheckOnScrollDown();
      });mqGlobal.AddOnReady(function () {
      window.PopupRegisterquickRegistration = new QuickRegistration('PopupRegister','Popup+Register', 'Articles');
    });
    function validate_username(input) {
       var reg = /^([\-_a-z0-9]){1}([\-._a-z0-9]){1,30}([\-_a-z0-9]){1}$/i,
        value = input.value,
        result = true;
      if (reg.test(value)) {
        result = true;
      }
      else {
        result = false;

        window.fpush({
          name: 'MQL5+Popup+Register+Invalid+Login',
          unit: 'section',
          value: 'Articles'
        });
              }
      return result;
    }
    function validate_email(input) {
      var reg = /^\w+([-+.'']{1,2}\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/i,
        value = input.value,
        result = true,
        length_value = value.length;
      if (reg.test(value) &amp;&amp; length_value &gt;= 1 &amp;&amp; length_value &lt;= 40) {
        result = true;
      }
      else {
        result = false;

        window.fpush({
          name: 'MQL5+Popup+Register+Invalid+Email',
          unit: 'section',
          value: 'Articles'
        });
              }
      return result;
    }mqGlobal.AddOnReady(function () {
      var username = $('PopupRegisterusername'),
        email = $('PopupRegisteremail');
      if (username)
        username.value = '';
      if (email)
        email.value = '';
    });mqGlobal.AddOnReady(function () {
      window.quickLogin = new QuickLogin('Popup+Login', 'Articles');
    });mqGlobal.AddOnLoad(function () {
        window.showLoginRegisterPopupAtEnd();
      });mqGlobal.AddOnLoad(function(){window.keywordMainFormSuggests = new Suggestions("keyword","https://search.mql5.com/api/suggest","zh",function(){$('main_search_form').onsubmit();});});window.fz("show","bfogggabsofabcpxuzmgaibarmaxasdrj");mqGlobal.AddOnReady(function ()
      {
        window.floatVerticalPanelNode = FloatVerticalPanel('该网站使用cookies。了解有关我们&lt;a href="/zh/about/cookies"&gt;Cookies政策&lt;/a&gt;的更多信息。','cookie_accept');
      });      mqGlobal.AddOnLoad(function () {
             Mql5Cookie.init('mql5.com','5058926924570804025');
      });
      if (typeof Attach !== "undefined")
        Attach.setAcceptFilter(".zip, .txt, .log, .mqh, .ex5, .mq5, .mq4, .ex4, .mt5, .set, .tpl, .cl, .py, .sqlite, .csv, .ipynb, .gif, .png, .jpg, .jpeg");
  </script>
    <div class="b-fixed-mt" id="bFixedMt" style="display: none;">
      <div id="jjyeyqenuvuvgqlpjjrqigjthhcgagwglu" class="bfb ff"><script type="text/javascript">window.fz("show","jjyeyqenuvuvgqlpjjrqigjthhcgagwglu");</script></div>
    </div>


  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Organization",
      "url": "https://www.mql5.com",
      "logo": "https://c.mql5.com/i/community/logo_mql5-2.png",
      "sameAs": [
        "https://www.facebook.com/mql5.community",
        "https://www.twitter.com/mql5com",
        "https://www.youtube.com/user/MetaQuotesOfficial"
       ]
    }
  </script>
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebSite",
  "name": "MQL5.Community",
  "url": "https://www.mql5.com",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://www.mql5.com/zh/search?keyword={keyword}",
    "query-input": "required name=keyword"
  }
}
  </script>
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"ItemList","itemListElement":[{"@type":"SiteNavigationElement","position":1,"name":"论坛","description":"交易策略和算法交易的讨论。MQL5.community  最大的外汇论坛","url":"https://www.mql5.com/zh/forum"},{"@type":"SiteNavigationElement","position":2,"name":"市场","description":"MetaTrader 市场 - 自动交易，指标，交易书籍和杂志的市场","url":"https://www.mql5.com/zh/market"},{"@type":"SiteNavigationElement","position":3,"name":"信号","description":"MetaTrader的群组交易，复制交易和账户监控 - MQL5.com交易信号","url":"https://www.mql5.com/zh/signals"},{"@type":"SiteNavigationElement","position":4,"name":"自由职业者","description":"订购EA交易、技术指标和算法交易应用程序。外汇工作。MQL5.com自由职业者服务","url":"https://www.mql5.com/zh/job"},{"@type":"SiteNavigationElement","position":5,"name":"比率","description":"","url":"https://www.mql5.com/zh/quotes/overview"},{"@type":"SiteNavigationElement","position":6,"name":"网页端","description":"MetaTrader交易平台的网页端。在线外汇交易。","url":"https://www.mql5.com/zh/trading"},{"@type":"SiteNavigationElement","position":7,"name":"经济日历","description":"","url":"https://www.mql5.com/zh/economic-calendar"},{"@type":"SiteNavigationElement","position":8,"name":"VPS","description":"","url":"https://www.mql5.com/zh/vps"},{"@type":"SiteNavigationElement","position":9,"name":"文章","description":"","url":"https://www.mql5.com/zh/articles"},{"@type":"SiteNavigationElement","position":10,"name":"代码库","description":"下载带有源代码的自动交易，技术指标和脚本 - MetaTrader 5的MQL5代码库","url":"https://www.mql5.com/zh/code"},{"@type":"SiteNavigationElement","position":11,"name":"文档","description":"MetaQuotes Language 5 (MQL5)语言参考 - MQL5.com文档","url":"https://www.mql5.com/zh/docs"}]}
</script>


<div class="r2qgv2mfa">该网站使用cookies。了解有关我们<a href="/zh/about/cookies">Cookies政策</a>的更多信息。<span class="r2qgv2mfa__cross"></span></div><div class="GoogleAd Advertisment BannerAd" id="yandex_ad" style="width: 1px; height: 1px; visibility: hidden; position: absolute; bottom: 0px;"></div><div id="chatbot-chat" style="border: 0px; background-color: transparent; pointer-events: none; z-index: 2147483639; position: fixed; bottom: 10px; width: 0px; height: 0px; overflow: hidden; opacity: 0; max-width: 100%; right: 10px; max-height: calc(100% - 10px);"><iframe src="https://cdn.chatbot.com/widget/v2/chat.html?id=61445dd7b4f0930007793481&amp;v=733" id="chatbot-chat-frame" name="chat-widget" title="ChatBot chat widget" style="pointer-events: all; background: none; border: 0px; float: none; position: absolute; inset: 0px; width: 100%; height: 100%; margin: 0px; padding: 0px; min-height: 0px;"></iframe></div></body></html>
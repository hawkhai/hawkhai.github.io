---
title : 自动快照存档
---

* TIME: 2021-08-30 00:14:25
* URL: <https://github.com/luozhouyang/python-string-similarity>

-----

Skip to content

[ ](https://github.com/)

[ Sign up
](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-
name%3E%2F%3Crepo-name%3E&source=header-repo)

  * Why GitHub? 

[Features →](/features)

    * [Mobile →](/mobile)
    * [Actions →](/features/actions)
    * [Codespaces →](/features/codespaces)
    * [Packages →](/features/packages)
    * [Security →](/features/security)
    * [Code review →](/features/code-review/)
    * [Issues →](/features/issues/)
    * [Integrations →](/features/integrations)
    * [GitHub Sponsors →](/sponsors)
    * [Customer stories→](/customer-stories)

  * [Team](/team)
  * [Enterprise](/enterprise)
  * Explore 

    * [Explore GitHub →](/explore)

#### Learn and contribute

    * [Topics →](/topics)
    * [Collections →](/collections)
    * [Trending →](/trending)
    * [Learning Lab →](https://lab.github.com/)
    * [Open source guides →](https://opensource.guide)

#### Connect with others

    * [The ReadME Project →](https://github.com/readme)
    * [Events →](https://github.com/events)
    * [Community forum →](https://github.community)
    * [GitHub Education →](https://education.github.com)
    * [GitHub Stars program →](https://stars.github.com)

  * [Marketplace](/marketplace)
  * Pricing 

[Plans →](/pricing)

    * [Compare plans →](/pricing#feature-comparison)
    * [Contact Sales →](https://enterprise.github.com/contact)
    * [Education →](https://education.github.com)

  * [ ![]() In this repository  All GitHub  ↵ Jump to ↵ ]()

  * No suggested jump to results

  * [ ![]() In this repository  All GitHub  ↵ Jump to ↵ ]()
  * [ ![]() In this user  All GitHub  ↵ Jump to ↵ ]()
  * [ ![]() In this repository  All GitHub  ↵ Jump to ↵ ]()

[ Sign in ](/login?return_to=https%3A%2F%2Fgithub.com%2Fluozhouyang%2Fpython-
string-similarity)

[ Sign up
](/signup?ref_cta=Sign+up&ref_loc=header+logged+out&ref_page=%2F%3Cuser-
name%3E%2F%3Crepo-name%3E&source=header-repo&source_repo=luozhouyang%2Fpython-
string-similarity)

{{ message }}

#  [luozhouyang](/luozhouyang) / **[python-string-
similarity](/luozhouyang/python-string-similarity) **

  * [ Notifications ](/login?return_to=%2Fluozhouyang%2Fpython-string-similarity)
  * [ Star ](/login?return_to=%2Fluozhouyang%2Fpython-string-similarity) [ 638 ](/luozhouyang/python-string-similarity/stargazers)
  * [ Fork ](/login?return_to=%2Fluozhouyang%2Fpython-string-similarity) [ 97 ](/luozhouyang/python-string-similarity/network/members)

A library implementing different string similarity and distance measures using
Python.

[ MIT License ](/luozhouyang/python-string-similarity/blob/master/LICENSE)

[ 638 stars ](/luozhouyang/python-string-similarity/stargazers) [ 97 forks
](/luozhouyang/python-string-similarity/network/members)

[ Star ](/login?return_to=%2Fluozhouyang%2Fpython-string-similarity)

[ Notifications ](/login?return_to=%2Fluozhouyang%2Fpython-string-similarity)

  * [ Code ](/luozhouyang/python-string-similarity)
  * [ Issues 2 ](/luozhouyang/python-string-similarity/issues)
  * [ Pull requests 0 ](/luozhouyang/python-string-similarity/pulls)
  * [ Actions ](/luozhouyang/python-string-similarity/actions)
  * [ Projects 0 ](/luozhouyang/python-string-similarity/projects)
  * [ Wiki ](/luozhouyang/python-string-similarity/wiki)
  * [ Security ](/luozhouyang/python-string-similarity/security)
  * [ Insights ](/luozhouyang/python-string-similarity/pulse)

More

  * [ Code ](/luozhouyang/python-string-similarity)
  * [ Issues ](/luozhouyang/python-string-similarity/issues)
  * [ Pull requests ](/luozhouyang/python-string-similarity/pulls)
  * [ Actions ](/luozhouyang/python-string-similarity/actions)
  * [ Projects ](/luozhouyang/python-string-similarity/projects)
  * [ Wiki ](/luozhouyang/python-string-similarity/wiki)
  * [ Security ](/luozhouyang/python-string-similarity/security)
  * [ Insights ](/luozhouyang/python-string-similarity/pulse)

master

Switch branches/tags

Branches Tags

Could not load branches

Nothing to show

[ {{ refName }} default ](https://github.com/luozhouyang/python-string-
similarity/tree/{{ urlEncodedRefName }}) [View all
branches](/luozhouyang/python-string-similarity/branches)

Could not load tags

Nothing to show

[ {{ refName }} default ](https://github.com/luozhouyang/python-string-
similarity/tree/{{ urlEncodedRefName }})

[View all tags](/luozhouyang/python-string-similarity/tags)

[ **1** branch ](/luozhouyang/python-string-similarity/branches) [ **13** tags
](/luozhouyang/python-string-similarity/tags)

[ Go to file ](/luozhouyang/python-string-similarity/find/master) Code

  * [ ](https://docs.github.com/articles/which-remote-url-should-i-use)

Clone

HTTPS  GitHub CLI

Use Git or checkout with SVN using the web URL.

Work fast with our official CLI. [Learn more](https://cli.github.com).

  * [ Open with GitHub Desktop ](https://desktop.github.com)
  * [ Download ZIP ](/luozhouyang/python-string-similarity/archive/refs/heads/master.zip)

#### Launching GitHub Desktop

If nothing happens, [download GitHub Desktop](https://desktop.github.com/) and
try again.

Go back

#### Launching GitHub Desktop

If nothing happens, [download GitHub Desktop](https://desktop.github.com/) and
try again.

Go back

#### Launching Xcode

If nothing happens, [download Xcode](https://developer.apple.com/xcode/) and
try again.

Go back

#### Launching Visual Studio Code

Your codespace will open once ready.

There was a problem preparing your codespace, please try again.

## Latest commit

[ ![@luozhouyang](https://avatars.githubusercontent.com/u/34032031?s=48&v=4)
](/luozhouyang)

[luozhouyang](/luozhouyang/python-string-similarity/commits?author=luozhouyang
"View all commits by luozhouyang") [Release v0.2.0](/luozhouyang/python-
string-similarity/commit/2efcfe7a8f095964609eba6c985d70426d2a1bc1 "Release
v0.2.0")

…

Loading status checks…

[ 2efcfe7 ](/luozhouyang/python-string-
similarity/commit/2efcfe7a8f095964609eba6c985d70426d2a1bc1) [ on 15 Dec 2020
](/luozhouyang/python-string-
similarity/commit/2efcfe7a8f095964609eba6c985d70426d2a1bc1)

[Release v0.2.0](/luozhouyang/python-string-
similarity/commit/2efcfe7a8f095964609eba6c985d70426d2a1bc1)

`2efcfe7`

## Git stats

  * [ **78** commits  ](/luozhouyang/python-string-similarity/commits/master)

## Files

[Permalink](/luozhouyang/python-string-
similarity/tree/2efcfe7a8f095964609eba6c985d70426d2a1bc1)

Failed to load latest commit information.

Type

Name

Latest commit message

Commit time

[.github/workflows](/luozhouyang/python-string-
similarity/tree/master/.github/workflows "This path skips through empty
directories")

[Test Python 3.9](/luozhouyang/python-string-
similarity/commit/932952dbca07e57aa50ddc77cfd8507d62b34089 "Test Python 3.9")

9 months ago

[strsimpy](/luozhouyang/python-string-similarity/tree/master/strsimpy
"strsimpy")

[Release v0.2.0](/luozhouyang/python-string-
similarity/commit/2efcfe7a8f095964609eba6c985d70426d2a1bc1 "Release v0.2.0")

9 months ago

[.gitignore](/luozhouyang/python-string-similarity/blob/master/.gitignore
".gitignore")

[Rename package](/luozhouyang/python-string-
similarity/commit/de6dc4cd9db43850dafd619c3caeaac8580ea203 "Rename package")

2 years ago

[LICENSE](/luozhouyang/python-string-similarity/blob/master/LICENSE "LICENSE")

[Initial commit](/luozhouyang/python-string-
similarity/commit/f1d9b6139de856a2dbd0193a61aad64cf266b01e "Initial commit")

3 years ago

[README.md](/luozhouyang/python-string-similarity/blob/master/README.md
"README.md")

[Perfect SIFT4](/luozhouyang/python-string-
similarity/commit/1d7e32198e44210aac13c72d1b83b22e57b26513 "Perfect SIFT4")

11 months ago

[requirements.txt](/luozhouyang/python-string-
similarity/blob/master/requirements.txt "requirements.txt")

[Revert "Added New similarity algorithm using Gensim Library
"](/luozhouyang/python-string-
similarity/commit/39f279c9c0bbbf4a586e1707f7f9f0e153e975fa "Revert "Added New
similarity algorithm using Gensim Library "")

2 years ago

[setup.py](/luozhouyang/python-string-similarity/blob/master/setup.py
"setup.py")

[Release v0.2.0](/luozhouyang/python-string-
similarity/commit/2efcfe7a8f095964609eba6c985d70426d2a1bc1 "Release v0.2.0")

9 months ago

View code

python-string-similarity Download Overview Normalized, metric, similarity and
distance (Normalized) similarity and distance Metric distances Shingles
(n-gram) based similarity and distance Levenshtein Normalized Levenshtein
Weighted Levenshtein Damerau-Levenshtein Optimal String Alignment Jaro-Winkler
Longest Common Subsequence Metric Longest Common Subsequence N-Gram Shingle
(n-gram) based algorithms Q-Gram Cosine similarity Jaccard index Sorensen-Dice
coefficient Overlap coefficient (i.e., Szymkiewicz-Simpson) Experimental SIFT4
Users

##  README.md

# python-string-similarity

[![Python package](https://github.com/luozhouyang/python-string-
similarity/workflows/Python%20package/badge.svg)](https://github.com/luozhouyang/python-
string-similarity/workflows/Python%20package/badge.svg) [![PyPI
version](https://camo.githubusercontent.com/320bb0acbd1cb08dde1805c9266b94602fc03c9d5c0904972ecacdb6d082991a/68747470733a2f2f62616467652e667572792e696f2f70792f73747273696d70792e737667)](https://badge.fury.io/py/strsimpy)
[![Python](https://camo.githubusercontent.com/9da7bc2fa67f25b1e8279ed644c39b5c5d5eaeb6f5322d8be44fa56004a31c96/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f73747273696d70792e7376673f7374796c653d706c6173746963)](https://badge.fury.io/py/strsimpy)

Python3.x implementation of [tdebatty/java-string-
similarity](https://github.com/tdebatty/java-string-similarity)

A library implementing different string similarity and distance measures. A
dozen of algorithms (including Levenshtein edit distance and sibblings, Jaro-
Winkler, Longest Common Subsequence, cosine similarity etc.) are currently
implemented. Check the summary table below for the complete list...

  * python-string-similarity
    * Download
    * Overview
    * Normalized, metric, similarity and distance
      * (Normalized) similarity and distance
      * Metric distances
    * Shingles (n-gram) based similarity and distance
    * Levenshtein
    * Normalized Levenshtein
    * Weighted Levenshtein
    * Damerau-Levenshtein
    * Optimal String Alignment
    * Jaro-Winkler
    * Longest Common Subsequence
    * Metric Longest Common Subsequence
    * N-Gram
    * Shingle (n-gram) based algorithms
      * Q-Gram
      * Cosine similarity
      * Jaccard index
      * Sorensen-Dice coefficient
      * Overlap coefficient (i.e., Szymkiewicz-Simpson)
    * Experimental
      * SIFT4
    * Users

## Download

From pypi:

    
    
    # pip install strsim # deprecated, do not use this!
    pip install -U strsimpy

## Overview

The main characteristics of each implemented algorithm are presented below.
The "cost" column gives an estimation of the computational cost to compute the
similarity between two strings of length m and n respectively.

|  | Normalized? | Metric? | Type | Cost | Typical usage  
---|---|---|---|---|---|---  
Levenshtein | distance | No | Yes |  | O(m*n) 1 |  
Normalized Levenshtein | distance  
similarity | Yes | No |  | O(m*n) 1 |  
Weighted Levenshtein | distance | No | No |  | O(m*n) 1 | OCR  
Damerau-Levenshtein 3 | distance | No | Yes |  | O(m*n) 1 |  
Optimal String Alignment 3 | distance | No | No |  | O(m*n) 1 |  
Jaro-Winkler | similarity  
distance | Yes | No |  | O(m*n) | typo correction  
Longest Common Subsequence | distance | No | No |  | O(m*n) 1,2 | diff
utility, GIT reconciliation  
Metric Longest Common Subsequence | distance | Yes | Yes |  | O(m*n) 1,2 |  
N-Gram | distance | Yes | No |  | O(m*n) |  
Q-Gram | distance | No | No | Profile | O(m+n) |  
Cosine similarity | similarity  
distance | Yes | No | Profile | O(m+n) |  
Jaccard index | similarity  
distance | Yes | Yes | Set | O(m+n) |  
Sorensen-Dice coefficient | similarity  
distance | Yes | No | Set | O(m+n) |  
Overlap coefficient | similarity  
distance | Yes | No | Set | O(m+n) |  
  
[1] In this library, Levenshtein edit distance, LCS distance and their
sibblings are computed using the **dynamic programming** method, which has a
cost O(m.n). For Levenshtein distance, the algorithm is sometimes called
**Wagner-Fischer algorithm** ("The string-to-string correction problem",
1974). The original algorithm uses a matrix of size m x n to store the
Levenshtein distance between string prefixes.

If the alphabet is finite, it is possible to use the **method of four
russians** (Arlazarov et al. "On economic construction of the transitive
closure of a directed graph", 1970) to speedup computation. This was published
by Masek in 1980 ("A Faster Algorithm Computing String Edit Distances"). This
method splits the matrix in blocks of size t x t. Each possible block is
precomputed to produce a lookup table. This lookup table can then be used to
compute the string similarity (or distance) in O(nm/t). Usually, t is choosen
as log(m) if m > n. The resulting computation cost is thus O(mn/log(m)). This
method has not been implemented (yet).

[2] In "Length of Maximal Common Subsequences", K.S. Larsen proposed an
algorithm that computes the length of LCS in time O(log(m).log(n)). But the
algorithm has a memory requirement O(m.n²) and was thus not implemented here.

[3] There are two variants of Damerau-Levenshtein string distance: Damerau-
Levenshtein with adjacent transpositions (also sometimes called unrestricted
Damerau–Levenshtein distance) and Optimal String Alignment (also sometimes
called restricted edit distance). For Optimal String Alignment, no substring
can be edited more than once.

## Normalized, metric, similarity and distance

Although the topic might seem simple, a lot of different algorithms exist to
measure text similarity or distance. Therefore the library defines some
interfaces to categorize them.

### (Normalized) similarity and distance

  * StringSimilarity : Implementing algorithms define a similarity between strings (0 means strings are completely different).
  * NormalizedStringSimilarity : Implementing algorithms define a similarity between 0.0 and 1.0, like Jaro-Winkler for example.
  * StringDistance : Implementing algorithms define a distance between strings (0 means strings are identical), like Levenshtein for example. The maximum distance value depends on the algorithm.
  * NormalizedStringDistance : This interface extends StringDistance. For implementing classes, the computed distance value is between 0.0 and 1.0. NormalizedLevenshtein is an example of NormalizedStringDistance.

Generally, algorithms that implement NormalizedStringSimilarity also implement
NormalizedStringDistance, and similarity = 1 - distance. But there are a few
exceptions, like N-Gram similarity and distance (Kondrak)...

### Metric distances

The MetricStringDistance interface : A few of the distances are actually
metric distances, which means that verify the triangle inequality d(x, y) <=
d(x,z) + d(z,y). For example, Levenshtein is a metric distance, but
NormalizedLevenshtein is not.

A lot of nearest-neighbor search algorithms and indexing structures rely on
the triangle inequality.

## Shingles (n-gram) based similarity and distance

A few algorithms work by converting strings into sets of n-grams (sequences of
n characters, also sometimes called k-shingles). The similarity or distance
between the strings is then the similarity or distance between the sets.

Some of them, like jaccard, consider strings as sets of shingles, and don't
consider the number of occurences of each shingle. Others, like cosine
similarity, work using what is sometimes called the profile of the strings,
which takes into account the number of occurences of each shingle.

For these algorithms, another use case is possible when dealing with large
datasets:

  1. compute the set or profile representation of all the strings
  2. compute the similarity between sets or profiles

## Levenshtein

The Levenshtein distance between two words is the minimum number of single-
character edits (insertions, deletions or substitutions) required to change
one word into the other.

It is a metric string distance. This implementation uses dynamic programming
(Wagner–Fischer algorithm), with only 2 rows of data. The space requirement is
thus O(m) and the algorithm runs in O(m.n).

    
    
    from strsimpy.levenshtein import Levenshtein
    
    levenshtein = Levenshtein()
    print(levenshtein.distance('My string', 'My $string'))
    print(levenshtein.distance('My string', 'My $string'))
    print(levenshtein.distance('My string', 'My $string'))

## Normalized Levenshtein

This distance is computed as levenshtein distance divided by the length of the
longest string. The resulting value is always in the interval [0.0 1.0] but it
is not a metric anymore!

The similarity is computed as 1 - normalized distance.

    
    
    from strsimpy.normalized_levenshtein import NormalizedLevenshtein
    
    normalized_levenshtein = NormalizedLevenshtein()
    print(normalized_levenshtein.distance('My string', 'My $string'))
    print(normalized_levenshtein.distance('My string', 'My $string'))
    print(normalized_levenshtein.distance('My string', 'My $string'))
    
    print(normalized_levenshtein.similarity('My string', 'My $string'))
    print(normalized_levenshtein.similarity('My string', 'My $string'))
    print(normalized_levenshtein.similarity('My string', 'My $string'))

## Weighted Levenshtein

An implementation of Levenshtein that allows to define different weights for
different character substitutions.

This algorithm is usually used for optical character recognition (OCR)
applications. For OCR, the cost of substituting P and R is lower then the cost
of substituting P and M for example because because from and OCR point of view
P is similar to R.

It can also be used for keyboard typing auto-correction. Here the cost of
substituting E and R is lower for example because these are located next to
each other on an AZERTY or QWERTY keyboard. Hence the probability that the
user mistyped the characters is higher.

    
    
    from strsimpy.weighted_levenshtein import WeightedLevenshtein
    
    
    def insertion_cost(char):
        return 1.0
    
    
    def deletion_cost(char):
        return 1.0
    
    
    def substitution_cost(char_a, char_b):
        if char_a == 't' and char_b == 'r':
            return 0.5
        return 1.0
    
    weighted_levenshtein = WeightedLevenshtein(
        substitution_cost_fn=substitution_cost,
        insertion_cost_fn=insertion_cost,
        deletion_cost_fn=deletion_cost)
    print(weighted_levenshtein.distance('String1', 'String2'))

## Damerau-Levenshtein

Similar to Levenshtein, Damerau-Levenshtein distance with transposition (also
sometimes calls unrestricted Damerau-Levenshtein distance) is the minimum
number of operations needed to transform one string into the other, where an
operation is defined as an insertion, deletion, or substitution of a single
character, or a **transposition of two adjacent characters**.

It does respect triangle inequality, and is thus a metric distance.

This is not to be confused with the optimal string alignment distance, which
is an extension where no substring can be edited more than once.

    
    
    from strsimpy.damerau import Damerau
    
    damerau = Damerau()
    print(damerau.distance('ABCDEF', 'ABDCEF'))
    print(damerau.distance('ABCDEF', 'BACDFE'))
    print(damerau.distance('ABCDEF', 'ABCDE'))
    print(damerau.distance('ABCDEF', 'BCDEF'))
    print(damerau.distance('ABCDEF', 'ABCGDEF'))
    print(damerau.distance('ABCDEF', 'POIU'))

Will produce:

    
    
    1.0
    2.0
    1.0
    1.0
    1.0
    6.0
    

## Optimal String Alignment

The Optimal String Alignment variant of Damerau–Levenshtein (sometimes called
the restricted edit distance) computes the number of edit operations needed to
make the strings equal under the condition that **no substring is edited more
than once** , whereas the true Damerau–Levenshtein presents no such
restriction. The difference from the algorithm for Levenshtein distance is the
addition of one recurrence for the transposition operations.

Note that for the optimal string alignment distance, the triangle inequality
does not hold and so it is not a true metric.

    
    
    from strsimpy.optimal_string_alignment import OptimalStringAlignment
    
    optimal_string_alignment = OptimalStringAlignment()
    print(optimal_string_alignment.distance('CA', 'ABC'))

Will produce:

    
    
    3.0
    

## Jaro-Winkler

Jaro-Winkler is a string edit distance that was developed in the area of
record linkage (duplicate detection) (Winkler, 1990). The Jaro–Winkler
distance metric is designed and best suited for short strings such as person
names, and to detect typos.

Jaro-Winkler computes the similarity between 2 strings, and the returned value
lies in the interval [0.0, 1.0]. It is (roughly) a variation of Damerau-
Levenshtein, where the substitution of 2 close characters is considered less
important then the substitution of 2 characters that a far from each other.

The distance is computed as 1 - Jaro-Winkler similarity.

    
    
    from strsimpy.jaro_winkler import JaroWinkler
    
    jarowinkler = JaroWinkler()
    print(jarowinkler.similarity('My string', 'My tsring'))
    print(jarowinkler.similarity('My string', 'My ntrisg'))

will produce:

    
    
    0.9740740740740741
    0.8962962962962963
    

## Longest Common Subsequence

The longest common subsequence (LCS) problem consists in finding the longest
subsequence common to two (or more) sequences. It differs from problems of
finding common substrings: unlike substrings, subsequences are not required to
occupy consecutive positions within the original sequences.

It is used by the diff utility, by Git for reconciling multiple changes, etc.

The LCS distance between strings X (of length n) and Y (of length m) is n + m
- 2 |LCS(X, Y)| min = 0 max = n + m

LCS distance is equivalent to Levenshtein distance when only insertion and
deletion is allowed (no substitution), or when the cost of the substitution is
the double of the cost of an insertion or deletion.

This class implements the dynamic programming approach, which has a space
requirement O(m.n), and computation cost O(m.n).

In "Length of Maximal Common Subsequences", K.S. Larsen proposed an algorithm
that computes the length of LCS in time O(log(m).log(n)). But the algorithm
has a memory requirement O(m.n²) and was thus not implemented here.

    
    
    from strsimpy.longest_common_subsequence import LongestCommonSubsequence
    lcs = LongestCommonSubsequence()
    print(lcs.distance('AGCAT', 'GAC'))
    4
    print(lcs.length('AGCAT', 'GAC'))
    2
    print(lcs.distance('AGCAT', 'AGCT'))
    1
    print(lcs.length('AGCAT', 'AGCT'))
    4

## Metric Longest Common Subsequence

Distance metric based on Longest Common Subsequence, from the notes "An LCS-
based string metric" by Daniel Bakkelund.
<http://heim.ifi.uio.no/~danielry/StringMetric.pdf>

The distance is computed as 1 - |LCS(s1, s2)| / max(|s1|, |s2|)

    
    
    from strsimpy.metric_lcs import MetricLCS
    
    metric_lcs = MetricLCS()
    s1 = 'ABCDEFG'
    s2 = 'ABCDEFHJKL'
    
    # LCS: ABCDEF => length = 6
    # longest = s2 => length = 10
    # => 1 - 6/10 = 0.4
    print(metric_lcs.distance(s1, s2))
    
    # LCS: ABDF => length = 4
    # longest = ABDEF => length = 5
    # => 1 - 4 / 5 = 0.2
    print(metric_lcs.distance('ABDEF', 'ABDIF'))

will produce:

    
    
    0.4
    0.19999999999999996
    

## N-Gram

Normalized N-Gram distance as defined by Kondrak, "N-Gram Similarity and
Distance", String Processing and Information Retrieval, Lecture Notes in
Computer Science Volume 3772, 2005, pp 115-126.

<http://webdocs.cs.ualberta.ca/~kondrak/papers/spire05.pdf>

The algorithm uses affixing with special character '\n' to increase the weight
of first characters. The normalization is achieved by dividing the total
similarity score the original length of the longest word.

In the paper, Kondrak also defines a similarity measure, which is not
implemented (yet).

    
    
    from strsimpy.ngram import NGram
    
    twogram = NGram(2)
    print(twogram.distance('ABCD', 'ABTUIO'))
    
    s1 = 'Adobe CreativeSuite 5 Master Collection from cheap 4zp'
    s2 = 'Adobe CreativeSuite 5 Master Collection from cheap d1x'
    fourgram = NGram(4)
    print(fourgram.distance(s1, s2))

## Shingle (n-gram) based algorithms

A few algorithms work by converting strings into sets of n-grams (sequences of
n characters, also sometimes called k-shingles). The similarity or distance
between the strings is then the similarity or distance between the sets.

The cost for computing these similarities and distances is mainly domnitated
by k-shingling (converting the strings into sequences of k characters).
Therefore there are typically two use cases for these algorithms:

Directly compute the distance between strings:

    
    
    from strsimpy.qgram import QGram
    
    qgram = QGram(2)
    print(qgram.distance('ABCD', 'ABCE'))

Or, for large datasets, pre-compute the profile of all strings. The similarity
can then be computed between profiles:

    
    
    from strsimpy.cosine import Cosine
    
    cosine = Cosine(2)
    s0 = 'My first string'
    s1 = 'My other string...'
    p0 = cosine.get_profile(s0)
    p1 = cosine.get_profile(s1)
    print(cosine.similarity_profiles(p0, p1))

Pay attention, this only works if the same KShingling object is used to parse
all input strings !

### Q-Gram

Q-gram distance, as defined by Ukkonen in "Approximate string-matching with
q-grams and maximal matches"
<http://www.sciencedirect.com/science/article/pii/0304397592901434>

The distance between two strings is defined as the L1 norm of the difference
of their profiles (the number of occurences of each n-gram): SUM( |V1_i -
V2_i| ). Q-gram distance is a lower bound on Levenshtein distance, but can be
computed in O(m + n), where Levenshtein requires O(m.n)

### Cosine similarity

The similarity between the two strings is the cosine of the angle between
these two vectors representation, and is computed as V1 . V2 / (|V1| * |V2|)

Distance is computed as 1 - cosine similarity.

### Jaccard index

Like Q-Gram distance, the input strings are first converted into sets of
n-grams (sequences of n characters, also called k-shingles), but this time the
cardinality of each n-gram is not taken into account. Each input string is
simply a set of n-grams. The Jaccard index is then computed as |V1 inter V2| /
|V1 union V2|.

Distance is computed as 1 - similarity. Jaccard index is a metric distance.

### Sorensen-Dice coefficient

Similar to Jaccard index, but this time the similarity is computed as 2 * |V1
inter V2| / (|V1| + |V2|).

Distance is computed as 1 - similarity.

### Overlap coefficient (i.e., Szymkiewicz-Simpson)

Very similar to Jaccard and Sorensen-Dice measures, but this time the
similarity is computed as |V1 inter V2| / Min(|V1|,|V2|). Tends to yield
higher similarity scores compared to the other overlapping coefficients.
Always returns the highest similarity score (1) if one given string is the
subset of the other.

Distance is computed as 1 - similarity.

## Experimental

### SIFT4

SIFT4 is a general purpose string distance algorithm inspired by JaroWinkler
and Longest Common Subsequence. It was developed to produce a distance measure
that matches as close as possible to the human perception of string distance.
Hence it takes into account elements like character substitution, character
distance, longest common subsequence etc. It was developed using experimental
testing, and without theoretical background.

    
    
    from strsimpy import SIFT4
    
    s = SIFT4()
    
    # result: 11.0
    s.distance('This is the first string', 'And this is another string') # 11.0
    # result: 12.0
    s.distance('Lorem ipsum dolor sit amet, consectetur adipiscing elit.', 'Amet Lorm ispum dolor sit amet, consetetur adixxxpiscing elit.', maxoffset=10)

## Users

  * [StringSimilarity.NET](https://github.com/feature23/StringSimilarity.NET) a .NET port of java-string-similarity

Use java-string-similarity in your project and want it to be mentioned here?
Don't hesitate to drop me a line!

## About

A library implementing different string similarity and distance measures using
Python.

### Topics

[ python ](/topics/python "Topic: python") [ algorithm ](/topics/algorithm
"Topic: algorithm") [ string ](/topics/string "Topic: string") [ similarity
](/topics/similarity "Topic: similarity") [ distance-measure
](/topics/distance-measure "Topic: distance-measure")

### Resources

Readme

### License

[ MIT License ](/luozhouyang/python-string-similarity/blob/master/LICENSE)

##  [ Releases 13 ](/luozhouyang/python-string-similarity/releases)

[ Release v0.2.0 Latest  on 15 Dec 2020 ](/luozhouyang/python-string-
similarity/releases/tag/v0.2.0)

[ \+ 12 releases ](/luozhouyang/python-string-similarity/releases)

##  [ Packages 0 ](/users/luozhouyang/packages?repo_name=python-string-
similarity)

No packages published  

##  [ Used by 188 ](/luozhouyang/python-string-
similarity/network/dependents?package_id=UGFja2FnZS02MjA5Mjg1MzI%3D)

[

  * ![@DarekarA](https://avatars.githubusercontent.com/u/63337436?s=88&u=5bf53d2288aa1a9c8bab474a7a4eda9f0be75a89&v=4)
  * ![@yyht](https://avatars.githubusercontent.com/u/14133687?s=88&v=4)
  * ![@markotalledo](https://avatars.githubusercontent.com/u/79496490?s=88&u=e28ead05c5cd93dc47399a7bbfd99afc89ffa95c&v=4)
  * ![@Rafiatun](https://avatars.githubusercontent.com/u/78837797?s=88&u=9d516bafccdee4c4ad744fafd365122b02c930e4&v=4)
  * ![@dsa2021](https://avatars.githubusercontent.com/u/86169610?s=88&v=4)
  * ![@SameerGodbole1](https://avatars.githubusercontent.com/u/87891647?s=88&v=4)
  * ![@ThreeGiantNoobs](https://avatars.githubusercontent.com/u/83164527?s=88&v=4)
  * ![@Taftsummerset1](https://avatars.githubusercontent.com/u/64021351?s=88&v=4)

\+ 180  ](/luozhouyang/python-string-
similarity/network/dependents?package_id=UGFja2FnZS02MjA5Mjg1MzI%3D)

##  [ Contributors 7 ](/luozhouyang/python-string-
similarity/graphs/contributors)

  * [ ![@luozhouyang](https://avatars.githubusercontent.com/u/34032031?v=4) ](https://github.com/luozhouyang)
  * [ ![@raszidzie](https://avatars.githubusercontent.com/u/42200400?v=4) ](https://github.com/raszidzie)
  * [ ![@pajusmar](https://avatars.githubusercontent.com/u/472587?v=4) ](https://github.com/pajusmar)
  * [ ![@gokhanercan](https://avatars.githubusercontent.com/u/1479777?v=4) ](https://github.com/gokhanercan)
  * [ ![@lanzkron](https://avatars.githubusercontent.com/u/11015162?v=4) ](https://github.com/lanzkron)
  * [ ![@urigoren](https://avatars.githubusercontent.com/u/6126173?v=4) ](https://github.com/urigoren)
  * [ ![@matthijsz](https://avatars.githubusercontent.com/u/34677839?v=4) ](https://github.com/matthijsz)

## Languages

  * [ Python 100.0% ](/luozhouyang/python-string-similarity/search?l=python)

  * © 2021 GitHub, Inc.
  * [Terms](https://docs.github.com/en/github/site-policy/github-terms-of-service)
  * [Privacy](https://docs.github.com/en/github/site-policy/github-privacy-statement)
  * [Security](https://github.com/security)
  * [Status](https://www.githubstatus.com/)
  * [Docs](https://docs.github.com)

[ ](https://github.com "GitHub")

  * [Contact GitHub](https://support.github.com)
  * [Pricing](https://github.com/pricing)
  * [API](https://docs.github.com)
  * [Training](https://services.github.com)
  * [Blog](https://github.blog)
  * [About](https://github.com/about)

You can’t perform that action at this time.

You signed in with another tab or window. [Reload]() to refresh your session.
You signed out in another tab or window. [Reload]() to refresh your session.

